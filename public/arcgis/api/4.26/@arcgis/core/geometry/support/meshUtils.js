/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{a as t,i as r}from"../../chunks/maybe.js";import{throwIfAborted as o}from"../../core/promiseUtils.js";import e from"../Mesh.js";import{b as s,u as n,g as i}from"../../chunks/georeference.js";import{L as c}from"../../chunks/Logger.js";import{a,g as p,d as m}from"../../chunks/vec3.js";import u,{M as l}from"./MeshComponent.js";import{M as f}from"../../chunks/MeshTransform.js";import"../../chunks/typedArrayUtil.js";import"../../core/Error.js";import"../../core/lang.js";import"../../chunks/object.js";import"../../config.js";import"../../chunks/string.js";import"../../chunks/tslib.es6.js";import"../../core/HandleOwner.js";import"../../core/Accessor.js";import"../../core/Handles.js";import"../../core/accessorSupport/decorators/subclass.js";import"../../chunks/metadata.js";import"../../chunks/utils.js";import"../../chunks/handleUtils.js";import"../../chunks/tracking.js";import"../../chunks/ensureType.js";import"../../chunks/get.js";import"../../chunks/ArrayPool.js";import"../../core/accessorSupport/decorators/property.js";import"../../chunks/watch.js";import"../../core/scheduling.js";import"../../chunks/nextTick.js";import"../../chunks/WatchUpdatingTracking.js";import"../../core/reactiveUtils.js";import"../../core/Loadable.js";import"../../core/Promise.js";import"../Extent.js";import"../Geometry.js";import"../../core/JSONSupport.js";import"../../chunks/reader.js";import"../SpatialReference.js";import"../../chunks/unitUtils.js";import"../../chunks/jsonMap.js";import"../../chunks/Ellipsoid.js";import"../../chunks/writer.js";import"../Point.js";import"../../core/accessorSupport/decorators/cast.js";import"./webMercatorUtils.js";import"../Polygon.js";import"../../chunks/extentUtils.js";import"../../chunks/aaBoundingRect.js";import"../../chunks/mathUtils.js";import"../../chunks/vec4.js";import"../../chunks/common.js";import"../../chunks/zmUtils.js";import"../../chunks/axisAngleDegrees.js";import"../../chunks/quat.js";import"../../chunks/quatf64.js";import"../../chunks/triangulationUtils.js";import"../../chunks/earcut.js";import"../../chunks/DoubleArray.js";import"../../chunks/Indices.js";import"../../chunks/deduplicate.js";import"../projection.js";import"../../chunks/SimpleObservable.js";import"../../chunks/mat4.js";import"../Multipoint.js";import"../../chunks/pe.js";import"../../chunks/assets.js";import"../../request.js";import"../../kernel.js";import"../../core/urlUtils.js";import"../Polyline.js";import"../../chunks/geodesicConstants.js";import"./GeographicTransformation.js";import"./GeographicTransformationStep.js";import"../../chunks/zscale.js";import"../../chunks/mat3.js";import"../../chunks/mat3f64.js";import"../../chunks/mat4f64.js";import"../../chunks/spatialReferenceEllipsoidUtils.js";import"../../chunks/projection.js";import"../../chunks/BufferView.js";import"../../chunks/vec2.js";import"../../chunks/vec32.js";import"./MeshMaterial.js";import"../../Color.js";import"../../chunks/colorUtils.js";import"./MeshTexture.js";import"../../chunks/imageUtils.js";import"../../chunks/persistableUrlUtils.js";import"./MeshMaterialMetallicRoughness.js";const h=c.getLogger("esri.geometry.support.triangleMeshMerge");function j(t,o){if(!o.rebake)return t.vertexAttributes;const e=s(t.vertexAttributes,t.transform,t.spatialReference);return r(o.transform)?n(e,o.transform.getOriginPoint(t.spatialReference),{geographic:o.transform.geographic}):e}function g(t,r,o){(function(t,r){return r.normal>0&&!t.vertexAttributes.normal})(t,r)&&"source"===o.shading&&(o.shading="flat")}function k(t,r,o,e,s){if(t.components)for(const n of t.components){const i=n.cloneWithDeduplication(o,e),c=r.position/3;if(i.faces)for(let t=0;t<i.faces.length;t++)i.faces[t]+=c;else{i.faces=new Uint32Array(t.vertexAttributes.position.length/3);for(let t=0;t<i.faces.length;t++)i.faces[t]=t+c}g(t,r,i),s.push(i)}else if(t.vertexAttributes&&t.vertexAttributes.position){const o=t.vertexAttributes.position.length/3,e=new Uint32Array(o),n=r.position/3;for(let t=0;t<o;t++)e[t]=t+n;const i=new u({faces:e});g(t,r,i),s.push(i)}}function b(o,e,s,n,i){if(!e)return;const c=e.position;if(!c)return;const a=e[o],p=s[o];if(t(a)){let t=n[o];const e=d[o];if(r(p)){for(let r=0;r<c.length;r+=3)for(let r=0;r<e;r++)p[t++]=i;n[o]=t}}else r(p)&&r(a)&&(function(t,r,o,e,s){for(let n=0;n<s;n++)o[e++]=t[r++]}(a,0,p,n[o],a.length),n[o]+=a.length)}const d={position:3,normal:3,tangent:4,uv:2,color:4};async function v(t,r,e){const s=await import("../../chunks/elevation.js");return o(e),s.create(t,r,e)}async function A(t,r){return await t.load(),(await import("../../chunks/elevationSampler.js")).create(t,r)}function w(t,r,o){return i(t,r,o)}function y(t,r,o){return n(t,r,o)}function U(o){const s=function(o,e){if(0===o.length)return h.error("merge()","Must specify one more geometries to merge"),null;const s=o[0].spatialReference;for(const t of o){if(!t.spatialReference.equals(s))return h.error("merge()","Geometries must all be in the same spatial reference"),null;if(!t.loaded)return h.error("merge()","Geometries must all be loaded before merging"),null}const n=function(o){let e=null,s=!0;const n=m();let i=0,c=!1;for(const p of o)if(!r(e)||!t(p.transform)&&p.transform.equals(e)||(s=!1),r(p.transform)){if(e&&e.geographic!==p.transform.geographic)return h.error("merge()","Inconsistent geographic mode for provided geometries transform. Some are geographic while others are not, unable to merge geometries."),null;t(e)&&(e=p.transform),p.transform.geographic&&(c=!0),i++,a(n,n,p.transform.origin)}if(t(e))return{transform:null,rebake:!1};if(s)return{transform:e.clone(),rebake:!1};const u=p(n,n,1/i);return{transform:new f({origin:u,geographic:c}),rebake:!0}}(o);if(t(n))return null;const i=function(t){let r=0,o=0,e=0,s=0,n=0;const i=function(t){let r=!1,o=!1,e=!1,s=!1;for(const n of t){const t=n.vertexAttributes;if(t&&t.position&&(t.uv&&(r=!0),t.normal&&(o=!0),t.tangent&&(s=!0),t.color&&(e=!0),o&&r&&e&&s))break}return{normal:o,uv:r,color:e,tangent:s}}(t);for(const c of t){const t=c.vertexAttributes;t&&t.position&&(r+=t.position.length,i.uv&&(o+=t.position.length/d.position*d.uv),i.normal&&(e+=t.position.length/d.position*d.normal),i.color&&(s+=t.position.length/d.position*d.color),i.tangent&&(n+=t.position.length/d.position*d.tangent))}return new l({position:new Float64Array(r),uv:o?new Float32Array(o):null,normal:e?new Float32Array(e):null,tangent:n?new Float32Array(n):null,color:s?new Uint8Array(s):null})}(o),c=[],u={position:0,uv:0,normal:0,tangent:0,color:0},g=new Map,v=new Map;for(const t of o){const r=j(t,n);e,k(t,u,g,v,c),b("position",r,i,u,0),b("normal",r,i,u,0),b("tangent",r,i,u,0),b("uv",t.vertexAttributes,i,u,0),b("color",t.vertexAttributes,i,u,255)}return{vertexAttributes:i,components:c,transform:n.transform,spatialReference:s}}(o);return r(s)?new e(s):null}export{A as createElevationSampler,v as createFromElevation,w as georeference,U as merge,y as ungeoreference};
