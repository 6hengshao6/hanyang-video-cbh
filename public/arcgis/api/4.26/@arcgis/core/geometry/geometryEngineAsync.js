/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import"../geometry.js";import{open as t}from"../core/workers/workers.js";import r from"./Point.js";import{fromJSON as n}from"./support/jsonUtils.js";import"../chunks/ensureType.js";import"../chunks/typedArrayUtil.js";import"../chunks/maybe.js";import"../chunks/Logger.js";import"../config.js";import"../chunks/object.js";import"../core/lang.js";import"../chunks/string.js";import"./Extent.js";import"../chunks/tslib.es6.js";import"../core/accessorSupport/decorators/property.js";import"../chunks/get.js";import"../chunks/utils.js";import"../chunks/handleUtils.js";import"../chunks/metadata.js";import"../core/Error.js";import"../core/accessorSupport/decorators/subclass.js";import"../chunks/tracking.js";import"./Geometry.js";import"../core/JSONSupport.js";import"../core/Accessor.js";import"../core/Handles.js";import"../chunks/ArrayPool.js";import"../chunks/watch.js";import"../core/scheduling.js";import"../chunks/nextTick.js";import"../core/promiseUtils.js";import"../chunks/reader.js";import"./SpatialReference.js";import"../chunks/unitUtils.js";import"../chunks/jsonMap.js";import"../chunks/Ellipsoid.js";import"../chunks/writer.js";import"./support/webMercatorUtils.js";import"../core/accessorSupport/decorators/cast.js";import"./Multipoint.js";import"../chunks/zmUtils.js";import"./Polygon.js";import"../chunks/extentUtils.js";import"../chunks/aaBoundingRect.js";import"../chunks/mathUtils.js";import"../chunks/vec3.js";import"../chunks/common.js";import"../chunks/vec4.js";import"./Polyline.js";import"../chunks/typeUtils.js";import"../core/workers/Connection.js";import"../chunks/Queue.js";import"../core/workers/RemoteClient.js";import"../kernel.js";import"../core/urlUtils.js";import"../chunks/assets.js";import"../request.js";import"../intl.js";import"../chunks/number.js";import"../chunks/locale.js";import"../chunks/messages.js";function e(t){return Array.isArray(t)?t[0]?.spatialReference:t?.spatialReference}function o(t){return t?Array.isArray(t)?t.map(o):t.toJSON?t.toJSON():t:t}function s(t){return Array.isArray(t)?t.map((t=>n(t))):n(t)}let i;async function c(){return i||(i=t("geometryEngineWorker",{strategy:"distributed"})),i}async function a(t,r){return(await c()).invoke("executeGEOperation",{operation:t,parameters:o(r)})}async function u(t,r){const n=await c();return Promise.all(n.broadcast("executeGEOperation",{operation:t,parameters:o(r)}))}function p(t){return a("extendedSpatialReferenceInfo",[t])}async function m(t,r){return s(await a("clip",[e(t),t,r]))}async function f(t,r){return s(await a("cut",[e(t),t,r]))}function l(t,r){return a("contains",[e(t),t,r])}function j(t,r){return a("crosses",[e(t),t,r])}function y(t,r,n){return a("distance",[e(t),t,r,n])}function h(t,r){return a("equals",[e(t),t,r])}function w(t,r){return a("intersects",[e(t),t,r])}function k(t,r){return a("touches",[e(t),t,r])}function d(t,r){return a("within",[e(t),t,r])}function g(t,r){return a("disjoint",[e(t),t,r])}function S(t,r){return a("overlaps",[e(t),t,r])}function x(t,r,n){return a("relate",[e(t),t,r,n])}function A(t){return a("isSimple",[e(t),t])}async function R(t){return s(await a("simplify",[e(t),t]))}async function O(t,r=!1){return s(await a("convexHull",[e(t),t,r]))}async function U(t,r){return s(await a("difference",[e(t),t,r]))}async function J(t,r){return s(await a("symmetricDifference",[e(t),t,r]))}async function N(t,r){return s(await a("intersect",[e(t),t,r]))}async function b(t,r=null){const n=function(t,r){let n;return Array.isArray(t)?n=t:(n=[],n.push(t),null!=r&&n.push(r)),n}(t,r);return s(await a("union",[e(n),n]))}async function E(t,r,n,o,i,c){return s(await a("offset",[e(t),t,r,n,o,i,c]))}async function P(t,r,n,o=!1){const i=[e(t),t,r,n,o];return s(await a("buffer",i))}async function v(t,r,n,o,i,c){const u=[e(t),t,r,n,o,i,c];return s(await a("geodesicBuffer",u))}async function T(t,n,o=!0){const s=await a("nearestCoordinate",[e(t),t,n,o]);return{...s,coordinate:r.fromJSON(s.coordinate)}}async function D(t,n){const o=await a("nearestVertex",[e(t),t,n]);return{...o,coordinate:r.fromJSON(o.coordinate)}}async function L(t,n,o,s){return(await a("nearestVertices",[e(t),t,n,o,s])).map((t=>({...t,coordinate:r.fromJSON(t.coordinate)})))}function z(t){return"xmin"in t?t.center:"x"in t?t:t.extent?.center}async function C(t,r,n){if(null==t)throw new Y;const e=t.spatialReference;if(null==(n=n??z(t)))throw new Y;const o=t.constructor.fromJSON(await a("rotate",[e,t,r,n]));return o.spatialReference=e,o}async function G(t,r){if(null==t)throw new Y;const n=t.spatialReference;if(null==(r=r??z(t)))throw new Y;const e=t.constructor.fromJSON(await a("flipHorizontal",[n,t,r]));return e.spatialReference=n,e}async function H(t,r){if(null==t)throw new Y;const n=t.spatialReference;if(null==(r=r??z(t)))throw new Y;const e=t.constructor.fromJSON(await a("flipVertical",[n,t,r]));return e.spatialReference=n,e}async function M(t,r,n,o){return s(await a("generalize",[e(t),t,r,n,o]))}async function V(t,r,n){return s(await a("densify",[e(t),t,r,n]))}async function q(t,r,n,o=0){return s(await a("geodesicDensify",[e(t),t,r,n,o]))}function B(t,r){return a("planarArea",[e(t),t,r])}function I(t,r){return a("planarLength",[e(t),t,r])}function Q(t,r,n){return a("geodesicArea",[e(t),t,r,n])}function W(t,r,n){return a("geodesicLength",[e(t),t,r,n])}async function F(t,r){return s(await a("intersectLinesToPoints",[e(t),t,r]))}async function K(t,r){await u("changeDefaultSpatialReferenceTolerance",[t,r])}async function X(t){await u("clearDefaultSpatialReferenceTolerance",[t])}class Y extends Error{constructor(){super("Illegal Argument Exception")}}export{P as buffer,K as changeDefaultSpatialReferenceTolerance,X as clearDefaultSpatialReferenceTolerance,m as clip,l as contains,O as convexHull,j as crosses,f as cut,V as densify,U as difference,g as disjoint,y as distance,h as equals,p as extendedSpatialReferenceInfo,G as flipHorizontal,H as flipVertical,M as generalize,Q as geodesicArea,v as geodesicBuffer,q as geodesicDensify,W as geodesicLength,N as intersect,F as intersectLinesToPoints,w as intersects,A as isSimple,T as nearestCoordinate,D as nearestVertex,L as nearestVertices,E as offset,S as overlaps,B as planarArea,I as planarLength,x as relate,C as rotate,R as simplify,J as symmetricDifference,k as touches,b as union,d as within};
