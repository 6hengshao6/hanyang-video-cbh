/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import e from"../core/Error.js";import{a as r,i as a}from"./maybe.js";import{getFilename as t,urlToObject as s}from"../core/urlUtils.js";import{p as l,f as o}from"./arcgisLayerUrl.js";import{a as n,f as i}from"./fetchService.js";import{o as u}from"./layerUtils.js";import{l as c}from"./lazyLayerLoader.js";import"../core/lang.js";import"./typedArrayUtil.js";import"./Logger.js";import"../config.js";import"./object.js";import"./string.js";import"./persistableUrlUtils.js";import"../request.js";import"../kernel.js";import"../core/promiseUtils.js";const y={FeatureLayer:!0,SceneLayer:!0};async function m(m){const d=m.properties?.customParameters,I=await async function(m,p){let d=l(m);if(r(d)&&(d=await async function(e,r){const l=await n(e,{customParameters:r});let i=null,u=null;const c=l.type;if("Feature Layer"===c||"Table"===c?(i="FeatureServer",u=l.id??null):"indexedVector"===c?i="VectorTileServer":l.hasOwnProperty("mapName")?i="MapServer":l.hasOwnProperty("bandCount")&&l.hasOwnProperty("pixelSizeX")?i="ImageServer":l.hasOwnProperty("maxRecordCount")&&l.hasOwnProperty("allowGeometryUpdates")?i="FeatureServer":l.hasOwnProperty("streamUrls")?i="StreamServer":f(l)?(i="SceneServer",u=l.id):l.hasOwnProperty("layers")&&f(l.layers?.[0])&&(i="SceneServer"),!i)return null;const y=null!=u?o(e):null;return{title:a(y)&&l.name||t(e),serverType:i,sublayer:u,url:{path:a(y)?y.serviceUrl:s(e).path}}}(m,p)),r(d))throw new e("arcgis-layers:url-mismatch","The url '${url}' is not a valid arcgis resource",{url:m});const{serverType:I,sublayer:b}=d;let S;const w={FeatureServer:"FeatureLayer",StreamServer:"StreamLayer",VectorTileServer:"VectorTileLayer"};switch(I){case"MapServer":if(null!=b)S="FeatureLayer";else{const e=await async function(e,r){return(await n(e,{customParameters:r})).tileInfo}(m,p);S=e?"TileLayer":"MapImageLayer"}break;case"ImageServer":{const e=await n(m,{customParameters:p}),{tileInfo:r,cacheType:a}=e;S=r?"LERC"!==r?.format?.toUpperCase()||a&&"elevation"!==a.toLowerCase()?"ImageryTileLayer":"ElevationLayer":"ImageryLayer";break}case"SceneServer":{const e=await n(d.url.path,{customParameters:p});if(S="SceneLayer",e){const r=e?.layers;if("Voxel"===e?.layerType)S="VoxelLayer";else if(r?.length){const e=r[0]?.layerType;null!=e&&null!=u[e]&&(S=u[e])}}break}default:S=w[I]}const v="FeatureServer"===I,h={parsedUrl:d,Constructor:null,layerOrTableId:v?b:void 0,sublayerIds:null,tableIds:null};if(y[S]&&null==b){const e=await async function(e,r,a){let t,s=!1;if("FeatureServer"===r){const r=await i(e,{customParameters:a});s=!!r.layersJSON,t=r.layersJSON||r.serviceJSON}else t=await n(e,{customParameters:a});const l=t?.layers,o=t?.tables;return{layerIds:l?.map((e=>e.id)).reverse()||[],tableIds:o?.map((e=>e.id)).reverse()||[],layerInfos:s?l:[],tableInfos:s?o:[]}}(m,I,p);v&&(h.sublayerInfos=e.layerInfos,h.tableInfos=e.tableInfos),1!==e.layerIds.length+e.tableIds.length?(h.sublayerIds=e.layerIds,h.tableIds=e.tableIds):v&&(h.layerOrTableId=e.layerIds[0]??e.tableIds[0],h.sourceJSON=e.layerInfos?.[0]??e.tableInfos?.[0])}return h.Constructor=await async function(e){return(0,c[e])()}(S),h}(m.url,d),b={...m.properties,url:m.url};if(!I.sublayerIds)return null!=I.layerOrTableId&&(b.layerId=I.layerOrTableId,b.sourceJSON=I.sourceJSON),new I.Constructor(b);const S=new(0,(await import("../layers/GroupLayer.js")).default)({title:I.parsedUrl.title});return function(e,r,t){function s(e,s){const l={...t,layerId:e,sublayerTitleMode:"service-name"};return a(s)&&(l.sourceJSON=s),new r.Constructor(l)}r.sublayerIds.forEach((a=>{const t=s(a,p(r.sublayerInfos,a));e.add(t)})),r.tableIds.forEach((a=>{const t=s(a,p(r.tableInfos,a));e.tables.add(t)}))}(S,I,b),S}function p(e,r){return e?e.find((e=>e.id===r)):null}function f(e){return null!=e&&e.hasOwnProperty("store")&&e.hasOwnProperty("id")&&"number"==typeof e.id}export{m as fromUrl};
