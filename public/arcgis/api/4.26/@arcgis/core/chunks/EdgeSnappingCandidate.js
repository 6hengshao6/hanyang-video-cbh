/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{i as t,t as s,e}from"./maybe.js";import{b as n,u as r,e as i,q as o,g as a,a as c,f as u}from"./vec2.js";import{a as f,d as h}from"./vec2f64.js";import{d as p,s as d,p as l,m as L,w as E,k as m,b as A,h as y,K as N,f as k,j as P}from"./vec3.js";import{j as g,h as q,L as x}from"./snappingUtils.js";import{j as I}from"./mathUtils.js";import{L as j}from"./geometry2dUtils.js";import{a as T,L as b}from"./LineSnappingHint.js";function R({start:t,end:s,type:e},a,c){const u=[],h=n(C,s,t),p=n(K,t,a),d=r(h),l=2*i(h,p),L=l*l-4*d*(r(p)-c*c);if(0===L){const s=-l/(2*d);(e===G.PLANE||s>=0)&&u.push(o(f(),t,h,s))}else if(L>0){const s=Math.sqrt(L),n=(-l+s)/(2*d);(e===G.PLANE||n>=0)&&u.push(o(f(),t,h,n));const r=(-l-s)/(2*d);(e===G.PLANE||r>=0)&&u.push(o(f(),t,h,r))}return u}function w(t,s){const e=t.start,r=t.end,o=n(C,r,e),c=d(K,-o[1],o[0],0),u=s.start,f=s.end,h=l(V,f,u),p=L(h,c),A=d(z,e[0],e[1],0),y=l(B,A,u),N=L(y,c);if(Math.abs(p)<S)return Math.abs(N),[];const k=E(J,u,h,N/p);if(s.type===j.RAY){const t=l(Q,k,u);if(L(t,h)<-S)return[]}if(t.type===G.HALF_PLANE){const t=a(Q,k,e);if(i(t,o)<-S)return[]}return[m(k)]}function F(t,s){return v(U(W,s[2],t),s)}function M(t,s){const e=_(U(W,0,t),U(X,0,s)),n=[];for(const t of e)n.push(h(t));return n}function H(t,s){return Y(t,U(W,t[2],s))}function Y(t,{start:s,end:e,type:n}){const r=l(C,t,s),i=l(K,e,s),o=L(r,i)/L(i,i);return E(p(),s,i,n===j.RAY?Math.max(o,0):o)}function Z({start:t,end:s,type:e},o,a){const c=[],u=A(C,s,t),f=n(K,t,o),h=r(u),d=2*i(u,f),l=d*d-4*h*(r(f)-a*a);if(0===l){const s=-d/(2*h);(e===j.LINE||s>=0)&&c.push(E(p(),t,u,s))}else if(l>0){const s=Math.sqrt(l),n=(-d+s)/(2*h);(e===j.LINE||n>=0)&&c.push(E(p(),t,u,n));const r=(-d-s)/(2*h);(e===j.LINE||r>=0)&&c.push(E(p(),t,u,r))}return c}function _(t,s){const e=t.start,n=t.end,r=s.start,i=s.end,o=l(C,n,e),a=l(K,i,r),c=l(V,r,e),u=y(z,o,a),f=L(c,u);if(!I(f,0,S))return[];const h=N(u);if(I(h,0,S))return[];const p=y(B,c,a),d=L(p,u)/h,A=E(J,e,o,d);if(t.type===j.RAY){const t=l(Q,A,e);if(L(o,t)<-S)return[]}if(s.type===j.RAY){const t=l(Q,A,r);if(L(a,t)<-S)return[]}return[m(A)]}function v({start:t,end:s,type:e},n){const r=l(C,n,t),i=l(K,s,t),o=y(V,i,r);if(N(o)/N(i)<S)switch(e){case j.LINE:return[m(n)];case j.RAY:return L(i,r)<-S?[]:[m(n)]}return[]}function D(t,s,e){return I(c(e,t),s*s,S)?[m(e)]:[]}function U(t,s,{start:e,end:n,type:r}){return d(t.start,e[0],e[1],s),d(t.end,n[0],n[1],s),t.type=O[r],t}var G;!function(t){t[t.PLANE=0]="PLANE",t[t.HALF_PLANE=1]="HALF_PLANE"}(G||(G={}));const O={[G.PLANE]:j.LINE,[G.HALF_PLANE]:j.RAY},S=1e-6,C=p(),K=p(),V=p(),z=p(),B=p(),J=p(),Q=p(),W={start:p(),end:p(),type:j.LINE},X={start:p(),end:p(),type:j.LINE};class ${intersect(t){return function(t,s){let e=[];if(ht(t)){const{point:n}=t;pt(s)?e=v(s.lineLike,n):dt(s)?e=D(s.center,s.radius,n):lt(s)?e=F(s.planeLike,n):Lt(s)&&(e=ft(s,t))}else if(pt(t)){const{lineLike:n}=t;ht(s)?e=v(n,s.point):pt(s)?e=_(n,s.lineLike):dt(s)?e=Z(n,s.center,s.radius):lt(s)?e=w(s.planeLike,n):Lt(s)&&(e=ft(s,t))}else if(dt(t)){const{center:n,radius:r}=t;if(pt(s))e=Z(s.lineLike,n,r);else if(ht(s))e=D(n,r,s.point);else{if(lt(s))return R(s.planeLike,n,r).map((e=>new rt(e,t,s)));Lt(s)&&(e=ft(s,t))}}else if(lt(t)){const{planeLike:n}=t;if(lt(s))return M(n,s.planeLike).map((e=>new rt(e,t,s)));if(ht(s))e=F(n,s.point);else if(pt(s))e=w(n,s.lineLike);else{if(dt(s))return R(n,s.center,s.radius).map((e=>new rt(e,t,s)));Lt(s)&&(e=ft(s,t))}}else Lt(t)&&(e=ft(t,s));return function(t,s,e){return t.map((t=>new nt(q(t),s,e)))}(e,t,s)}(this,t)}}class tt extends ${constructor(t){super(),this.point=t}equals(t){return ht(t)&&P(this.point,t.point)}closestTo(){return g(this.point)}}class st extends ${constructor(t,s,e){super(),this.start=t,this.end=s,this.type=e,this.lineLike={start:this.start,end:this.end,type:this.type}}equals(t){return pt(t)&&this.type===t.type&&P(this.start,t.start)&&P(this.end,t.end)}closestTo(t){const s=Y(t,this.lineLike);return q(s)}}class et extends st{constructor(t,s){super(t,s,j.LINE)}}class nt extends ${constructor(t,s,e){super(),this.intersection=t,this.first=s,this.second=e}equals(t){return t instanceof nt&&this.first.equals(t.first)&&this.second.equals(t.second)}closestTo(){return g(this.intersection)}}class rt extends ${constructor(t,s,e){super(),this.basePoint=t,this.first=s,this.second=e}equals(t){return t instanceof rt&&this.first.equals(t.first)&&this.second.equals(t.second)}closestTo(t){const s=this.basePoint;return q(k(s[0],s[1],t[2]))}}class it extends ${constructor(t,s){super(),this.center=t,this.radius=s}equals(t){return dt(t)&&this.center[0]===t.center[0]&&this.center[1]===t.center[1]&&this.radius===t.radius}closestTo(t){const s=function(t,s,e){const r=n(C,t,s),i=e/u(r),a=o(p(),s,r,i);return a[2]=t[2],a}(t,this.center,this.radius);return q(s)}}class ot extends ${constructor(t,s,e){super(),this.start=t,this.end=s,this.type=e,this.planeLike={start:t,end:s,type:e}}equals(t){return lt(t)&&this.type===t.type&&P(this.start,t.start)&&P(this.end,t.end)}closestTo(t){return q(H(t,this.planeLike))}closestEndTo(t){const{start:s,end:e}=this;return Math.sign(i(n(Et,e,s),n(mt,t,s)))>0?e:s}}class at extends ot{constructor(t,s){super(t,s,G.HALF_PLANE)}}class ct extends ot{constructor(t,s){super(t,s,G.PLANE)}}class ut extends ${constructor(t,s,e){super(),this.start=t,this.end=s,this.getZ=e,this.planeLike={start:t,end:s,type:G.PLANE}}equals(t){return Lt(t)&&P(this.start,t.start)&&P(this.end,t.end)&&this.getZ===t.getZ}closestTo(t){return function(t,e){const n=H(e,t.planeLike);return n[2]=s(t.getZ(e[0],e[1],e[2]))??At,q(n)}(this,t)}addIfOnTheGround(t,s){for(const n of s){const s=e(this.getZ(n[0],n[1],n[2]),0);Math.abs(n[2]-s)<S&&(n[2]=s,t.push(n))}}}function ft(e,n){const{planeLike:r,getZ:i}=e,o=[];if(ht(n))e.addIfOnTheGround(o,F(r,n.point));else if(pt(n))e.addIfOnTheGround(o,w(r,n.lineLike));else if(dt(n))for(const[s,e]of R(r,n.center,n.radius)){const n=i(s,e,0);t(n)&&o.push(k(s,e,n))}else if(lt(n)||Lt(n))for(const[t,e]of M(r,n.planeLike)){const n=s(i(t,e,0))??At;o.push(k(t,e,n))}return o}function ht(t){return t instanceof tt}function pt(t){return t instanceof st}function dt(t){return t instanceof it}function lt(t){return t instanceof ot}function Lt(t){return t instanceof ut}const Et=f(),mt=f(),At=0;class yt{constructor(t,s,e,n){this.targetPoint=t,this.constraint=s,this.isDraped=e,this.domain=n}}class Nt extends yt{constructor({targetPoint:t,objectId:s,constraint:e,isDraped:n}){super(t,e,n,T.FEATURE),this.objectId=s}}class kt extends Nt{constructor(t){super({...t,constraint:new et(t.edgeStart,t.edgeEnd)})}get hints(){return[new b(x.REFERENCE,this.constraint.start,this.constraint.end,this.isDraped,this.domain)]}}export{ut as D,kt as E,Nt as F,nt as I,tt as P,yt as S,at as V,ct as a,it as b,Y as p};
