/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import"../geometry.js";import e from"../core/Error.js";import{u as n,i}from"./maybe.js";import{a}from"./screenUtils.js";import t from"../geometry/SpatialReference.js";import{q as o}from"./quantizationUtils.js";import{d as s,h as l}from"./unitUtils.js";import{isNumericField as r,numericTypes as u}from"../layers/support/fieldUtils.js";import{c as f,e as m}from"./heatmapUtils.js";import{p as d,g as c,i as p,c as y,a as h,b as v,d as I,e as x,f as z,r as T,h as $}from"./utils10.js";import{l as g}from"./arcadeOnDemand.js";import w from"../geometry/Point.js";let F=null;async function j(e,n){if(!n)return[];const{field:i,field2:a,field3:o,fieldDelimiter:s}=e,l=e.valueExpression,r=e.normalizationType,u=e.normalizationField,f=e.normalizationTotal,m=[],p=e.viewInfoParams;let y=null,h=null;if(l){if(!F){const{arcadeUtils:e}=await g();F=e}y=F.createFunction(l),h=p&&F.getViewInfo({viewingMode:p.viewingMode,scale:p.scale,spatialReference:new t(p.spatialReference)})}const v=e.fieldInfos,I=n[0]&&"declaredClass"in n[0]&&"esri.Graphic"===n[0].declaredClass||!v?null:{fields:v};return n.forEach((e=>{const n=e.attributes;let t;if(l){const n=I?{...e,layer:I}:e,i=F.createExecContext(n,h);t=F.executeFunction(y,i)}else n&&(t=n[i],a&&(t=`${d(t)}${s}${d(n[a])}`,o&&(t=`${t}${s}${d(n[o])}`)));if(r&&"number"==typeof t&&isFinite(t)){const e=n&&parseFloat(n[u]);t=c(t,r,e,f)}m.push(t)})),m}function b(e){const n=e.field,i=e.normalizationType,a=e.normalizationField;let t;return"field"===i?t="(NOT "+a+" = 0)":"log"!==i&&"natural-log"!==i&&"square-root"!==i||(t=`(${n} > 0)`),t}function E(e,n,i){const a=null!=n?e+" >= "+n:"",t=null!=i?e+" <= "+i:"";let o="";return o=a&&t?D(a,t):a||t,o?"("+o+")":""}function V(n,i,a,t){let o;return i?i.name!==n.objectIdField&&t.includes(i.type)||(o=new e(a,"'field' should be one of these types: "+t.join(","))):o=new e(a,"'field' is not defined in the layer schema"),o}function M(n,i,a){let t;return i?i.name!==n.objectIdField&&r(i)||(t=new e(a,"'field' should be one of these numeric types: "+u.join(","))):t=new e(a,"'field' is not defined in the layer schema"),t}function D(e,n){let a=i(e)?e:"";return i(n)&&n&&(a=a?"("+a+") AND ("+n+")":n),a}function P(n,i){if(n&&"intersects"!==n.spatialRelationship)return new e(i,"Only 'intersects' spatialRelationship is supported for featureFilter")}function N(n,i,a){const t=function(e){const n=e.layer;return e.fields.filter((e=>!n.getField(e)))}({layer:n,fields:i});if(t.length)return new e(a,"Unknown fields: "+t.join(", ")+". You can only use fields defined in the layer schema");const o=function(e){const n=e.layer;return e.fields.filter((e=>{const i=n.getFieldUsageInfo(e);return!i||!i.supportsStatistics}))}({layer:n,fields:i});return o.length?new e(a,"Unsupported fields: "+o.join(", ")+". You can only use fields that can be fetched i.e. AdapterFieldUsageInfo.supportsStatistics must be true"):void 0}function S(e,n,i){const a=[],t=[],o=[],s=[],l=[];e.forEach(((e,n)=>{const r=e.field?"field":"expression",u=e.field||e.valueExpression;e.field?(l.push(u),t.push(`var ${r}${n} = Number($feature["${u}"]);`)):(a.push(`function getValueForExpr${n}() {\n  ${u} \n}`),t.push(`var ${r}${n} = Number(getValueForExpr${n}());`)),i||o.push(`${r}${n} = IIf(${r}${n} < 0, 0, ${r}${n});`),s.push(`${r}${n}`)}));let r="return sum;";const u=a.length?null:l.reduce(((e,n)=>`${e} + ${n}`));let f=null;return n||i?n?i||(r="return IIf(sum >= 0, sum, null);",u&&(f=`(( ${u} ) >= 0)`)):(r="return IIf(sum != 0, sum, null);",u&&(f=`(( ${u} ) <> 0)`)):(r="return IIf(sum > 0, sum, null);",u&&(f=`(( ${u} ) > 0)`)),{valueExpression:[a.length?a.join("\n"):"",t.join("\n"),o.join("\n"),`var sum = ${s.join(" + ")};`,r].filter(Boolean).join("\n\n"),sqlExpression:u,sqlWhere:f}}async function U(e){const{attribute:n,features:i}=e,{normalizationType:a,normalizationField:t,minValue:o,maxValue:s,fieldType:l}=n,r=await j({field:n.field,valueExpression:n.valueExpression,normalizationType:a,normalizationField:t,normalizationTotal:n.normalizationTotal,viewInfoParams:n.viewInfoParams,fieldInfos:n.fieldInfos},i),u=p({normalizationType:a,normalizationField:t,minValue:o,maxValue:s}),f={value:.5,fieldType:l},m="esriFieldTypeString"===l?y({values:r,supportsNullCount:u,percentileParams:f}):h({values:r,minValue:o,maxValue:s,useSampleStdDev:!a,supportsNullCount:u,percentileParams:f});return v(m,"esriFieldTypeDate"===l)}async function C(e){const{attribute:n,features:i}=e,a=await j({field:n.field,field2:n.field2,field3:n.field3,fieldDelimiter:n.fieldDelimiter,valueExpression:n.valueExpression,viewInfoParams:n.viewInfoParams,fieldInfos:n.fieldInfos},i),t=I(a);return x(t,n.domains,n.returnAllCodedValues,n.fieldDelimiter)}async function q(e){const{attribute:n,features:i}=e,{field:a,normalizationType:t,normalizationField:o,normalizationTotal:s,classificationMethod:l}=n,r=await j({field:a,valueExpression:n.valueExpression,normalizationType:t,normalizationField:o,normalizationTotal:s,viewInfoParams:n.viewInfoParams,fieldInfos:n.fieldInfos},i),u=z(r,{field:a,normalizationType:t,normalizationField:o,normalizationTotal:s,classificationMethod:l,standardDeviationInterval:n.standardDeviationInterval,numClasses:n.numClasses,minValue:n.minValue,maxValue:n.maxValue});return T(u,l)}async function O(e){const{attribute:n,features:i}=e,{field:a,normalizationType:t,normalizationField:o,normalizationTotal:s,classificationMethod:l}=n,r=await j({field:a,valueExpression:n.valueExpression,normalizationType:t,normalizationField:o,normalizationTotal:s,viewInfoParams:n.viewInfoParams,fieldInfos:n.fieldInfos},i);return $(r,{field:a,normalizationType:t,normalizationField:o,normalizationTotal:s,classificationMethod:l,standardDeviationInterval:n.standardDeviationInterval,numBins:n.numBins,minValue:n.minValue,maxValue:n.maxValue})}async function R(e){const{attribute:i,features:t}=e,{field:r,radius:u,fieldOffset:d,transform:c,spatialReference:p}=i,y=i.size??[0,0],h=function(e,i,a,t){const r=s(a)?l(a):null,u=r?Math.round((r.valid[1]-r.valid[0])/i.scale[0]):null;return e.map((e=>{const a=new w(n(e.geometry));return o(i,a,a,a.hasZ,a.hasM),e.geometry=r?function(e,n,i){return e.x<0?e.x+=n:e.x>i&&(e.x-=n),e}(a,u??0,t[0]):a,e}))}(t??[],c,p,y),{count:v,min:I,max:x,mean:z,stdDev:T}=function(e,n=18,i,t,o,s){const l=new Float64Array(o*s);n=Math.round(a(n));let r=Number.POSITIVE_INFINITY,u=Number.NEGATIVE_INFINITY,d=0,c=0,p=0,y=0;const h=f(t,i);for(const{geometry:i,attributes:a}of e){const{x:e,y:t}=i,f=Math.max(0,e-n),v=Math.max(0,t-n),I=Math.min(s,t+n),x=Math.min(o,e+n),z=+h(a);for(let i=v;i<I;i++)for(let a=f;a<x;a++){const s=i*o+a,f=m(a-e,i-t,n),h=l[s];d=l[s]+=f*z;const v=d-h;c+=v,p+=v*v,d<r&&(r=d),d>u&&(u=d),y++}}if(!y)return{mean:0,stddev:0,min:0,max:0,mid:0,count:0};const v=(u-r)/2;return{mean:c/y,stdDev:Math.sqrt((p-c*c/y)/y),min:r,max:u,mid:v,count:y}}(h,u??void 0,d,r,y[0],y[1]);return{count:v,min:I,max:x,avg:z,stddev:T}}const _=Object.freeze(Object.defineProperty({__proto__:null,classBreaks:q,heatmapStatistics:R,histogram:O,summaryStatistics:U,uniqueValues:C},Symbol.toStringTag,{value:"Module"}));export{E as a,R as b,q as c,j as d,M as e,P as f,b as g,O as h,V as i,S as j,_ as k,D as m,U as s,C as u,N as v};
