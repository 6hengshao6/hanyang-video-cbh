/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import e from"../Camera.js";import"../geometry.js";import t from"../Graphic.js";import n from"../Viewpoint.js";import{r}from"./asyncUtils.js";import"./typedArrayUtil.js";import{C as a,a as i,c as o}from"./Cyclical.js";import s from"../core/Error.js";import{e as c,i as l,a as u,u as f}from"./maybe.js";import{createResolver as m,eachAlways as p}from"../core/promiseUtils.js";import{f as d,t as g}from"./mat3.js";import{c as h}from"./mat3f64.js";import{c as y}from"./mat4f64.js";import{c as v,H as x,g as w,b as M,a as R,m as b,l as T,d as z,n as j,h as S,e as G,f as C,E as A,k as P,J as D,D as E,s as U,t as H}from"./vec3.js";import{projectPointToVector as O,projectVectorToVector as k,projectVectorToPoint as F,project as I,projectBuffer as B,computeTranslationToOriginAndRotation as L}from"../geometry/projection.js";import{c as q,k as W,o as Z,u as J,v as _,e as K,b as N,w as V,r as X,q as Y}from"./aaBoundingBox.js";import{p as $,c as Q,r as ee}from"./aaBoundingRect.js";import{o as te}from"./frustum.js";import{c as ne}from"./scaleUtils.js";import{geographicToWebMercator as re,project as ae,canProject as ie}from"../geometry/support/webMercatorUtils.js";import{B as oe}from"./unitUtils.js";import{a as se}from"./Intersector2.js";import{L as ce}from"./Logger.js";import{r as le,b as ue,d as fe,a as me}from"./mathUtils.js";import pe from"../geometry/Point.js";import de from"../geometry/SpatialReference.js";import{V as ge}from"./ViewingMode.js";import{y as he,o as ye,a as ve,A as xe}from"./mat4.js";import we from"../geometry/Extent.js";import{g as Me,a as Re}from"./earthUtils.js";import{g as be}from"./ElevationProvider.js";import{i as Te}from"./spatialReferenceSupport.js";import ze from"../geometry/Geometry.js";function je(e,t,n,r){return l(e.renderCoordsHelper.fromRenderCoords(t.eye,Pe,r))&&$(n,Pe)}function Se(e,t){return e.elevationProvider?c(e.elevationProvider.getElevation(t[0],t[1],t[2],e.renderCoordsHelper.spatialReference,"ground"),0):0}function Ge(e,t,n,r){const a=e.state.camera.clone();t&&n&&r&&(a.eye=t,a.center=n,a.up=r),function(e,t,n){let r=Ae[e.viewingMode];r||(r=se(e.state.viewingMode),r.options.backfacesTerrain=!e.state.isGlobal,r.options.invisibleTerrain=!0,Ae[e.viewingMode]=r);const{isGlobal:a}=e.state;return!(!e.sceneIntersectionHelper.intersectRay(t,r,n)||Ce(e,t.origin,n))||!(!e.renderCoordsHelper.intersectManifold(t,0,n)||Ce(e,t.origin,n))||!!a&&function(e,t,n){const r=b(e.origin,e.origin)-n*n,a=r>0?Math.sqrt(r)/3:1;return w(t,e.direction,a/T(e.direction)),R(t,t,e.origin),!0}(t,n,oe(e.spatialReference).radius)}(e,a.ray,De)||v(De,a.center);const i=e.state.constraints,o=i.minimumPoiDistance;if(x(a.eye,De)<o){const t=i.collision.enabled;v(Ee,a.viewForward),w(Ee,Ee,o),t?a.eye=M(Pe,De,Ee):R(De,a.eye,Ee);const n=e.renderCoordsHelper,r=n.getAltitude(a.eye),s=i.collision.elevationMargin;t&&r<s&&(M(Ee,De,a.eye),a.eye=n.setAltitude(Pe,s,a.eye),R(De,a.eye,Ee))}return a.center=De,a}function Ce(e,t,n){if(!e.state.isGlobal||!e.stateManager.constraintsManager)return!1;const r=Se(e,t),a=e.stateManager.constraintsManager.nearFarHeuristic,{far:i}=a.compute(t,n,e.renderDataExtent,r,Ue),o=i*i;return x(t,n)>o}const Ae={},Pe=z(),De=z(),Ee=z(),Ue={near:0,far:0},He=z(),Oe=z();function ke(){return{direction:z(),up:z()}}function Fe(e,t,n,r,a){let i=j(He,e),o=b(i,r);const s=o>0;o=Math.abs(o),o>.99&&(o=Math.abs(b(t,r)),o<.99?(v(i,t),s&&w(i,i,-1)):i=null);let c=0;if(i){w(Oe,r,b(r,i)),M(i,i,Oe);const e=b(i,a)/(T(i)*T(a));S(Oe,i,a),c=(b(Oe,r)>0?1:-1)*le(ue(e))}const l=le(ue(-b(r,e)/T(e)));return n?(n.heading=c,n.tilt=l,n):{heading:c,tilt:l}}const Ie=C(0,1,0),Be=C(0,0,1),Le=y(),qe=z(),We=z();function Ze(e,t,n,r=ke()){const{direction:a,up:i}=r;return he(Le,-fe(t)),ye(Le,Le,fe(n)),G(a,Be,Le),w(a,a,-1),G(i,Ie,Le),r}function Je(e,t,n,r,a){const i=e.renderSpatialReference,o=e.map&&e.spatialReference||t.spatialReference;return O(t,qe,i),O(t,We,i),qe[0]-=n/2,We[0]+=n/2,qe[1]-=r/2,We[1]+=r/2,k(qe,i,qe,o),k(We,i,We,o),a?(a.xmin=qe[0],a.ymin=qe[1],a.xmax=We[0],a.ymax=We[1],a.spatialReference=o):a=new we(qe[0],qe[1],We[0],We[1],o),a}const _e=Object.freeze(Object.defineProperty({__proto__:null,directionToHeadingTilt:function(e,t,n,r){return Fe(t,n,r,Be,Ie)},eyeForCenterWithHeadingTilt:function(e,t,n,r){const a=Ze(0,n,r),i=z();return w(i,a.direction,-t),R(i,i,e),{up:a.up,eye:i,heading:n,tilt:r}},eyeTiltToLookAtTilt:function(e){return fe(e)},headingTiltToDirectionUp:Ze,lookAtTiltToEyeTilt:function(e){return le(e)},toExtent:Je},Symbol.toStringTag,{value:"Module"})),Ke=C(0,0,1),Ne=j(z(),C(1,1,1)),Ve=new a(-180,180),Xe=y(),Ye=z(),$e=z();function Qe(e,t,n,r=ke()){S(Ye,e,Ke),0===b(Ye,Ye)&&S(Ye,e,Ne),ve(Xe,-fe(t),e),xe(Xe,Xe,-fe(n),Ye);const{up:a,direction:i}=r;return S(a,Ye,e),j(a,a),G(a,a,Xe),j(i,e),A(i,i),G(i,i,Xe),r}function et(e){const t=e[1];e[1]=-e[2],e[2]=t}function tt(e,t){const n=Qe(t,e.heading,e.tilt);return e.up=n.up,e}function nt(e,t,n,r,a){let o,s,c,l;const u=t.latitude,f=oe(e.spatialReference).radius,m=t.longitude,p=Me(u,n,f)/2;o=m-p,s=m+p;const d=fe(u),g=(1+Math.sin(d))/(1-Math.sin(d)),h=(g+1)*Math.tan(r/f/2),y=h*h;function v(e){const t=Math.PI/2;return(e=i.normalize(e,-t))>t&&(e=Math.PI-e),e}if(c=1.5*Math.PI-2*Math.atan(.5*(h+Math.sqrt(4*g+y))),l=c+r/f,c=v(c),l=v(l),l<c){const e=l;l=c,c=e}if(c=Math.max(le(c),-90),l=Math.min(le(l),90),s=Ve.monotonic(o,s),s-o>180){const e=(s-o-180)/2;o+=e,s-=e}const x=e.spatialReference&&e.spatialReference.isGeographic?e.spatialReference:de.WGS84;return a?(a.xmin=o,a.ymin=c,a.xmax=s,a.ymax=l,a.spatialReference=x):a=new we(o,c,s,l,x),e.spatialReference&&e.spatialReference.isWebMercator&&re(a,!1,a),a}const rt=Object.freeze(Object.defineProperty({__proto__:null,directionToHeadingTilt:function(e,t,n,r){const a=Ye,i=$e;return j(a,e),S($e,a,Ke),0===b($e,$e)&&S($e,a,Ne),S(i,$e,a),Fe(t,n,r,a,i)},eyeForCenterWithHeadingTilt:function(e,t,n,r){const a={eye:z(),up:null,tilt:r,heading:n},i=Ye;i[0]=e[0],i[1]=e[2],i[2]=-e[1];const o=t,s=fe(n),c=fe(r),l=Math.sin(s),u=Math.cos(s),f=Math.sin(c),m=Math.cos(c),p=T(i);let d;if(Math.abs(c)<1e-8)d=o+p;else{const e=p/f,t=me(o/e),n=Math.PI-c-t;d=e*Math.sin(n)}const g=m*o,h=o*o*(f*f),y=u*u*h,v=d-g,x=v*v,M=y*(y+x-i[1]*i[1]);if(M<0)return w(a.eye,i,d/p),a.tilt=0,tt(a,e);const R=Math.sqrt(M),b=i[1]*v,j=y+x;let S;if(S=u>0?-R+b:R+b,Math.abs(j)<1e-8)return p<1e-8?(a.eye[0]=0,a.eye[1]=0,a.eye[2]=o):w(a.eye,i,d/p),a.tilt=0,et(a.eye),tt(a,e);a.eye[1]=S/j;const G=l*l*h,C=f*o,A=u*C*a.eye[1],P=a.eye[1]*a.eye[1],D=1-P,E=Math.sqrt(D),U=y*P+G-2*A*E*v+D*x;return Math.abs(U)<1e-8?(w(a.eye,i,d/p),a.tilt=0,et(a.eye),tt(a,e)):(a.eye[0]=(D*(d*i[0]-g*i[0])-C*E*(i[0]*a.eye[1]*u+i[2]*l))/U,a.eye[2]=(D*(d*i[2]-g*i[2])-C*E*(i[2]*a.eye[1]*u-i[0]*l))/U,w(a.eye,a.eye,d),et(a.eye),tt(a,e))},eyeTiltToLookAtTilt:function(e,t,n){const r=fe(e),a=T(t);return me(n/(a/Math.sin(r)))+r},headingTiltToDirectionUp:Qe,lookAtTiltToEyeTilt:function(e,t,n){const r=T(t),a=Math.sqrt(n*n+r*r-2*n*r*Math.cos(Math.PI-e)),i=me(n/(a/Math.sin(e)));return le(e-i)},toExtent:nt},Symbol.toStringTag,{value:"Module"})),at=ce.getLogger("esri.views.3d.support.cameraUtils"),it=39.37,ot=96,st=1,ct=8,lt=5,ut=1,ft=z(),mt={heading:0,tilt:0},pt=new pe,dt=new a(-20037508.342788905,20037508.342788905),gt=new a(-180,180);var ht;function yt(e){return e.spatialReference||de.WGS84}function vt(e){return"global"===e.viewingMode?rt:_e}function xt(e,t,n,r,a){return vt(e).headingTiltToDirectionUp(t,n,r,a)}function wt(e,t){if(u(t))return null;const n=e.renderSpatialReference,r=vt(e).headingTiltToDirectionUp,a=z();if(!O(t.position,a,n))return null;const i=r(a,t.heading,t.tilt);w(i.direction,i.direction,e.state.camera.distance),R(i.direction,i.direction,a);const o=Ge(e,a,i.direction,i.up);return o.fov=fe(t.fov),o}!function(e){e[e.LOCKED=0]="LOCKED",e[e.ADJUST=1]="ADJUST"}(ht||(ht={}));const Mt=z();function Rt(t,n,r){const a=t.renderSpatialReference,i=St(t,n.eye,n.viewForward,n.up,mt);let o=yt(t);return k(n.eye,a,Mt,o)||(o=de.WGS84,k(n.eye,a,Mt,o)),u(r)?new e(new pe(Mt,o),i.heading,i.tilt,le(n.fov)):(r.position.x=Mt[0],r.position.y=Mt[1],r.position.z=Mt[2],r.position.spatialReference=o,r.heading=i.heading,r.tilt=i.tilt,r.fov=le(n.fov),r)}function bt(e,t,n){const r=e.state.camera,a=r.width/2/r.pixelRatio;return e.renderCoordsHelper.viewingMode===ge.Global&&null!=n&&(t*=Math.cos(fe(n))),t/=e.renderCoordsHelper.unitInMeters,a/(ot*it/t)/Math.tan(r.fovX/2)}function Tt(e,t,n){const r=e.state.camera,a=t*Math.tan(r.fovX/2),i=r.width/2/r.pixelRatio;let o=ot*it/(i/a);return e.renderCoordsHelper.viewingMode===ge.Global&&null!=n&&(o/=Math.cos(fe(n))),o*e.renderCoordsHelper.unitInMeters}function zt(e,t,n,r,a,i){return jt(e,t,bt(e,n,t.latitude),r,a,i)}function jt(e,t,n,r,a,i){if(Bt(i)){const o=new It(i.signal);return Gt(e,r.heading,r.tilt,t,n,a,o),void o.resolver.promise.then((t=>{const n=Ht(e,t,r.fov);if(!u(n))return i.resolver.resolve(n);i.resolver.reject()}),(e=>i.resolver.reject(e)))}const o=Gt(e,r.heading,r.tilt,t,n,a);return Ht(e,o,r.fov,i)}function St(e,t,n,r,a){return vt(e).directionToHeadingTilt(t,n,r,a)}function Gt(e,t,n,r,a,i,o){const s=r&&r instanceof pe?r:null;if(Bt(o))return async function(e,t,n){const r=z();if(t)if(t instanceof pe){if(O(t,r,e.renderSpatialReference),null==t.z&&null!=e.basemapTerrain&&null!=e.elevationProvider){const a=await e.elevationProvider.queryElevation(t.x,t.y,t.z??0,t.spatialReference,"ground",n);return l(a)&&e.renderCoordsHelper.setAltitude(r,a),r}}else v(r,t);else v(r,e.state.camera.center);return r}(e,r,o.signal).then((r=>{Ct(e,t,n,s,r,a,i,o)}),(e=>o.resolver.reject(e))),null;const c=function(e,t){const n=z();if(t&&t instanceof pe){if(O(t,n,e.renderSpatialReference),null==t.z&&null!=e.basemapTerrain&&null!=e.elevationProvider){const r=be(e.elevationProvider,t);l(r)&&e.renderCoordsHelper.setAltitude(n,r)}}else v(n,t||e.state.camera.center);return n}(e,r);return Ct(e,t,n,s,c,a,i,o)}function Ct(e,t,n,r,a,i,o,s){if(u(r)){const t=e.renderSpatialReference;if(r=F(a,t,yt(e)),u(r))return null}i=Math.max(i,e.state.constraints.minimumPoiDistance);const l=function(e,t,n,r,a,i){let o=0;return i===ht.ADJUST&&function(e,t,n){const r=e.pointsOfInterest.centerOnSurfaceFrequent.distance;if(Math.log(n/r)/Math.LN2>ct)return!0;const a=e.renderSpatialReference,i=yt(e),o=F(t,a,i),s=F(e.pointsOfInterest.centerOnSurfaceFrequent.renderLocation,a,i);if(u(o)||u(s))return!1;const c=Math.tan(.5*e.state.camera.fov)*r;return s.distance(o)/c>lt}(e,r,a)?(t=0,o=function(e,t,n,r){const a=Ut(e,r,t,n);if(!e.state.constraints.tilt)return a;const i=e.state.constraints.tilt(t);i.max=Math.min(i.max,.5*Math.PI);const o=i.min*(1-Dt)+i.max*Dt;return Math.min(a,o)}(e,a,n,r)):o=Ut(e,r,a,n),o=e.state.constraints.clampTilt(a,o),{heading:t,tilt:n=Et(e,r,a,o)}}(e,t,n,a,i,o),f=(0,vt(e).eyeForCenterWithHeadingTilt)(a,i,l.heading,l.tilt);if(o===ht.ADJUST&&"global"===e.viewingMode&&n>0){const l=()=>{const c=Et(e,a,i,function(e,t,n,r){let a=Ut(e,r,t,n);if(!e.state.constraints.tilt)return a;const i=e.state.constraints.tilt(t);return a=Math.min(a,.5*Math.PI),i.min*(1-Dt)+a*Dt}(e,i,n,a));return o=n-c<1?ht.LOCKED:ht.ADJUST,Ct(e,t,c,r,a,i,o,s)},u=e.map.ground.navigationConstraint;if(!u||"stay-above"===u.type){if(function(e,t){return!!(e.basemapTerrain&&e.renderCoordsHelper.fromRenderCoords(t,pt,e.spatialReference)&&e.elevationProvider&&c(be(e.elevationProvider,pt),0)>(pt.z??0)-ut)}(e,f.eye))return l();if(Bt(s))return async function(e,t,n){if(!e.renderCoordsHelper.fromRenderCoords(t,pt,e.spatialReference)||!e.elevationProvider)return!1;const r=pt.z??0,a=await e.elevationProvider.queryElevation(pt.x,pt.y,r,pt.spatialReference,"ground",n);return c(a,0)>r-ut}(e,f.eye,s.signal).then((e=>e?l():(s.resolver.resolve({eye:f.eye,up:f.up,center:P(a),heading:f.heading,tilt:f.tilt}),null))),null}}const m=!s||Bt(s)?{center:z(),eye:z(),up:z(),tilt:0,heading:0}:s;return m.eye=f.eye,m.up=f.up,m.center=P(a),m.heading=f.heading,m.tilt=f.tilt,Bt(s)&&s.resolver.resolve(m),m}function At(e,t,n,r,a,i=null){let o,s,l;if(e.state.isGlobal){if(!Te(t.spatialReference,ge.Global))return Bt(i)&&i.resolver.reject(),null;const e=new pe(t.xmin,t.ymin,t.spatialReference),n=new pe(t.xmax,t.ymax,t.spatialReference),r=t.spatialReference.isGeographic?gt:dt;o=new pe({x:r.center(e.x,n.x),y:(n.y+e.y)/2,z:null!=t.zmax&&null!=t.zmin?(t.zmax+t.zmin)/2:void 0,spatialReference:t.spatialReference});const a=oe(t.spatialReference),c=Re(o,e,n);s=c.lon,l=c.lat,r.diff(e.x,n.x)>r.range/2&&(s+=a.halfCircumference),s=Math.min(s,a.halfCircumference),l=Math.min(l,a.halfCircumference)}else{const n=c(e.renderSpatialReference,t.spatialReference);n.equals(t.spatialReference)||(t=I(t,n)),s=t.xmax-t.xmin,l=t.ymax-t.ymin;const r=null!=t.zmax&&null!=t.zmin?(t.zmax+t.zmin)/2:void 0;o=new pe({x:t.xmin+.5*s,y:t.ymin+.5*l,z:r,spatialReference:n})}const f=null!=t.zmax&&null!=t.zmin?t.zmax-t.zmin:0,m=e.state.camera,p=1/Math.tan(m.fovX/2),d=1/Math.tan(m.fovY/2),g=1/Math.tan(m.fov/2),h=Math.max(.5*s*p,.5*l*d,.5*f*g)/st;if(Bt(i)){const t=new It(i.signal);return Gt(e,n,r,o,h,a,t),void t.resolver.promise.then((t=>{const n=Ht(e,t,e.camera.fov);if(!u(n))return i.resolver.resolve(n);i.resolver.reject()}),(e=>i.resolver.reject(e)))}const y=Gt(e,n,r,o,h,a);return Ht(e,y,e.camera.fov,i)}function Pt(e,t,n){const r=e.renderSpatialReference,a=F(n,r,yt(e));if(u(a))return null;const i=Math.tan(t.fovX/2),o=Math.tan(t.fovY/2),s=D(t.eye,n),c=2*s*i*st,l=2*s*o*st;return"global"===e.viewingMode?nt(e,a,c,l):Je(e,a,c,l)}const Dt=.7;function Et(e,t,n,r){return vt(e).lookAtTiltToEyeTilt(r,t,n)}function Ut(e,t,n,r){return vt(e).eyeTiltToLookAtTilt(r,t,n)}function Ht(t,n,r,a){if(u(n))return null;const i=t.renderSpatialReference,o=F(n.eye,i,yt(t));return u(o)?null:l(a)?(a.position=o,a.heading=n.heading,a.tilt=n.tilt,a.fov=r,a):new e(o,n.heading,n.tilt,r)}function Ot(e,t){const n=e.basemapTerrain?.tilingScheme;if(n)return n.levelAtScale(t);at.error("#scaleToZoom()","Cannot compute zoom from scale without a tiling scheme")}function kt(e,t){const n=e.basemapTerrain?.tilingScheme;if(n)return n.scaleAtLevel(t);at.error("#zoomToScale()","Cannot compute scale from zoom without a tiling scheme")}function Ft(e,t){return k(t.center,e.renderSpatialReference,ft,de.WGS84),Tt(e,t.distance,ft[1])}class It{constructor(e){this.signal=e,this.resolver=m()}}function Bt(e){return e&&"resolver"in e}const Lt=.66;function qt(e){return 360-o.normalize(e)}function Wt(e){return o.normalize(360-e)}function Zt(e){return l(e)&&e.resolver&&e.resolver.reject(),null}function Jt(e,t,n,r=null){if(!t)return Zt(r);const a=e.spatialReference||de.WGS84;if(l(t.camera)){const e=ae(t.camera.position,a);if(u(e))return Zt(r);const n=t.camera.clone();return n.position=e,function(e,t){return l(e)&&e.resolver&&e.resolver.resolve(t),t}(r,n)}if(u(t.targetGeometry))return Zt(r);const i=t.get("targetGeometry.spatialReference");if(i&&!ie(i,a))return Zt(r);const o=Rt(e,e.state.camera);let s=ht.ADJUST;if(null!=t.rotation&&(o.heading=qt(t.rotation),s=ht.LOCKED),null!=n&&(o.tilt=n),"point"===t.targetGeometry.type){const n=t.targetGeometry;let a;const i=t.targetGeometry.clone();return a=null!=t.scale?bt(e,t.scale,n.latitude):e.state.camera.distance,jt(e,i,a,o,s,r)}const c=t.targetGeometry.extent;return c?At(e,c,o.heading,o.tilt,s,r):Zt(r)}function _t(e,t,r=null){return u(r)&&(r=new n),Xt(e,null,t.clone(),r)}async function Kt(t,r,a){const i=function(e,t){if(!t||!e.spatialReference)return null;const n={target:void 0};if("declaredClass"in t||Array.isArray(t))n.target=t;else{for(const e in t)n[e]=t[e];t.center&&!n.target&&(n.target=t.center)}return n}(t,r);if(!i)throw new s("viewpointutils-create:no-target","Missing target for creating viewpoint");const o=new e({fov:t.camera.fov}),c=new n({camera:o});if(i.target instanceof n){const e=await async function(e,t,n,r,a){if(l(t.camera))return Qt(e,t.camera,a);a.scale=t.scale,a.rotation=t.rotation,a.targetGeometry=l(t.targetGeometry)?t.targetGeometry.clone():null,a.camera=null,null!=n.heading?a.rotation=Wt(n.heading):null!=n.rotation&&(a.rotation=n.rotation);const i=Nt(e,n);null!=i&&(a.scale=i);const o=new It(r);return Jt(e,a,n.tilt,o),a.camera=await o.resolver.promise,a}(t,i.target,i,a,c);return tn(e)}if(i.target instanceof e)return tn(Qt(t,i.target,c));const u=null!=i.scale||null!=i.zoom;if(i.target instanceof we){const e=i.target.xmin===i.target.xmax||i.target.ymin===i.target.ymax;return tn(u||e?await en(t,i,i.target.center,o,a,c):await async function(e,t,n,r,a,i){i.targetGeometry=n.clone(),Rt(e,Ge(e),r);const o=Vt(r,t)?ht.LOCKED:ht.ADJUST,s=new It(a);return At(e,n,r.heading,r.tilt,o,s),i.camera=await s.resolver.promise,i}(t,i,i.target,o,a,c))}const m={boundingBox:W(),hasZ:!1,screenSpaceObjects:[]},p=u?function(e,t){const n=Nt(e,t);return n?ne(n):void 0}(t,i):void 0;if(await $t(t,i.target,p,m),isFinite(m.boundingBox[0])){let e;if(Z(m.boundingBox,nn),mn.x=nn[0],mn.y=nn[1],mn.z=nn[2],mn.spatialReference=t.spatialReference,isFinite(mn.z)&&m.hasZ?e=_(m.boundingBox):(mn.z=void 0,e=ee(J(m.boundingBox,sn))),u||e)return tn(await en(t,i,mn,o,a,c));const n=function(e,t){const n=Lt;if(!t.length)return n;let r=Number.NEGATIVE_INFINITY;for(let e=0;e<t.length;e++){const n=t[e].screenSpaceBoundingRect;r=Math.max(r,Math.abs(n[0]),Math.abs(n[1]),Math.abs(n[2]),Math.abs(n[3]))}return n-r/Math.min(e.width,e.height)*2}(t,m.screenSpaceObjects);return tn(await async function(e,t,n,r,a,i,o,s){s.targetGeometry=n.clone();const c=Ge(e),l=function(e,t,n,r,a){let i=0;null!=n.z?i=n.z:e.basemapTerrain&&e.elevationProvider&&(i=f(be(e.elevationProvider,n))),U(nn,n.x,n.y,i),L(e.spatialReference,nn,rn,e.renderSpatialReference),d(an,rn),g(an,an),W(on);const o=[[0,1,2],[3,1,2],[0,4,2],[3,4,2],[0,1,5],[3,1,5],[0,4,5],[3,4,5]];for(let t=0;t<o.length;t++){const n=o[t];let a=r[n[2]];isFinite(a)||(a=i),U(nn,r[n[0]],r[n[1]],a),k(nn,e.spatialReference,nn,e.renderSpatialReference),K(on,H(nn,nn,an))}const s=V(on),c=X(on),l=Y(on),u=1/Math.tan(t.fovX/2),m=1/Math.tan(t.fovY/2),p=.5*Math.sqrt(s*s+l*l)*Math.max(m,u)+.5*c,h=.5*c*m+.5*Math.max(s,l);return Math.max(p,h)/a}(e,c,n,r,a);Rt(e,c,i);const u=Vt(i,t)?ht.LOCKED:ht.ADJUST;s.scale=Tt(e,l,s.targetGeometry.latitude);const m=new It(o);return zt(e,s.targetGeometry,s.scale,i,u,m),s.camera=await m.resolver.promise,s}(t,i,mn,m.boundingBox,n,o,a,c))}return i.position?tn(function(e,t,n,r){const a=Ge(e);return v(cn,a.viewForward),St(e,a.eye,cn,a.up,fn),n.position=new pe(t.position),n.heading=null!=t.heading?t.heading:fn.heading,n.tilt=null!=t.tilt?t.tilt:fn.tilt,Xt(e,null,n,r)}(t,i,o,c)):tn(await async function(e,t,n,r,a){const i=Ge(e);return en(e,t,F(i.center,e.renderSpatialReference,e.spatialReference),n,r,a)}(t,i,o,a,c))}function Nt(e,t){return null==t.scale&&null!=t.zoom?kt(e,t.zoom):t.scale}function Vt(e,t){let n=!1;return null!=t.heading?(e.heading=t.heading,n=!0):null!=t.rotation&&(e.heading=qt(t.rotation),n=!0),null!=t.tilt&&(e.tilt=t.tilt,n=!0),null!=t.fov&&(e.fov=t.fov),n}function Xt(e,t,n,r){const a=e.spatialReference||de.WGS84;return t=l(t)?t:wt(e,n),u(t)||(r.targetGeometry=F(t.center,e.renderSpatialReference,a),r.scale=Ft(e,t),r.rotation=Wt(n.heading),r.camera=n),r}function Yt(e,t,n){const r=()=>new s("viewpointutils:invalid-geometry","The target is missing a valid geometry");if(!t)throw r();if(!ie(t.spatialReference,e.spatialReference))throw new s("viewpointutils:incompatible-spatialreference",`Spatial reference (${t.spatialReference?t.spatialReference.wkid:"unknown"}) is incompatible with the view (${e.spatialReference?.wkid})`,{geometry:t});const a=[];if(!t.hasZ&&e.basemapTerrain){let n;switch(t.type){case"point":n=t;break;case"multipoint":case"polyline":n=t.extent?.center;break;case"mesh":n=t.origin;break;case"extent":n=t.center;break;case"polygon":n=t.centroid}n&&l(e.basemapTerrain.spatialReference)&&ie(n,e.basemapTerrain.spatialReference)&&e.elevationProvider?nn[2]=c(be(e.elevationProvider,n),0):nn[2]=0}(0,pn[t.type])(t,(e=>{a.push(e[0],e[1],e[2])}),nn);const i=a.length/3;if(0===i)throw r();const o=new Array(a.length);if(B(a,t.spatialReference,0,o,e.spatialReference,0,i)){t.hasZ&&(n.hasZ=!0);for(let e=0;e<o.length;e+=3)t.hasZ?(nn[0]=o[e],nn[1]=o[e+1],nn[2]=o[e+2]):(nn[0]=o[e],nn[1]=o[e+1]),K(n.boundingBox,nn)}}async function $t(e,n,a,i){if(Array.isArray(n)&&2===n.length){const t=n[0],r=n[1];if("number"==typeof t&&"number"==typeof r)return mn.x=t,mn.y=r,mn.z=void 0,mn.spatialReference=e.spatialReference?.isGeographic?e.spatialReference:de.WGS84,void Yt(e,mn,i)}n&&"function"==typeof n.map?await p(n.map((t=>$t(e,t,a,i)))):n instanceof ze?Yt(e,n,i):n instanceof t&&await async function(e,t,n,a){const i=await r(e.whenViewForGraphic(t));if(!1===i.ok||u(i.value)||!("whenGraphicBounds"in i.value))return void Yt(e,t.geometry,a);const o=i.value,s=await r(o.whenGraphicBounds(t,{minDemResolution:n}));if(!1===s.ok)return void Yt(e,t.geometry,a);const{screenSpaceObjects:c,boundingBox:l}=s.value;N(a.boundingBox,l),c&&c.forEach((e=>{a.screenSpaceObjects.push(e)})),isFinite(l[2])&&(a.hasZ=!0)}(e,n,a,i)}function Qt(e,t,n){const r=e.spatialReference,a=ae(t.position,r);return u(a)?null:((t=t.clone()).fov=e.camera.fov,t.position=a,Xt(e,null,t,n))}async function en(e,t,n,r,a,i){if(u(n))throw new s("createfromcenter","invalid point");i.targetGeometry=n.clone();const o=Ge(e);if(t.position)return function(e,t,n,r,a,i){const o=e.renderSpatialReference;return O(n,ln,o),O(t,un,o),i.targetGeometry=new pe(t),a.position=new pe(n),M(cn,un,ln),St(e,ln,cn,r.up,a),i.scale=Tt(e,E(ln,un),i.targetGeometry.latitude),i.rotation=Wt(a.heading),i.camera=a,i}(e,i.targetGeometry,t.position,o,r,i);if(t.zoomFactor){const r=o.distance/t.zoomFactor,a=w(nn,o.viewForward,-r);o.eye=R(nn,o.center,a),i.scale=Tt(e,r,n.latitude)}Rt(e,o,r);const c=Vt(r,t)?ht.LOCKED:ht.ADJUST;if(!t.zoomFactor){const s=Nt(e,t);null==s?(O(n,nn,e.renderSpatialReference),te(o.frustum,nn)?i.scale=Tt(e,E(o.eye,nn),n.latitude):i.scale=Ft(e,o)):i.scale=s;const l=new It(a);zt(e,i.targetGeometry,i.scale,r,c,l),i.camera=await l.resolver.promise}return i}function tn(e){return e&&l(e.camera)&&(e.rotation=Wt(e.camera.heading)),e}const nn=z(),rn=y(),an=h(),on=q(),sn=Q(),cn=z(),ln=z(),un=z(),fn={heading:0,tilt:0},mn=new pe,pn={point(e,t,n){n[0]=e.x,n[1]=e.y,null!=e.z&&(n[2]=e.z),t(n)},polygon(e,t,n){const r=e.hasZ;for(let a=0;a<e.rings.length;a++){const i=e.rings[a];for(let e=0;e<i.length;e++)n[0]=i[e][0],n[1]=i[e][1],r&&(n[2]=i[e][2]),t(n)}},polyline(e,t,n){const r=e.hasZ;for(let a=0;a<e.paths.length;a++){const i=e.paths[a];for(let e=0;e<i.length;e++)n[0]=i[e][0],n[1]=i[e][1],r&&(n[2]=i[e][2]),t(n)}},multipoint(e,t,n){const r=e.points,a=e.hasZ;for(let e=0;e<r.length;e++)n[0]=r[e][0],n[1]=r[e][1],a&&(n[2]=r[e][2]),t(n)},extent(e,t,n){null!=e.zmin&&null!=e.zmax?(t(U(n,e.xmin,e.ymin,e.zmin)),t(U(n,e.xmax,e.ymin,e.zmin)),t(U(n,e.xmin,e.ymax,e.zmin)),t(U(n,e.xmax,e.ymax,e.zmin)),t(U(n,e.xmin,e.ymin,e.zmax)),t(U(n,e.xmax,e.ymin,e.zmax)),t(U(n,e.xmin,e.ymax,e.zmax)),t(U(n,e.xmax,e.ymax,e.zmax))):(t(U(n,e.xmin,e.ymin,n[2])),t(U(n,e.xmax,e.ymin,n[2])),t(U(n,e.xmin,e.ymax,n[2])),t(U(n,e.xmax,e.ymax,n[2])))},mesh(e,t,n){const r=e.vertexAttributes&&e.vertexAttributes.position;if(r)for(let e=0;e<r.length;e+=3)t(U(n,r[e],r[e+1],r[e+2]))}};export{ht as O,wt as a,Ot as b,Kt as c,Tt as d,je as e,_t as f,Ge as g,At as h,Rt as i,Gt as j,bt as k,Jt as l,xt as m,ke as n,St as o,Se as s,Pt as t,kt as z};
