/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import"./typedArrayUtil.js";import{c as t}from"./mathUtils.js";import{f as e}from"./mat3.js";import{c as o}from"./mat3f64.js";import{i,j as s,s as n,m as r,g as a,n as l,r as u,o as f,p as c}from"./mat4.js";import{c as p}from"./mat4f64.js";import{d as S,s as d}from"./vec3.js";import{m as E}from"./lengthUtils.js";import{_ as T}from"./tslib.es6.js";import _ from"../core/Accessor.js";import{property as m}from"../core/accessorSupport/decorators/property.js";import"./ensureType.js";import{subclass as v}from"../core/accessorSupport/decorators/subclass.js";import{N as h}from"./interfaces2.js";import{R as y,D as z}from"./Material.js";import{U as I,B as O}from"./ShaderBuilder.js";import{V as R}from"./VertexAttribute.js";import{D as A,T as D,P as L,a as N,c as C,U as x}from"./enums3.js";import{V as U}from"./VertexElementDescriptor.js";import{V as w,B as F}from"./FramebufferObject.js";import{T as g}from"./Texture.js";let W=class extends _{constructor(){super(...arguments),this.SCENEVIEW_HITTEST_RETURN_INTERSECTOR=!1,this.DECONFLICTOR_SHOW_VISIBLE=!1,this.DECONFLICTOR_SHOW_INVISIBLE=!1,this.DECONFLICTOR_SHOW_GRID=!1,this.LABELS_SHOW_BORDER=!1,this.TEXT_SHOW_BASELINE=!1,this.TEXT_SHOW_BORDER=!1,this.OVERLAY_DRAW_DEBUG_TEXTURE=!1,this.OVERLAY_SHOW_CENTER=!1,this.SHOW_POI=!1,this.TESTS_DISABLE_OPTIMIZATIONS=!1,this.TESTS_DISABLE_FAST_UPDATES=!1,this.DRAW_MESH_GEOMETRY_NORMALS=!1,this.FEATURE_TILE_FETCH_SHOW_TILES=!1,this.FEATURE_TILE_TREE_SHOW_TILES=!1,this.TERRAIN_TILE_TREE_SHOW_TILES=!1,this.I3S_TREE_SHOW_TILES=!1,this.I3S_SHOW_MODIFICATIONS=!1,this.LOD_INSTANCE_RENDERER_DISABLE_UPDATES=!1,this.LOD_INSTANCE_RENDERER_COLORIZE_BY_LEVEL=!1,this.EDGES_SHOW_HIDDEN_TRANSPARENT_EDGES=!1,this.LINE_WIREFRAMES=!1}};T([m()],W.prototype,"SCENEVIEW_HITTEST_RETURN_INTERSECTOR",void 0),T([m()],W.prototype,"DECONFLICTOR_SHOW_VISIBLE",void 0),T([m()],W.prototype,"DECONFLICTOR_SHOW_INVISIBLE",void 0),T([m()],W.prototype,"DECONFLICTOR_SHOW_GRID",void 0),T([m()],W.prototype,"LABELS_SHOW_BORDER",void 0),T([m()],W.prototype,"TEXT_SHOW_BASELINE",void 0),T([m()],W.prototype,"TEXT_SHOW_BORDER",void 0),T([m()],W.prototype,"OVERLAY_DRAW_DEBUG_TEXTURE",void 0),T([m()],W.prototype,"OVERLAY_SHOW_CENTER",void 0),T([m()],W.prototype,"SHOW_POI",void 0),T([m()],W.prototype,"TESTS_DISABLE_OPTIMIZATIONS",void 0),T([m()],W.prototype,"TESTS_DISABLE_FAST_UPDATES",void 0),T([m()],W.prototype,"DRAW_MESH_GEOMETRY_NORMALS",void 0),T([m()],W.prototype,"FEATURE_TILE_FETCH_SHOW_TILES",void 0),T([m()],W.prototype,"FEATURE_TILE_TREE_SHOW_TILES",void 0),T([m()],W.prototype,"TERRAIN_TILE_TREE_SHOW_TILES",void 0),T([m()],W.prototype,"I3S_TREE_SHOW_TILES",void 0),T([m()],W.prototype,"I3S_SHOW_MODIFICATIONS",void 0),T([m()],W.prototype,"LOD_INSTANCE_RENDERER_DISABLE_UPDATES",void 0),T([m()],W.prototype,"LOD_INSTANCE_RENDERER_COLORIZE_BY_LEVEL",void 0),T([m()],W.prototype,"EDGES_SHOW_HIDDEN_TRANSPARENT_EDGES",void 0),T([m()],W.prototype,"LINE_WIREFRAMES",void 0),W=T([v("esri.views.3d.support.DebugFlags")],W);const V=new W;var H,B;!function(t){t[t.Undefined=0]="Undefined",t[t.DefinedSize=1]="DefinedSize",t[t.DefinedScale=2]="DefinedScale"}(H||(H={})),function(t){t[t.Undefined=0]="Undefined",t[t.DefinedAngle=1]="DefinedAngle"}(B||(B={}));class M{constructor(t){this.field=t}}class b extends M{constructor(t){super(t),this.minSize=[0,0,0],this.maxSize=[0,0,0],this.offset=[0,0,0],this.factor=[0,0,0],this.type=[H.Undefined,H.Undefined,H.Undefined]}}class P extends M{constructor(t){super(t),this.colors=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],this.values=[0,0,0,0,0,0,0,0]}}class j extends M{constructor(t){super(t),this.values=[0,0,0,0,0,0,0,0],this.opacityValues=[0,0,0,0,0,0,0,0]}}class G{constructor(){this.size=null,this.color=null,this.opacity=null,this.rotation=null}}function Y(t){return null!=t}function X(t){return"number"==typeof t}function k(t){return"string"==typeof t}function Z(t,e){t&&t.push(e)}function q(t,e,o,i,s){const n=t.minSize,r=t.maxSize;if(t.expression)return Z(s,"Could not convert size info: expression not supported"),!1;if(t.useSymbolValue){const t=i.symbolSize[o];return e.minSize[o]=t,e.maxSize[o]=t,e.offset[o]=e.minSize[o],e.factor[o]=0,e.type[o]=H.DefinedSize,!0}if(Y(t.field))return Y(t.stops)?2===t.stops.length&&X(t.stops[0].size)&&X(t.stops[1].size)?($(t.stops[0].size,t.stops[1].size,t.stops[0].value,t.stops[1].value,e,o),e.type[o]=H.DefinedSize,!0):(Z(s,"Could not convert size info: stops only supported with 2 elements"),!1):X(n)&&X(r)&&Y(t.minDataValue)&&Y(t.maxDataValue)?($(n,r,t.minDataValue,t.maxDataValue,e,o),e.type[o]=H.DefinedSize,!0):null!=E[t.valueUnit]?(e.minSize[o]=-1/0,e.maxSize[o]=1/0,e.offset[o]=0,e.factor[o]=1/E[t.valueUnit],e.type[o]=H.DefinedSize,!0):"unknown"===t.valueUnit?(Z(s,"Could not convert size info: proportional size not supported"),!1):(Z(s,"Could not convert size info: scale-dependent size not supported"),!1);if(!Y(t.field)){if(t.stops&&t.stops[0]&&X(t.stops[0].size))return e.minSize[o]=t.stops[0].size,e.maxSize[o]=t.stops[0].size,e.offset[o]=e.minSize[o],e.factor[o]=0,e.type[o]=H.DefinedSize,!0;if(X(n))return e.minSize[o]=n,e.maxSize[o]=n,e.offset[o]=n,e.factor[o]=0,e.type[o]=H.DefinedSize,!0}return Z(s,"Could not convert size info: unsupported variant of sizeInfo"),!1}function $(t,e,o,i,s,n){const r=Math.abs(i-o)>0?(e-t)/(i-o):0;s.minSize[n]=r>0?t:e,s.maxSize[n]=r>0?e:t,s.offset[n]=t-o*r,s.factor[n]=r}function J(t,e,o){t[4*e]=o.r/255,t[4*e+1]=o.g/255,t[4*e+2]=o.b/255,t[4*e+3]=o.a}function K(t,e,o){const i=2===o&&"arithmetic"===t.rotationType;e.offset[o]=i?90:0,e.factor[o]=i?-1:1,e.type[o]=1}class Q{constructor(t=[1,1,1],e=[1,1,1],o=1,i=[0,0,0],s=[1,1,1],n=[0,0,0]){this.modelSize=t,this.symbolSize=e,this.unitInMeters=o,this.anchor=i,this.scale=s,this.rotation=n,this.supportsSize=!0,this.supportsColor=!0,this.supportsRotation=!0,this.supportsOpacity=!1}}function tt(t,e,o){if(!t)return null;const i=t.reduce(((t,i)=>{if(!t)return t;if(i.valueExpression)return Z(o,"Could not convert visual variables: arcade expressions not supported"),null;switch(i.type){case"size":return e.supportsSize?function(t,e,o,i){if(t.normalizationField||t.valueRepresentation)return Z(i,"Could not convert size info: unsupported property"),null;if(null!=(s=t.field)&&!k(s))return Z(i,"Could not convert size info: field is not a string"),null;var s;if(e.size){if(t.field)if(e.size.field){if(t.field!==e.size.field)return Z(i,"Could not convert size info: multiple fields in use"),null}else e.size.field=t.field}else e.size=new b(t.field);let n;switch(t.axis){case"width":return n=q(t,e.size,0,o,i),n?e:null;case"height":return n=q(t,e.size,2,o,i),n?e:null;case"depth":return n=q(t,e.size,1,o,i),n?e:null;case"width-and-depth":return n=q(t,e.size,0,o,i),n&&q(t,e.size,1,o,i),n?e:null;case null:case void 0:case"all":return n=q(t,e.size,0,o,i),n=n&&q(t,e.size,1,o,i),n=n&&q(t,e.size,2,o,i),n?e:null;default:return Z(i,`Could not convert size info: unknown axis "${t.axis}""`),null}}(i,t,e,o):t;case"color":return e.supportsColor?function(t,e,o){if(t.normalizationField)return Z(o,"Could not convert color info: unsupported property"),null;if(k(t.field)){if(!t.stops)return Z(o,"Could not convert color info: missing stops or colors"),null;{if(t.stops.length>8)return Z(o,"Could not convert color info: too many color stops"),null;e.color=new P(t.field);const i=t.stops;for(let t=0;t<8;++t){const o=i[Math.min(t,i.length-1)];e.color.values[t]=o.value,J(e.color.colors,t,o.color)}}}else{if(!(t.stops&&t.stops.length>=0))return Z(o,"Could not convert color info: no field and no colors/stops"),null;{const o=t.stops&&t.stops.length>=0&&t.stops[0].color;e.color={field:null,values:[0,0,0,0,0,0,0,0],colors:[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]};for(let t=0;t<8;t++)e.color.values[t]=1/0,J(e.color.colors,t,o)}}return e}(i,t,o):t;case"opacity":return e.supportsOpacity?function(t,e,o){if(t.normalizationField)return Z(o,"Could not convert opacity info: unsupported property"),null;if(k(t.field)){if(!t.stops)return Z(o,"Could not convert opacity info: missing stops or opacities"),null;{if(t.stops.length>8)return Z(o,"Could not convert opacity info: too many opacity stops"),null;e.opacity=new j(t.field);const i=t.stops;for(let t=0;t<8;++t){const o=i[Math.min(t,i.length-1)];e.opacity.values[t]=o.value,e.opacity.opacityValues[t]=o.opacity}}}else{if(!(t.stops&&t.stops.length>=0))return Z(o,"Could not convert opacity info: no field and no opacities/stops"),null;{const o=t.stops&&t.stops.length>=0?t.stops[0].opacity:0;e.opacity={field:null,values:[0,0,0,0,0,0,0,0],opacityValues:[0,0,0,0,0,0,0,0]};for(let t=0;t<8;t++)e.opacity.values[t]=1/0,e.opacity.opacityValues[t]=o}}return e}(i,t,o):null;case"rotation":return e.supportsRotation?function(t,e,o){if(!k(t.field))return Z(o,"Could not convert rotation info: field is not a string"),null;if(e.rotation){if(t.field)if(e.rotation.field){if(t.field!==e.rotation.field)return Z(o,"Could not convert rotation info: multiple fields in use"),null}else e.rotation.field=t.field}else e.rotation={field:t.field,offset:[0,0,0],factor:[1,1,1],type:[0,0,0]};switch(t.axis){case"tilt":return K(t,e.rotation,0),e;case"roll":return K(t,e.rotation,1),e;case null:case void 0:case"heading":return K(t,e.rotation,2),e;default:return Z(o,`Could not convert rotation info: unknown axis "${t.axis}""`),null}}(i,t,o):t;default:return null}}),new G);return!(t.length>0&&i)||i.size||i.color||i.opacity||i.rotation?i&&i.size&&!function(t,e,o){for(let o=0;o<3;++o){let i=e.unitInMeters;t.type[o]===H.DefinedSize&&(i*=e.modelSize[o],t.type[o]=H.DefinedScale),t.minSize[o]=t.minSize[o]/i,t.maxSize[o]=t.maxSize[o]/i,t.offset[o]=t.offset[o]/i,t.factor[o]=t.factor[o]/i}let i;if(t.type[0]!==H.Undefined)i=0;else if(t.type[1]!==H.Undefined)i=1;else{if(t.type[2]===H.Undefined)return Z(o,"No size axis contains a valid size or scale"),!1;i=2}for(let e=0;e<3;++e)t.type[e]===H.Undefined&&(t.minSize[e]=t.minSize[i],t.maxSize[e]=t.maxSize[i],t.offset[e]=t.offset[i],t.factor[e]=t.factor[i],t.type[e]=t.type[i]);return!0}(i.size,e,o)?null:i:null}class et{constructor(t,e,o){this.visualVariables=t,this.materialParameters=e,this.requiresShaderTransformation=o}}function ot(t,e){if(!t)return null;if(V.TESTS_DISABLE_FAST_UPDATES)return null;const o=tt(t.visualVariables,e);return o?new et(o,rt(o,e),!!o.size):null}function it(t,e,o){if(!e||!t)return!1;const i=t.visualVariables,s=tt(e.visualVariables,o);return!!s&&!!(st(i.size,s.size,"size")&&st(i.color,s.color,"color")&&st(i.rotation,s.rotation,"rotation")&&st(i.opacity,s.opacity,"opacity"))&&(t.visualVariables=s,t.materialParameters=rt(s,o),t.requiresShaderTransformation=!!s.size,!0)}function st(t,e,o){if(!!t!=!!e)return!1;if(t&&t.field!==e?.field)return!1;if(t&&"rotation"===o){const o=t,i=e;for(let t=0;t<3;t++)if(o.type[t]!==i.type[t]||o.offset[t]!==i.offset[t]||o.factor[t]!==i.factor[t])return!1}return!0}class nt extends h{constructor(t=null){super(),this.vvSymbolAnchor=null,this.vvSymbolRotationMatrix=null,this.vvSize=t?.size??null,this.vvColor=t?.color??null,this.vvOpacity=t?.opacity??null}}function rt(t,s){const n=new nt(t);return n.vvSize&&(n.vvSymbolAnchor=s.anchor,i(ct),function(t,e,o,i=p()){const s=t||0,n=e||0,r=o||0;0!==s&&u(i,i,-s/180*Math.PI),0!==n&&f(i,i,n/180*Math.PI),0!==r&&c(i,i,r/180*Math.PI)}(s.rotation[2],s.rotation[0],s.rotation[1],ct),n.vvSymbolRotationMatrix=n.vvSymbolRotationMatrix||o(),e(n.vvSymbolRotationMatrix,ct)),n}function at(e,o,i){if(!e.vvSize)return i;s(ut,i);const u=e.vvSymbolRotationMatrix;n(ct,u[0],u[1],u[2],0,u[3],u[4],u[5],0,u[6],u[7],u[8],0,0,0,0,1),r(ut,ut,ct);for(let i=0;i<3;++i){const s=e.vvSize.offset[i]+o[0]*e.vvSize.factor[i];ft[i]=t(s,e.vvSize.minSize[i],e.vvSize.maxSize[i])}return a(ut,ut,ft),l(ut,ut,e.vvSymbolAnchor),ut}function lt(e,o,i){if(o.vvSize)for(let s=0;s<3;++s){const n=o.vvSize.offset[s]+i[0]*o.vvSize.factor[s];e[s]=t(n,o.vvSize.minSize[s],o.vvSize.maxSize[s])}else d(e,1,1,1)}const ut=p(),ft=S(),ct=p();class pt extends nt{constructor(){super(...arguments),this.renderOccluded=y.Occlude}}const St=8;class dt extends I{constructor(t,e,o){super(t,"vec4",O.Pass,((o,i,s)=>o.setUniform4fv(t,e(i,s))),o)}}class Et extends I{constructor(t,e,o){super(t,"float",O.Pass,((o,i,s)=>o.setUniform1fv(t,e(i,s))),o)}}new U(R.POSITION,3,A.FLOAT,0,12),new U(R.POSITION,3,A.FLOAT,0,20),new U(R.UV0,2,A.FLOAT,12,20),new U(R.POSITION,3,A.FLOAT,0,32),new U(R.NORMAL,3,A.FLOAT,12,32),new U(R.UV0,2,A.FLOAT,24,32),new U(R.POSITION,3,A.FLOAT,0,16),new U(R.COLOR,4,A.UNSIGNED_BYTE,12,16);const Tt=[new U(R.POSITION,2,A.FLOAT,0,8)],_t=[new U(R.POSITION,2,A.FLOAT,0,16),new U(R.UV0,2,A.FLOAT,8,16)];class mt extends w{}function vt(t,e=Tt,o=z,i=-1,s=1){let n=null;return n=e===_t?new Float32Array([i,i,0,0,s,i,1,0,i,s,0,1,s,s,1,1]):new Float32Array([i,i,s,i,i,s,s,s]),new mt(t,o,{geometry:e},{geometry:F.createVertex(t,x.STATIC_DRAW,n)})}function ht(t,e=Tt,o=z){const i=new Float32Array([-1,-1,3,-1,-1,3]);return new mt(t,o,{geometry:e},{geometry:F.createVertex(t,x.STATIC_DRAW,i)})}const yt=4;function zt(t,e=yt){return new g(t,{target:D.TEXTURE_2D,pixelFormat:L.RGBA,dataType:N.UNSIGNED_BYTE,samplingMode:C.NEAREST,width:e,height:e})}function It(t,e,o=yt){const i=new Uint8Array(o*o*4);for(let t=0;t<i.length;t+=4)i[t]=255*e[0],i[t+1]=255*e[1],i[t+2]=255*e[2],i[t+3]=255*e[3];return new g(t,{target:D.TEXTURE_2D,pixelFormat:L.RGBA,dataType:N.UNSIGNED_BYTE,samplingMode:C.NEAREST,width:o,height:o},i)}function Ot(t){return new g(t,{target:D.TEXTURE_2D,pixelFormat:L.RGBA,dataType:N.UNSIGNED_BYTE,samplingMode:C.NEAREST,width:1,height:1},new Uint8Array([255,255,255,255]))}export{Q as C,Et as F,_t as P,pt as V,dt as a,mt as b,vt as c,Ot as d,V as e,It as f,zt as g,Tt as h,ht as i,ot as j,at as k,lt as l,it as u,St as v};
