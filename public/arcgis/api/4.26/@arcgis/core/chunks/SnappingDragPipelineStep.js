/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{a as e,f as n,i as t,r as o,u as a}from"./maybe.js";import{ignoreAbortErrors as i,debounce as r}from"../core/promiseUtils.js";import{watch as s}from"../core/reactiveUtils.js";import{p as l}from"./dehydratedFeatureComparison.js";import{c}from"./hydratedFeatures.js";import{f as p}from"./elevationInfoUtils.js";import{E as u}from"./dragEventPipeline.js";import{S as f}from"./SnappingContext.js";import{T as d,I as m}from"./Scheduler.js";function g({predicate:c=(()=>!0),snappingManager:g,snappingContext:h,updatingHandles:y,useZ:Z=!0}){const j=new u;if(e(g))return{snappingStep:[S,j],cancelSnapping:S};let T,z=null,I=null,k=null;const w=()=>{z=n(z),g.doneSnapping(),t(I)&&I.frameTask.remove(),I=null,T=o(T),k=null},E=function(n,o,a){return r((async({frameTask:i,point:r,scenePoint:s,context:c,event:p,delta:u,getLastState:f},d)=>{const m=await i.schedule((()=>n.snap({point:r,scenePoint:s,context:c,signal:d})),d);if(m.valid){let s=await i.schedule((()=>m.apply()),d);const g=f();t(g.point)&&r!==g.point&&(s=n.update({point:g.point,scenePoint:g.scenePoint,context:c})),!e(g.updatePoint)&&l(s,g.updatePoint)||(v(p.mapEnd,s,u,o),a.execute(p))}}))}(g,Z,j);let U=null,C=null,b=null;return{snappingStep:[n=>{if(!c(n))return n;const{action:o}=n;if("start"===o){const{info:o}=n,a="3d"===(r=g.view).type?r.resourceController.scheduler.registerTask(d.SNAPPING):m;if(I=function(e,n,o){return{context:new f({editGeometryOperations:e.editGeometryOperations,elevationInfo:e.elevationInfo,pointer:e.pointer,vertexHandle:t(n.info)?n.info.handle:null,excludeFeature:e.excludeFeature,visualizer:e.visualizer}),originalPos:t(n.snapOrigin)?e.coordinateHelper.vectorToDehydratedPoint(n.snapOrigin):n.mapStart,originalScenePos:t(n.scenePoints)?n.scenePoints.sceneStart:null,frameTask:o}}(h,n,a),I.context.selfSnappingZ=null,!Z&&t(o)){const n=function(n,o){if(!n.hasZ())return null;const a=o.vertices;let i=null;for(const o of a){const a=n.getZ(o.pos);if(t(i)&&t(a)&&Math.abs(a-i)>1e-6)return null;e(i)&&(i=a)}return i}(h.coordinateHelper,o.handle.component);t(n)&&(I.context.selfSnappingZ={value:n,elevationInfo:h.elevationInfo??p})}}var r;if(t(I)){const{context:t,originalScenePos:r,originalPos:l}=I,{mapEnd:c,mapStart:p,scenePoints:u}=n,f=x(l,P(c,p)),d=P(p,l),m={...n,action:"update"},S=I.context,h=function(n,t){return e(n)||e(t)?null:x(n,P(t.sceneEnd,t.sceneStart))}(r,u),j=g.update({point:f,scenePoint:h,context:t});if(b=j,v(c,j,d,Z),U=f,C=h,"end"!==o){const{frameTask:n}=I;e(z)&&(z=new AbortController),k=e=>{y.addPromise(i(E({frameTask:n,event:m,context:S,point:f,scenePoint:h,delta:d,getLastState:()=>({point:U,scenePoint:C,updatePoint:e.forceUpdate?null:b})},a(z).signal)))},k({forceUpdate:!1}),e(T)&&(T=s((()=>g.options.effectiveEnabled),(()=>k?.({forceUpdate:!0}))))}}return"end"===o&&w(),n},j],cancelSnapping:e=>(w(),e)}}function x(e,[n,t,o]){const a=c(e);return a.x+=n,a.y+=t,a.hasZ&&(a.z+=o),a}function P(e,n){const t=e.hasZ&&n.hasZ?e.z-n.z:0;return[e.x-n.x,e.y-n.y,t]}function v(e,n,[t,o,a],i){e.x=n.x+t,e.y=n.y+o,i&&e.hasZ&&n.hasZ&&(e.z=n.z+a)}function S(e){return e}export{g as c};
