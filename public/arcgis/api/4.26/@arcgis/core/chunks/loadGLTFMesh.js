/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import t from"../Color.js";import r from"../request.js";import{o as e}from"./ensureType.js";import{q as o}from"./mathUtils.js";import{i as s,u as i,g as n,a}from"./maybe.js";import{n as m}from"./mat3.js";import{c as p}from"./mat3f64.js";import{f as c}from"./vec3.js";import{f as l}from"./vec4f64.js";import u,{M as f}from"../geometry/support/MeshComponent.js";import j from"../geometry/support/MeshMaterialMetallicRoughness.js";import g from"../geometry/support/MeshTexture.js";import{b as d,c as y,s as x,u as T,B as h,v as b,a as v,d as w}from"./BufferView.js";import{c as M,b as A,d as C,e as E}from"./vec32.js";import{D as U,l as R,a as S,f as B,d as O,e as $,g as P,h as D,i as q,j as I,k,m as F,C as G}from"./DefaultMaterial_COLOR_GAMMA.js";import{e as L}from"./types.js";import"./typedArrayUtil.js";import{a as _}from"./georeference.js";import{i as z}from"./resourceUtils2.js";import{b as N}from"./enums3.js";import"./colorUtils.js";import"./common.js";import"./vec4.js";import"./Logger.js";import"../config.js";import"./object.js";import"../core/lang.js";import"./string.js";import"../kernel.js";import"../core/urlUtils.js";import"../core/Error.js";import"../core/promiseUtils.js";import"./tslib.es6.js";import"../core/JSONSupport.js";import"../core/Accessor.js";import"../core/Handles.js";import"../core/accessorSupport/decorators/subclass.js";import"./metadata.js";import"./utils.js";import"./handleUtils.js";import"./tracking.js";import"./get.js";import"./ArrayPool.js";import"../core/accessorSupport/decorators/property.js";import"./watch.js";import"../core/scheduling.js";import"./nextTick.js";import"../core/accessorSupport/decorators/cast.js";import"../geometry/support/MeshMaterial.js";import"./imageUtils.js";import"./reader.js";import"./writer.js";import"./persistableUrlUtils.js";import"./vec2.js";import"./asyncUtils.js";import"./mat4f64.js";import"./Version.js";import"./mat4.js";import"./quat.js";import"./quatf64.js";import"./compilerUtils.js";import"./Indices.js";import"./unitUtils.js";import"./jsonMap.js";import"./Ellipsoid.js";import"../geometry/projection.js";import"./SimpleObservable.js";import"../geometry/Extent.js";import"../geometry/Geometry.js";import"../geometry/SpatialReference.js";import"../geometry/Point.js";import"../geometry/support/webMercatorUtils.js";import"../geometry/Multipoint.js";import"./zmUtils.js";import"./pe.js";import"./assets.js";import"../geometry/Polygon.js";import"./extentUtils.js";import"./aaBoundingRect.js";import"../geometry/Polyline.js";import"./geodesicConstants.js";import"../geometry/support/GeographicTransformation.js";import"../geometry/support/GeographicTransformationStep.js";import"./zscale.js";import"./spatialReferenceEllipsoidUtils.js";import"./MeshTransform.js";import"./axisAngleDegrees.js";import"./DoubleArray.js";import"./projection.js";import"./basicInterfaces.js";function V(t,r){return new t(new ArrayBuffer(r*t.ElementCount*L(t.ElementType)))}async function H(o,a,m){const p=new U(function(t){const e=t?.resolveFile;return e?{busy:!1,request:async(t,o,i)=>{const n=e(t),a="image"===o?"image":"binary"===o?"array-buffer":"json";return(await r(n,{responseType:a,signal:s(i)?i.signal:null})).data}}:null}(m)),u=(await R(p,a,m,!0)).model,x=u.lods.shift(),T=new Map,b=new Map;u.textures.forEach(((t,r)=>{return T.set(r,new g({data:(z((o=t).data),o.data),wrap:(e=o.parameters.wrap,{horizontal:W(e.s),vertical:W(e.t)})}));var e,o})),u.materials.forEach(((r,e)=>b.set(e,function(r,e){const o=new t((a=r.color,m=r.opacity,l(X(a[0]),X(a[1]),X(a[2]),m))),s=r.emissiveFactor?new t(function(t){return c(X(t[0]),X(t[1]),X(t[2]))}(r.emissiveFactor)):null;var a,m;return new j({color:o,colorTexture:i(n(r.textureColor,(t=>e.get(t)))),normalTexture:i(n(r.textureNormal,(t=>e.get(t)))),emissiveColor:s,emissiveTexture:i(n(r.textureEmissive,(t=>e.get(t)))),occlusionTexture:i(n(r.textureOcclusion,(t=>e.get(t)))),alphaMode:Q(r.alphaMode),alphaCutoff:r.alphaCutoff,doubleSided:r.doubleSided,metallic:r.metallicFactor,roughness:r.roughnessFactor,metallicRoughnessTexture:i(n(r.textureMetallicRoughness,(t=>e.get(t)))),colorTextureTransform:r.colorTextureTransform,normalTextureTransform:r.normalTextureTransform,occlusionTextureTransform:r.occlusionTextureTransform,emissiveTextureTransform:r.emissiveTextureTransform,metallicRoughnessTextureTransform:r.metallicRoughnessTextureTransform})}(r,T))));const M=function(t){let r=0;const o={color:!1,tangent:!1,normal:!1,texCoord0:!1},i=new Map,n=new Map,a=[];for(const p of t.parts){const{attributes:{position:t,normal:c,color:l,tangent:u,texCoord0:f}}=p,j=`\n      ${J(t,i)}/\n      ${J(c,i)}/\n      ${J(l,i)}/\n      ${J(u,i)}/\n      ${J(f,i)}/\n      ${m=p.transform,s(m)?m.toString():"-"}\n    `;let g=!1;const d=e(n,j,(()=>(g=!0,{start:r,length:t.count})));g&&(r+=t.count),c&&(o.normal=!0),l&&(o.color=!0),u&&(o.tangent=!0),f&&(o.texCoord0=!0),a.push({gltf:p,writeVertices:g,region:d})}var m;return{vertexAttributes:{position:V(v,r),normal:o.normal?V(h,r):null,tangent:o.tangent?V(d,r):null,color:o.color?V(y,r):null,texCoord0:o.texCoord0?V(w,r):null},parts:a,components:[]}}(x);for(const t of M.parts)K(M,t,b);const{position:A,normal:C,tangent:E,color:S,texCoord0:B}=M.vertexAttributes,O={position:A.typedBuffer,normal:s(C)?C.typedBuffer:null,tangent:s(E)?E.typedBuffer:null,uv:s(B)?B.typedBuffer:null,color:s(S)?S.typedBuffer:null},$=_(O,o,m);return{transform:$.transform,components:M.components,spatialReference:o.spatialReference,vertexAttributes:new f({position:$.vertexAttributes.position,normal:$.vertexAttributes.normal,tangent:$.vertexAttributes.tangent,color:O.color,uv:O.uv})}}function J(t,r){if(a(t))return"-";const o=t.typedBuffer;return`${e(r,o.buffer,(()=>r.size))}/${o.byteOffset}/${o.byteLength}`}function K(t,r,e){r.writeVertices&&function(t,r){const{position:e,normal:i,tangent:n,color:a,texCoord0:c}=t.vertexAttributes,l=r.region.start,{attributes:u,transform:f}=r.gltf,j=u.position.count;if(M(e.slice(l,j),u.position,f),s(u.normal)&&s(i)){const t=m(p(),f),r=i.slice(l,j);A(r,u.normal,t),o(t)&&C(r,r)}else s(i)&&B(i,0,0,1,{dstIndex:l,count:j});if(s(u.tangent)&&s(n)){const t=m(p(),f),r=n.slice(l,j);O(r,u.tangent,t),o(t)&&$(r,r)}else s(n)&&P(n,0,0,1,1,{dstIndex:l,count:j});if(s(u.texCoord0)&&s(c)?D(c.slice(l,j),u.texCoord0):s(c)&&q(c,0,0,{dstIndex:l,count:j}),s(u.color)&&s(a)){const t=u.color,r=a.slice(l,j);if(4===t.elementCount)t instanceof d?I(r,t,255):t instanceof y?k(r,t):t instanceof x&&I(r,t,1/256);else{P(r,255,255,255,255);const e=T.fromTypedArray(r.typedBuffer,r.typedBufferStride);t instanceof h?E(e,t,255):t instanceof T?F(e,t):t instanceof b&&E(e,t,1/256)}}else s(a)&&P(a.slice(l,j),255,255,255,255)}(t,r);const{indices:i,attributes:n,primitiveType:a,material:c}=r.gltf;let l=S(i||n.position.count,a);const f=r.region.start;if(f){const t=l.slice();for(let r=0;r<l.length;r++)t[r]+=f;l=t}t.components.push(new u({faces:l,material:e.get(c),trustSourceNormals:!0}))}function Q(t){switch(t){case"OPAQUE":return"opaque";case"MASK":return"mask";case"BLEND":return"blend"}}function W(t){switch(t){case N.CLAMP_TO_EDGE:return"clamp";case N.MIRRORED_REPEAT:return"mirror";case N.REPEAT:return"repeat"}}function X(t){return t**(1/G)*255}export{H as loadGLTFMesh};
