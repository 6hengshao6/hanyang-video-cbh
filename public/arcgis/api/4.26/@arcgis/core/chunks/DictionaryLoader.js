/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import t from"../Color.js";import s from"../request.js";import e from"../core/Error.js";import{L as o}from"./Logger.js";import{L as r}from"./LRUCache.js";import{i,a as n}from"./maybe.js";import{isAbortError as l}from"../core/promiseUtils.js";import{n as m}from"./string.js";import{l as a,c}from"./arcadeOnDemand.js";import p from"../symbols/CIMSymbol.js";import"./colorUtils.js";import"./mathUtils.js";import"./vec3.js";import"./common.js";import"./vec4.js";import"./ensureType.js";import"./typedArrayUtil.js";import"../config.js";import"./object.js";import"../core/lang.js";import"../kernel.js";import"../core/urlUtils.js";import"./MemCache.js";import"../core/scheduling.js";import"./nextTick.js";import"../geometry.js";import"../geometry/Extent.js";import"./tslib.es6.js";import"../core/accessorSupport/decorators/property.js";import"./get.js";import"./utils.js";import"./handleUtils.js";import"./metadata.js";import"../core/accessorSupport/decorators/subclass.js";import"./tracking.js";import"../geometry/Geometry.js";import"../core/JSONSupport.js";import"../core/Accessor.js";import"../core/Handles.js";import"./ArrayPool.js";import"./watch.js";import"./reader.js";import"../geometry/SpatialReference.js";import"./unitUtils.js";import"./jsonMap.js";import"./Ellipsoid.js";import"./writer.js";import"../geometry/Point.js";import"../core/accessorSupport/decorators/cast.js";import"../geometry/support/webMercatorUtils.js";import"../geometry/Multipoint.js";import"./zmUtils.js";import"../geometry/Polygon.js";import"./extentUtils.js";import"./aaBoundingRect.js";import"../geometry/Polyline.js";import"./typeUtils.js";import"../geometry/support/jsonUtils.js";import"./enumeration.js";import"../layers/support/fieldUtils.js";import"../symbols/Symbol.js";const y="esri.renderers.support.DictionaryLoader",u={type:"CIMSimpleLineCallout",lineSymbol:{type:"CIMLineSymbol",symbolLayers:[{type:"CIMSolidStroke",width:.5,color:[0,0,0,255]}]}};class f{constructor(t,s,e){this.config=null,this.fieldMap=null,this.url=null,this._ongoingRequests=new Map,this._symbolCache=new r(100),this._dictionaryPromise=null,this.url=t,this.config=s,this.fieldMap=e}getSymbolFields(){return this._symbolFields}async getSymbolAsync(s,e){let o;this._dictionaryPromise||(this._dictionaryPromise=this.fetchResources(e));try{o=await this._dictionaryPromise}catch(t){if(l(t))return this._dictionaryPromise=null,null}const r={};if(this.fieldMap)for(const t of this._symbolFields){const e=this.fieldMap[t];if(e&&null!=s.attributes[e]){const o=""+s.attributes[e];r[t]=o}else r[t]=""}const n=o?.(r,e);if(!n||"string"!=typeof n)return null;const a=m(n).toString(),c=this._symbolCache.get(a);if(c)return c.catch((()=>{this._symbolCache.pop(a)})),c;const p=n.split(";"),y=[],u=[];for(const s of p)if(s)if(s.includes("po:")){const e=s.substr(3).split("|");if(3===e.length){const s=e[0],o=e[1];let r=e[2];if("DashTemplate"===o)r=r.split(" ").map((t=>Number(t)));else if("Color"===o){const s=new t(r).toRgba();r=[s[0],s[1],s[2],255*s[3]]}else r=Number(r);u.push({primitiveName:s,propertyName:o,value:r})}}else if(s.includes("|")){for(const t of s.split("|"))if(this._itemNames.has(t)){y.push(t);break}}else this._itemNames.has(s)&&y.push(s);const f=!i(s.geometry)||!s.geometry.hasZ&&"point"===s.geometry.type,h=this._cimPartsToCIMSymbol(y,u,f,e);return this._symbolCache.put(a,h,1),h}async fetchResources(t){if(this._dictionaryPromise)return this._dictionaryPromise;if(!this.url)return void o.getLogger(y).error("no valid URL!");const r=s(this.url+"/resources/styles/dictionary-info.json",{responseType:"json",query:{f:"json"},signal:i(t)?t.signal:null}),[{data:l}]=await Promise.all([r,a()]);if(!l)throw this._dictionaryPromise=null,new e("esri.renderers.DictionaryRenderer","Bad dictionary data!");const m=l.expression,p=l.authoringInfo;this._refSymbolUrlTemplate=this.url+"/"+l.cimRefTemplateUrl,this._itemNames=new Set(l.itemsNames),this._symbolFields=p.symbol;const u={};if(this.config){const t=this.config;for(const s in t)u[s]=t[s]}if(p.configuration)for(const t of p.configuration)u.hasOwnProperty(t.name)||(u[t.name]=t.value);const f=[];if(i(t)&&t.fields&&this.fieldMap)for(const s of this._symbolFields){const e=this.fieldMap[s],o=t.fields.filter((t=>t.name===e));o.length>0&&f.push({...o[0],name:s})}const h=c(m,i(t)?t.spatialReference:null,f,u).then((t=>{const s={scale:0};return(e,o)=>{if(n(t))return null;const r=t.repurposeFeature({geometry:null,attributes:e});return s.scale=i(o)?o.scale??void 0:void 0,t.evaluate({$feature:r,$view:s})}})).catch((t=>(o.getLogger(y).error("Creating dictinoary expression failed:",t),null)));return this._dictionaryPromise=h,h}async _cimPartsToCIMSymbol(t,s,e,o){const r=new Array(t.length);for(let s=0;s<t.length;s++)r[s]=this._getSymbolPart(t[s],o);const i=await Promise.all(r),n=this.fieldMap;if(n)for(const t of i)h(t,n);return new p({data:this._combineSymbolParts(i,s,e)})}async _getSymbolPart(t,e){if(this._ongoingRequests.has(t))return this._ongoingRequests.get(t).then((t=>t.data));const o=this._refSymbolUrlTemplate.replace(/\{itemName\}/gi,t),r=s(o,{responseType:"json",query:{f:"json"},...e});this._ongoingRequests.set(t,r);try{return(await r).data}catch(s){throw this._ongoingRequests.delete(t),s}}_combineSymbolParts(t,s,e){if(!t||0===t.length)return null;const o={...t[0]};if(t.length>1){o.symbolLayers=[];for(const s of t){const t=s;o.symbolLayers.unshift(...t.symbolLayers)}}return e&&(o.callout=u),{type:"CIMSymbolReference",symbol:o,primitiveOverrides:s}}}function h(t,s){if(!t)return;const e=t.symbolLayers;if(!e)return;let o=e.length;for(;o--;){const t=e[o];t&&!1!==t.enable&&"CIMVectorMarker"===t.type&&j(t,s)}}function j(t,s){const e=t.markerGraphics;if(e)for(const t of e){if(!t)continue;const e=t.symbol;if(e)switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":h(e,s);break;case"CIMTextSymbol":e.fieldMap=s}}}export{f as DictionaryLoader};
