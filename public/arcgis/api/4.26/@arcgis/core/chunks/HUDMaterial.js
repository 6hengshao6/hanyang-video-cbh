/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{h as e}from"./typedArrayUtil.js";import{c as t}from"./mathUtils.js";import{i as s,e as i}from"./maybe.js";import{f as r}from"./mat3.js";import{c as a}from"./mat3f64.js";import{c as o}from"./mat4.js";import{c as n}from"./mat4f64.js";import{k as l}from"./vec2.js";import{a as c,f as p}from"./vec2f64.js";import{s as f,e as h,n as d,b as u,g as m,c as g,l as v,D as O,t as S,m as y,a as A,d as P,f as b}from"./vec3.js";import{c as x,f as I}from"./vec4f64.js";import{c as T}from"./aaBoundingRect.js";import{c as _}from"./BufferView.js";import{e as C}from"./glUtil3D.js";import{n as E}from"./InterleavedLayout.js";import{S as j}from"./ShaderOutput.js";import{H as L}from"./AlignPixel.glsl.js";import{G as z,a as D}from"./GLTextureMaterial.js";import{D as M,b as w,d as R,e as U,p as N,v as V,R as B}from"./Material.js";import{R as H}from"./RenderSlot.js";import{a as G}from"./Util2.js";import{V as F}from"./VertexAttribute.js";import{k as X,l as W,m as q,o as Z,p as k,q as J}from"./DefaultBufferWriter.js";import{H as Y,c as Q}from"./HUDMaterial.glsl.js";import{V as K}from"./ViewingMode.js";import{R as $,S as ee,P as te}from"./Program2.js";import{o as se}from"./OrderIndependentTransparency.js";import{T as ie}from"./TransparencyPassType.js";import{B as re,e as ae,d as oe}from"./enums3.js";import{b as ne,d as le,m as ce,a as pe}from"./renderState.js";import{_ as fe}from"./tslib.es6.js";import{p as he}from"./ShaderTechniqueConfiguration.js";import{D as de}from"./DefaultTechniqueConfiguration.js";class ue{constructor(){this.factor=new me,this.factorAlignment=new me}}class me{constructor(){this.scale=0,this.factor=0,this.minPixelSize=0,this.paddingPixels=0}}class ge extends ee{initializeConfiguration(e,t){t.spherical=e.viewingMode===K.Global}initializeProgram(e){return new te(e.rctx,ge.shader.get().build(this.configuration),M)}_setPipelineState(e){const t=this.configuration,s=e===ie.NONE,i=e===ie.FrontFace,r=this.configuration.hasPolygonOffset?ve:null,a=(s||i)&&t.output!==j.Highlight&&(t.depthEnabled||t.occlusionPass)?le:null;return ce({blending:t.output===j.Color||t.output===j.Alpha||t.output===j.Highlight?s?Oe:se(e):null,depthTest:{func:ae.LEQUAL},depthWrite:a,colorWrite:pe,polygonOffset:r})}initializePipeline(){return this._setPipelineState(this.configuration.transparencyPassType)}get primitiveType(){return this.configuration.occlusionPass?oe.POINTS:oe.TRIANGLES}}ge.shader=new $(Y,(()=>import("./HUDMaterial.glsl.js").then((e=>e.H))));const ve={factor:0,units:-4},Oe=ne(re.ONE,re.ONE_MINUS_SRC_ALPHA);class Se extends de{constructor(){super(...arguments),this.output=j.Color,this.screenCenterOffsetUnitsEnabled=L.World,this.transparencyPassType=ie.NONE,this.spherical=!1,this.occlusionTestEnabled=!0,this.signedDistanceFieldEnabled=!1,this.vvSize=!1,this.vvColor=!1,this.hasVerticalOffset=!1,this.hasScreenSizePerspective=!1,this.debugDrawLabelBorder=!1,this.binaryHighlightOcclusionEnabled=!0,this.hasSlicePlane=!1,this.hasPolygonOffset=!1,this.depthEnabled=!0,this.pixelSnappingEnabled=!0,this.isDraped=!1,this.hasMultipassGeometry=!1,this.hasMultipassTerrain=!1,this.cullAboveGround=!1,this.occlusionPass=!1,this.objectAndLayerIdColorInstanced=!1}}fe([he({count:j.COUNT})],Se.prototype,"output",void 0),fe([he({count:L.COUNT})],Se.prototype,"screenCenterOffsetUnitsEnabled",void 0),fe([he({count:ie.COUNT})],Se.prototype,"transparencyPassType",void 0),fe([he()],Se.prototype,"spherical",void 0),fe([he()],Se.prototype,"occlusionTestEnabled",void 0),fe([he()],Se.prototype,"signedDistanceFieldEnabled",void 0),fe([he()],Se.prototype,"vvSize",void 0),fe([he()],Se.prototype,"vvColor",void 0),fe([he()],Se.prototype,"hasVerticalOffset",void 0),fe([he()],Se.prototype,"hasScreenSizePerspective",void 0),fe([he()],Se.prototype,"debugDrawLabelBorder",void 0),fe([he()],Se.prototype,"binaryHighlightOcclusionEnabled",void 0),fe([he()],Se.prototype,"hasSlicePlane",void 0),fe([he()],Se.prototype,"hasPolygonOffset",void 0),fe([he()],Se.prototype,"depthEnabled",void 0),fe([he()],Se.prototype,"pixelSnappingEnabled",void 0),fe([he()],Se.prototype,"isDraped",void 0),fe([he()],Se.prototype,"hasMultipassGeometry",void 0),fe([he()],Se.prototype,"hasMultipassTerrain",void 0),fe([he()],Se.prototype,"cullAboveGround",void 0),fe([he()],Se.prototype,"occlusionPass",void 0),fe([he()],Se.prototype,"objectAndLayerIdColorInstanced",void 0),fe([he({constValue:!0})],Se.prototype,"hasSliceInVertexProgram",void 0),fe([he({constValue:!1})],Se.prototype,"hasVvInstancing",void 0);class ye extends w{constructor(e){super(e,new Be),this._configuration=new Se}getConfiguration(e,t){return this._configuration.output=e,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasVerticalOffset=!!this.parameters.verticalOffset,this._configuration.hasScreenSizePerspective=!!this.parameters.screenSizePerspective,this._configuration.screenCenterOffsetUnitsEnabled="screen"===this.parameters.centerOffsetUnits?L.Screen:L.World,this._configuration.hasPolygonOffset=this.parameters.polygonOffset,this._configuration.isDraped=this.parameters.isDraped,this._configuration.occlusionTestEnabled=this.parameters.occlusionTest,this._configuration.pixelSnappingEnabled=this.parameters.pixelSnappingEnabled,this._configuration.signedDistanceFieldEnabled=this.parameters.textureIsSignedDistanceField,this._configuration.vvSize=!!this.parameters.vvSize,this._configuration.vvColor=!!this.parameters.vvColor,this._configuration.occlusionPass=t.slot===H.OCCLUSION_PIXELS&&this.parameters.occlusionTest&&(e===j.Color||e===j.Alpha),e===j.Color&&(this._configuration.debugDrawLabelBorder=!!C.LABELS_SHOW_BORDER),e===j.Highlight&&(this._configuration.binaryHighlightOcclusionEnabled=this.parameters.binaryHighlightOcclusion),this._configuration.depthEnabled=this.parameters.depthEnabled,this._configuration.transparencyPassType=t.transparencyPassType,this._configuration.hasMultipassGeometry=t.multipassGeometry.enabled,this._configuration.hasMultipassTerrain=t.multipassTerrain.enabled,this._configuration.cullAboveGround=t.multipassTerrain.cullAboveGround,this._configuration}intersect(e,t,i,a,n,l){if(!i.options.selectionMode||!i.options.hud||!e.visible)return;const c=this.parameters;let p=1,S=1;if(r(je,t),s(e.shaderTransformer)){const t=e.shaderTransformer(we);p=t[0],S=t[5],function(e){const t=e[0],s=e[1],i=e[2],r=e[3],a=e[4],o=e[5],n=e[6],l=e[7],c=e[8],p=1/Math.sqrt(t*t+s*s+i*i),f=1/Math.sqrt(r*r+a*a+o*o),h=1/Math.sqrt(n*n+l*l+c*c);e[0]=t*p,e[1]=s*p,e[2]=i*p,e[3]=r*f,e[4]=a*f,e[5]=o*f,e[6]=n*h,e[7]=l*h,e[8]=c*h}(je)}const y=e.vertexAttributes.get(F.POSITION),A=e.vertexAttributes.get(F.SIZE),b=e.vertexAttributes.get(F.NORMAL),x=e.vertexAttributes.get(F.AUXPOS1);G(y.size>=3);const I=i.point,T=i.camera,_=Q(c);p*=T.pixelRatio,S*=T.pixelRatio;const C="screen"===this.parameters.centerOffsetUnits;for(let e=0;e<y.data.length/y.size;e++){const s=e*y.size;f(Ie,y.data[s],y.data[s+1],y.data[s+2]),h(Ie,Ie,t);const r=e*A.size;Ne[0]=A.data[r]*p,Ne[1]=A.data[r+1]*S,h(Ie,Ie,T.viewMatrix);const a=e*x.size;if(f(De,x.data[a],x.data[a+1],x.data[a+2]),!C&&(Ie[0]+=De[0],Ie[1]+=De[1],0!==De[2])){const e=De[2];d(De,Ie),u(Ie,Ie,m(De,De,e))}const n=e*b.size;if(f(Te,b.data[n],b.data[n+1],b.data[n+2]),this._normalAndViewAngle(Te,je,T,Me),this._applyVerticalOffsetTransformationView(Ie,Me,T,be),T.applyProjection(Ie,_e),_e[0]>-1){_e[0]=Math.floor(_e[0]),_e[1]=Math.floor(_e[1]),C&&(De[0]||De[1])&&(_e[0]+=De[0],0!==De[1]&&(_e[1]+=R(De[1],be.factorAlignment)),T.unapplyProjection(_e,Ie)),_e[0]+=this.parameters.screenOffset[0],_e[1]+=this.parameters.screenOffset[1],U(Ne,be.factor,Ne);const e=Re*T.pixelRatio;let t=0;if(c.textureIsSignedDistanceField&&(t=c.outlineSize*T.pixelRatio/2),I&&Pe(I,_e[0],_e[1],Ne,e,t,c,_)){const e=i.ray;if(h(Ee,Ie,o(ze,T.viewMatrix)),_e[0]=I[0],_e[1]=I[1],T.unprojectFromRenderScreen(_e,Ie)){const t=P();g(t,e.direction);const s=1/v(t);m(t,t,s),l(O(e.origin,Ie)*s,t,-1,!0,1,Ee)}}}}}intersectDraped(e,t,i,r,a,o){const n=e.vertexAttributes.get(F.POSITION),l=e.vertexAttributes.get(F.SIZE),c=this.parameters,p=Q(c);let f=1,h=1;if(s(e.shaderTransformer)){const t=e.shaderTransformer(we);f=t[0],h=t[5]}f*=e.screenToWorldRatio,h*=e.screenToWorldRatio;const d=Ue*e.screenToWorldRatio;for(let t=0;t<n.data.length/n.size;t++){const s=t*n.size,i=n.data[s],u=n.data[s+1],m=t*l.size;Ne[0]=l.data[m]*f,Ne[1]=l.data[m+1]*h;let g=0;c.textureIsSignedDistanceField&&(g=c.outlineSize*e.screenToWorldRatio/2),Pe(r,i,u,Ne,d,g,c,p)&&a(o.dist,o.normal,-1,!1)}}createBufferWriter(){return new Fe(this)}_normalAndViewAngle(e,t,s,i){return(function(e){return e instanceof Float32Array&&e.length>=16}(a=t)||function(e){return Array.isArray(e)&&e.length>=16}(a))&&(t=r(Le,t)),S(i.normal,e,t),h(i.normal,i.normal,s.viewInverseTransposeMatrix),i.cosAngle=y(Ce,Ve),i;var a}_updateScaleInfo(e,t,i){const r=this.parameters;s(r.screenSizePerspective)?N(i,t,r.screenSizePerspective,e.factor):(e.factor.scale=1,e.factor.factor=0,e.factor.minPixelSize=0,e.factor.paddingPixels=0),s(r.screenSizePerspectiveAlignment)?N(i,t,r.screenSizePerspectiveAlignment,e.factorAlignment):(e.factorAlignment.factor=e.factor.factor,e.factorAlignment.scale=e.factor.scale,e.factorAlignment.minPixelSize=e.factor.minPixelSize,e.factorAlignment.paddingPixels=e.factor.paddingPixels)}applyShaderOffsetsView(e,t,s,i,r,a,o){const n=this._normalAndViewAngle(t,s,r,Me);return this._applyVerticalGroundOffsetView(e,n,r,o),this._applyVerticalOffsetTransformationView(o,n,r,a),this._applyPolygonOffsetView(o,n,i[3],r,o),this._applyCenterOffsetView(o,i,o),o}applyShaderOffsetsNDC(e,t,i,r,a){return this._applyCenterOffsetNDC(e,t,i,r),s(a)&&g(a,r),this._applyPolygonOffsetNDC(r,t,i,r),r}_applyPolygonOffsetView(e,s,i,r,a){const o=r.aboveGround?1:-1;let n=Math.sign(i);0===n&&(n=o);const l=o*n;if(this.parameters.shaderPolygonOffset<=0)return g(a,e);const c=t(Math.abs(s.cosAngle),.01,1),p=1-Math.sqrt(1-c*c)/c/r.viewport[2];return m(a,e,l>0?p:1/p),a}_applyVerticalGroundOffsetView(e,t,s,i){const r=v(e),a=s.aboveGround?1:-1,o=.5*s.computeRenderPixelSizeAtDist(r),n=m(Ie,t.normal,a*o);return A(i,e,n),i}_applyVerticalOffsetTransformationView(e,t,s,r){const a=this.parameters;if(!a.verticalOffset||!a.verticalOffset.screenLength){if(a.screenSizePerspective||a.screenSizePerspectiveAlignment){const s=v(e);this._updateScaleInfo(r,s,t.cosAngle)}else r.factor.scale=1,r.factorAlignment.scale=1;return e}const o=v(e),n=i(a.screenSizePerspectiveAlignment,a.screenSizePerspective),l=V(s,o,a.verticalOffset,t.cosAngle,n);return this._updateScaleInfo(r,o,t.cosAngle),m(t.normal,t.normal,l),A(e,e,t.normal)}_applyCenterOffsetView(e,t,s){const i="screen"!==this.parameters.centerOffsetUnits;return s!==e&&g(s,e),i&&(s[0]+=t[0],s[1]+=t[1],t[2]&&(d(Te,s),A(s,s,m(Te,Te,t[2])))),s}_applyCenterOffsetNDC(e,t,s,i){const r="screen"!==this.parameters.centerOffsetUnits;return i!==e&&g(i,e),r||(i[0]+=t[0]/s.fullWidth*2,i[1]+=t[1]/s.fullHeight*2),i}_applyPolygonOffsetNDC(e,t,s,i){const r=this.parameters.shaderPolygonOffset;if(e!==i&&g(i,e),r){const e=s.aboveGround?1:-1,a=e*Math.sign(t[3]);i[2]-=(a||e)*r}return i}requiresSlot(e,t){if(t===j.Color||t===j.Alpha||t===j.Highlight||t===j.ObjectAndLayerIdColor){if(e===H.DRAPED_MATERIAL)return!0;const{drawInSecondSlot:t,occlusionTest:s}=this.parameters;return e===(t?H.LABEL_MATERIAL:H.HUD_MATERIAL)||s&&e===H.OCCLUSION_PIXELS}return!1}createGLMaterial(e){return new Ae(e)}calculateRelativeScreenBounds(e,t,s=T()){return function(e,t,s,i=xe){l(i,e.anchorPosition),i[0]*=-t[0],i[1]*=-t[1],i[0]+=e.screenOffset[0]*s,i[1]+=e.screenOffset[1]*s}(this.parameters,e,t,s),s[2]=s[0]+e[0],s[3]=s[1]+e[1],s}}class Ae extends z{constructor(e){super({...e,...e.material.parameters})}selectProgram(e){return this.ensureTechnique(ge,e)}beginSlot(e){return this.updateTexture(this._material.parameters.textureId),this._material.setParameters(this.textureBindParameters),this.selectProgram(e)}}function Pe(e,t,i,r,a,o,n,l){let c=t-a-(l[0]>0?r[0]*l[0]:0),p=c+r[0]+2*a,f=i-a-(l[1]>0?r[1]*l[1]:0),h=f+r[1]+2*a;const d=n.distanceFieldBoundingBox;return n.textureIsSignedDistanceField&&s(d)&&(c+=r[0]*d[0],f+=r[1]*d[1],p-=r[0]*(1-d[2]),h-=r[1]*(1-d[3]),c-=o,p+=o,f-=o,h+=o),e[0]>c&&e[0]<p&&e[1]>f&&e[1]<h}const be=new ue,xe=c(),Ie=P(),Te=P(),_e=x(),Ce=P(),Ee=P(),je=a(),Le=a(),ze=n(),De=P(),Me={normal:Ce,cosAngle:0},we=n(),Re=1,Ue=2,Ne=[0,0],Ve=b(0,0,1);class Be extends D{constructor(){super(...arguments),this.renderOccluded=B.Occlude,this.color=I(1,1,1,1),this.texCoordScale=[1,1],this.polygonOffset=!1,this.anchorPosition=p(.5,.5),this.screenOffset=[0,0],this.shaderPolygonOffset=1e-5,this.textureIsSignedDistanceField=!1,this.outlineColor=I(1,1,1,1),this.outlineSize=0,this.vvSizeEnabled=!1,this.vvSize=null,this.vvColor=null,this.vvOpacity=null,this.vvSymbolAnchor=null,this.vvSymbolRotationMatrix=null,this.hasSlicePlane=!1,this.pixelSnappingEnabled=!0,this.occlusionTest=!0,this.binaryHighlightOcclusion=!0,this.centerOffsetUnits="world",this.drawInSecondSlot=!1,this.depthEnabled=!0,this.isDraped=!1}}const He=E().vec3f(F.POSITION).vec3f(F.NORMAL).vec2f(F.UV0).vec4u8(F.COLOR).vec2f(F.SIZE).vec4f(F.AUXPOS1).vec4f(F.AUXPOS2),Ge=He.clone().vec4u8(F.OBJECTANDLAYERIDCOLOR);class Fe{constructor(t){this._material=t,this.vertexBufferLayout=e("enable-feature:objectAndLayerId-rendering")?Ge:He}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){return 6*e.indices.get(F.POSITION).length}write(e,t,i,r,a){X(i.indices.get(F.POSITION),i.vertexAttributes.get(F.POSITION).data,e,r.position,a,6),W(i.indices.get(F.NORMAL),i.vertexAttributes.get(F.NORMAL).data,t,r.normal,a,6);const o=i.vertexAttributes.get(F.UV0).data;let n,l,c,p;if(null==o||o.length<4){const e=this._material.parameters;n=0,l=0,c=e.texCoordScale[0],p=e.texCoordScale[1]}else n=o[0],l=o[1],c=o[2],p=o[3];c=Math.min(1.99999,c+1),p=Math.min(1.99999,p+1);let f=i.indices.get(F.POSITION).length,h=a;const d=r.uv0;for(let e=0;e<f;++e)d.set(h,0,n),d.set(h,1,l),h+=1,d.set(h,0,c),d.set(h,1,l),h+=1,d.set(h,0,c),d.set(h,1,p),h+=1,d.set(h,0,c),d.set(h,1,p),h+=1,d.set(h,0,n),d.set(h,1,p),h+=1,d.set(h,0,n),d.set(h,1,l),h+=1;q(i.indices.get(F.COLOR),i.vertexAttributes.get(F.COLOR).data,4,r.color,a,6);const u=i.indices.get(F.SIZE),m=i.vertexAttributes.get(F.SIZE).data;f=u.length;const g=r.size;h=a;for(let e=0;e<f;++e){const t=m[2*u[e]],s=m[2*u[e]+1];for(let e=0;e<6;++e)g.set(h,0,t),g.set(h,1,s),h+=1}if(i.indices.get(F.AUXPOS1)&&i.vertexAttributes.get(F.AUXPOS1)?Z(i.indices.get(F.AUXPOS1),i.vertexAttributes.get(F.AUXPOS1).data,r.auxpos1,a,6):k(r.auxpos1,a,6*f),i.indices.get(F.AUXPOS2)&&i.vertexAttributes.get(F.AUXPOS2)?Z(i.indices.get(F.AUXPOS2),i.vertexAttributes.get(F.AUXPOS2).data,r.auxpos2,a,6):k(r.auxpos2,a,6*f),s(i.objectAndLayerIdColor)&&i.indices.get(F.POSITION)){const e=i.indices.get(F.POSITION).length,t=r.getField(F.OBJECTANDLAYERIDCOLOR,_);J(i.objectAndLayerIdColor,t,e,a,6)}}}export{ye as H,ue as S};
