/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import t from"../core/Evented.js";import{HandleOwner as i}from"../core/HandleOwner.js";import{i as s,a as n,u as r}from"./maybe.js";import{eachAlwaysValues as o,throwIfAborted as a,isAborted as d}from"../core/promiseUtils.js";import{sync as c,watch as h,syncAndInitial as p}from"../core/reactiveUtils.js";import{property as l}from"../core/accessorSupport/decorators/property.js";import{s as u}from"./ensureType.js";import"./typedArrayUtil.js";import{subclass as g}from"../core/accessorSupport/decorators/subclass.js";import{project as f,initializeProjection as S}from"../geometry/projection.js";import{f as y}from"./elevationInfoUtils.js";import{d as m}from"./Settings2.js";import{a as _,L as v}from"./LineSnappingHint.js";import w from"../core/Handles.js";import{a as E,b as x,e as T,u as C,q as P,d as R,l as L}from"./vec2.js";import{H as V,c as F,d as I,k as j,b as M,a as O,j as N,f as D,s as q,w as b,A as H}from"./vec3.js";import{g as A}from"./common.js";import{S as z}from"./QueryEngineResult.js";import{S as G,V as k,F as U,E as Z,a as W,p as X,b as Q,I as B}from"./EdgeSnappingCandidate.js";import{L as J,b as K,d as Y,e as $,f as ee,g as te,h as ie,p as se,i as ne}from"./snappingUtils.js";import{D as re}from"./DrapedEdgeSnappingCandidate.js";import{R as oe,P as ae,I as de}from"./RightAngleSnappingHint.js";import{a as ce}from"./viewUtils.js";import he from"../core/Accessor.js";import pe from"../core/Collection.js";import{L as le,p as ue,a as ge}from"./geometry2dUtils.js";import{a as fe}from"./vec2f64.js";import Se from"../views/interactive/snapping/SnappingOptions.js";class ye extends G{constructor({targetPoint:e,constraint:t,previousVertex:i,otherVertex:s,otherVertexType:n,objectId:r,isDraped:o}){super(e,t,o,_.SELF),this.previousVertex=i,this.otherVertex=s,this.otherVertexType=n,this.objectId=r}get hints(){const e=this.previousVertex,t=this.otherVertexType===me.CENTER?this.otherVertex:this.targetPoint,i=this.otherVertexType===me.CENTER?this.targetPoint:this.otherVertex;return[new v(J.TARGET,t,i,this.isDraped,this.domain),new v(J.REFERENCE,e,t,this.isDraped,this.domain),new oe(this.previousVertex,t,i,this.isDraped,this.domain)]}}var me;!function(e){e[e.NEXT=0]="NEXT",e[e.CENTER=1]="CENTER"}(me||(me={}));let _e=class extends i{get updating(){return u(this.snappingSources,(({snappingSource:e})=>e.updating))||this.updatingHandles.updating}get snappingSources(){const e=this._get("snappingSources")||new Map,t=new Map;if(s(this.options)&&s(this.options.featureSources))for(const i of this.options.featureSources.items){const n=i.layer.uid,r=e.get(n);if(r){e.delete(n),t.set(n,r);continue}if(!i.layer.loaded){this.updatingHandles.addPromise(i.layer.load());continue}const o=this._createSourceInfo(i);s(o)&&t.set(n,o)}for(const[,t]of e)t.destroy();return t}constructor(e){super(e),this.options=null,this._domain=_.FEATURE,this._sourceModules={featureService:{module:null,loader:null},featureCollection:{module:null,loader:null},graphics:{module:null,loader:null},notes:{module:null,loader:null},scene:{module:null,loader:null}}}initialize(){this.updatingHandles.add((()=>this.snappingSources),(()=>this.notifyChange("updating")),c),s(this.view)&&this.handles.add([this.view.on("layerview-create",(e=>this._updateLayerView(e.layer,e.layerView))),this.view.on("layerview-destroy",(e=>this._updateLayerView(e.layer,null)))])}_updateLayerView(e,t){for(const[,i]of this.snappingSources)i.snappingSource.layerSource.layer===e&&(i.layerView=t)}destroy(){this._set("options",null);for(const[,e]of this.snappingSources)e.destroy()}async fetchCandidates(e,t,i,d){if(!(t&this._domain)||n(this.options)||!this.options.effectiveFeatureEnabled)return[];const c=[],h=this._computeScreenSizeDistanceParameters(e,i),p={distance:h,mode:r(this.view)?.type??"2d",point:e,coordinateHelper:i.coordinateHelper,types:this._types};for(const[,{snappingSource:e,layerView:t}]of this.snappingSources)!e.layerSource.enabled||s(t)&&t.suspended||c.push(e.fetchCandidates(p,d).then((t=>t.filter((t=>!this._candidateIsExcluded(e,t,i.excludeFeature))))));const l=(await o(c)).flat();return this._addRightAngleCandidates(l,e,h,i),a(d),K(e,l),l}_addRightAngleCandidates(e,t,i,n){const o=s(n.vertexHandle)?n.vertexHandle.rightEdge?.rightVertex?.pos:s(n.editGeometryOperations)&&"polygon"===n.editGeometryOperations.data.type?r(n.editGeometryOperations.data.components[0]?.getFirstVertex())?.pos:null,a=s(n.vertexHandle)?n.vertexHandle.leftEdge?.leftVertex?.pos:s(n.editGeometryOperations)?r(n.editGeometryOperations.data.components[0]?.getLastVertex())?.pos:null,{view:d}=this,c=Y(o,d,n),h=Y(a,d,n),p=e.length;for(let s=0;s<p;s++)this._addRightAngleCandidate(e[s],h,t,i,e),this._addRightAngleCandidate(e[s],c,t,i,e)}_addRightAngleCandidate(e,t,i,s,r){if(n(t)||!function(e){return(e instanceof Z||e instanceof re)&&!function({constraint:{start:e,end:t}}){const i=V(e,t),s=E(e,t);return i<A()||s/i<Te}(e)}(e))return;const o=e.constraint.closestTo(t),a=(o[0]-i[0])/s.x,d=(o[1]-i[1])/s.y,{start:c,end:h}=e.constraint;if(a*a+d*d<=1){const i=new ye({targetPoint:o,otherVertex:t,otherVertexType:me.NEXT,previousVertex:E(o,c)>E(o,h)?c:h,constraint:new k(t,o),objectId:e.objectId,isDraped:e.isDraped});r.push(i)}}_computeScreenSizeDistanceParameters(e,t){let i=s(this.options)?this.options.distance*("touch"===t.pointer?this.options.touchSensitivityMultiplier:1):0;return n(this.view)?{x:i,y:i,z:i,distance:i}:"2d"===this.view.type?(i*=this.view.resolution,{x:i,y:i,z:i,distance:i}):this._computeScreenSizeDistanceParameters3D(e,i,this.view,t)}_computeScreenSizeDistanceParameters3D(e,t,i,s){const{spatialReference:n}=s;i.renderCoordsHelper.toRenderCoords(e,n,Ee);const r=i.state.camera.computeScreenPixelSizeAt(Ee),o=r*i.renderCoordsHelper.unitInMeters/i.mapCoordsHelper.unitInMeters,a=t*o,d=ce(e,n,y,i),c=d?we(d,e,o,0,0,i,s):0,h=d?we(d,e,0,o,0,i,s):0,p=d?we(d,e,0,0,o,i,s):0;return{x:0===c?0:a/c,y:0===h?0:a/h,z:0===p?0:a/p,distance:r*t}}get _types(){return z.EDGE|z.VERTEX}_candidateIsExcluded(e,t,i){if(n(i))return!1;const s=this._getCandidateObjectId(t);if(n(s))return!1;const r=e.layerSource.layer;return"graphics"===r.type?i.uid===s:i.sourceLayer===r&&!(!i.attributes||!("objectIdField"in r))&&i.attributes[r.objectIdField]===s}_getCandidateObjectId(e){return e instanceof U?e.objectId:null}_createSourceInfo(e){const t=this._createFeatureSnappingSourceType(e);if(n(t))return null;if("loading"in t)return this.updatingHandles.addPromise(t.loading.then((()=>{this.destroyed||this.notifyChange("snappingSources")}))),null;const i=s(this.view)?this.view.allLayerViews.find((t=>t.layer===e.layer)):null;return new ve(t.source,i)}_createFeatureSnappingSourceType(e){switch(e.layer.type){case"feature":case"geojson":case"csv":case"oriented-imagery":case"subtype-group":case"wfs":return this._createFeatureSnappingSourceFeatureLayer(e);case"graphics":return this._createFeatureSnappingSourceGraphicsLayer(e);case"map-notes":return this._createFeatureSnappingSourceMapNotesLayer(e);case"scene":case"building-scene":return this._createFeatureSnappingSourceSceneLayer(e)}return null}_createFeatureSnappingSourceSceneLayer(e){const{view:t}=this;if(n(t)||"3d"!==t.type)return null;const i=this._getSourceModule("scene");return s(i.module)?{source:new i.module.SceneLayerSnappingSource({layerSource:e,view:t})}:{loading:i.loader}}_createFeatureSnappingSourceFeatureLayer(e){switch(e.layer.source?.type){case"feature-layer":case"oriented-imagery":{const t=this._getSourceModule("featureService");return s(t.module)?{source:new t.module.FeatureServiceSnappingSource({spatialReference:this.spatialReference,view:this.view,layerSource:e})}:{loading:t.loader}}case"memory":case"csv":case"geojson":case"wfs":{if("mesh"===e.layer.geometryType)return null;const t=this._getSourceModule("featureCollection");return s(t.module)?{source:new t.module.FeatureCollectionSnappingSource({layerSource:e,view:this.view})}:{loading:t.loader}}}return null}_createFeatureSnappingSourceGraphicsLayer(e){const t=this._getSourceModule("graphics");return s(t.module)?{source:new t.module.GraphicsSnappingSource({getGraphicsLayers:()=>[e.layer],spatialReference:this.spatialReference,view:this.view,layerSource:e})}:{loading:t.loader}}_createFeatureSnappingSourceMapNotesLayer(e){const t=this._getSourceModule("notes");return s(t.module)?{source:new t.module.GraphicsSnappingSource({getGraphicsLayers:()=>s(e.layer.sublayers)?e.layer.sublayers.toArray():[],spatialReference:this.spatialReference,view:this.view,layerSource:e})}:{loading:t.loader}}_getSourceModule(e){const t=this._sourceModules[e];if(n(t.loader)){const i=this._loadSourceModule(e).then((e=>{t.module=e}));return t.loader=i,{module:t.module,loader:i}}return{module:t.module,loader:t.loader}}_loadSourceModule(e){const t=this.updatingHandles;switch(e){case"featureService":return t.addPromise(import("./FeatureServiceSnappingSource.js"));case"featureCollection":return t.addPromise(import("./FeatureCollectionSnappingSource.js"));case"graphics":case"notes":return t.addPromise(import("./GraphicsSnappingSource.js"));case"scene":return t.addPromise(import("./SceneLayerSnappingSource.js"))}}};e([l({constructOnly:!0})],_e.prototype,"spatialReference",void 0),e([l({constructOnly:!0})],_e.prototype,"view",void 0),e([l()],_e.prototype,"options",void 0),e([l({readOnly:!0})],_e.prototype,"updating",null),e([l({readOnly:!0})],_e.prototype,"snappingSources",null),_e=e([g("esri.views.interactive.snapping.FeatureSnappingEngine")],_e);class ve{constructor(e,t){this.snappingSource=e,this.layerView=t,this.handles=new w;const i=this.snappingSource.layerSource.layer;if("refresh"in i){const t=i;this.handles.add(t.on("refresh",(()=>e.refresh())))}this.handles.add([h((()=>e.updating),(t=>e.layerSource.updating=t),p),h((()=>e.availability),(t=>e.layerSource.availability=t),p)])}destroy(){this.snappingSource.destroy(),this.handles.destroy()}}function we(e,t,i,s,n,r,{spatialReference:o}){const a=F(xe,t);a[0]+=i,a[1]+=s,a[2]+=n;const d=ce(a,o,y,r);return d?$(d,e):1/0}const Ee=I(),xe=I(),Te=1e-4;class Ce{constructor(e,t){this.view=e,this.options=t,this.squaredShortLineThreshold=m.shortLineThreshold*m.shortLineThreshold}snap(e,t){return s(t.vertexHandle)?"vertex"!==t.vertexHandle.type?[]:this.snapExistingVertex(e,t):this.snapNewVertex(e,t)}edgeExceedsShortLineThreshold(e,t){return this.exceedsShortLineThreshold(Y(e.leftVertex.pos,this.view,t),Y(e.rightVertex.pos,this.view,t),t)}exceedsShortLineThreshold(e,t,{spatialReference:i}){return 0===this.squaredShortLineThreshold||ee(ce(t,i,y,this.view),ce(e,i,y,this.view))>this.squaredShortLineThreshold}isVertical(e,t){return E(e,t)<m.verticalLineThreshold}squaredProximityThreshold(e){return"touch"===e?this._squaredTouchProximityThreshold:this._squaredMouseProximityThreshold}get _squaredMouseProximityThreshold(){return this.options.distance*this.options.distance}get _squaredTouchProximityThreshold(){const{distance:e,touchSensitivityMultiplier:t}=this.options,i=e*t;return i*i}}class Pe extends G{constructor({lineStart:e,lineEnd:t,targetPoint:i,isDraped:s}){super(i,new W(e,t),s,_.SELF),this._referenceLineHint=new v(J.REFERENCE_EXTENSION,e,t,s,this.domain)}get hints(){return[this._referenceLineHint,new v(J.TARGET,this._lineEndClosestToTarget(),this.targetPoint,this.isDraped,this.domain)]}_lineEndClosestToTarget(){return this.constraint.closestEndTo(this.targetPoint)}}class Re extends Ce{snapNewVertex(e,t){const i=t.editGeometryOperations.data.components[0],s=i.edges.length,n=[];if(s<1)return n;const{spatialReference:r}=t,o=ce(e,r,y,this.view),{view:a}=this,d=i.edges[s-1];let c=d;do{if(this.edgeExceedsShortLineThreshold(c,t)){const i=te(c,a,t);this._processCandidateProposal(i.left,i.right,e,o,t,n)}c=c.leftVertex.leftEdge}while(c&&c!==d);return n}snapExistingVertex(e,t){const i=[],s=r(t.vertexHandle),n=s.component;if(n.edges.length<2)return i;const{view:o}=this,{spatialReference:a}=t,d=ce(e,a,y,o),c=s.leftEdge,h=s.rightEdge;c&&h&&this.edgeExceedsShortLineThreshold(c,t)&&this.edgeExceedsShortLineThreshold(h,t)&&this._processCandidateProposal(Y(c.leftVertex.pos,o,t),Y(h.rightVertex.pos,o,t),e,d,t,i);const p=n.edges[0];let l=p;do{if(l!==s.leftEdge&&l!==s.rightEdge&&this.edgeExceedsShortLineThreshold(l,t)){const s=te(l,o,t);this._processCandidateProposal(s.left,s.right,e,d,t,i)}l=l.rightVertex.rightEdge}while(l&&l!==p);return i}_processCandidateProposal(e,t,i,s,n,r){const{spatialReference:o,pointer:a}=n,d=ie(X(i,{start:e,end:t,type:le.LINE}));ee(s,ce(d,o,y,this.view))<this.squaredProximityThreshold(a)&&r.push(new Pe({lineStart:e,lineEnd:t,targetPoint:d,isDraped:"on-the-ground"===n.elevationInfo?.mode}))}}class Le extends G{constructor({referenceLine:e,lineStart:t,targetPoint:i,isDraped:s}){const n=j(t),{left:r,right:o}=e;M(n,O(n,n,o),r),super(i,new W(t,ie(n)),s,_.SELF),this._referenceLines=[{edge:e,fadeLeft:!0,fadeRight:!0}]}get hints(){return[new v(J.TARGET,this.constraint.start,this.targetPoint,this.isDraped,this.domain),new ae(this.constraint.start,this.targetPoint,this.isDraped,this.domain),...this._referenceLines.map((e=>new v(J.REFERENCE,e.edge.left,e.edge.right,this.isDraped,this.domain,e.fadeLeft,e.fadeRight)))]}addReferenceLine(e){const t={edge:e,fadeLeft:!0,fadeRight:!0};this._referenceLines.forEach((i=>{N(e.right,i.edge.left)&&(i.fadeLeft=!1,t.fadeRight=!1),N(e.right,i.edge.right)&&(i.fadeRight=!1,t.fadeRight=!1),N(e.left,i.edge.right)&&(i.fadeRight=!1,t.fadeLeft=!1),N(e.left,i.edge.left)&&(i.fadeLeft=!1,t.fadeLeft=!1)})),this._referenceLines.push(t)}}class Ve extends Ce{snapNewVertex(e,t){const i=t.editGeometryOperations.data.components[0],s=i.edges.length,n=i.vertices.length,r=[];if(s<2)return r;const{view:o}=this,a=ce(e,t.spatialReference,y,o),d=Y(i.vertices[n-1].pos,o,t),c=Y(i.vertices[0].pos,o,t),h=i.edges[s-1];let p=h;do{if(this.edgeExceedsShortLineThreshold(p,t)){const i=te(p,o,t);this._checkEdgeForParallelLines(i,d,e,a,t,r),this._checkEdgeForParallelLines(i,c,e,a,t,r)}p=p.leftVertex.leftEdge}while(p&&p!==h);return r}snapExistingVertex(e,t){const i=[],s=r(t.vertexHandle),n=s.component;if(n.edges.length<3)return i;const{view:o}=this,a=ce(e,t.spatialReference,y,o),d=s.leftEdge,c=s.rightEdge,h=n.vertices[0],p=Y(h.pos,o,t),l=n.vertices.length,u=n.vertices[l-1],g=Y(u.pos,o,t),f=n.edges[0];let S=f;do{if(S!==d&&S!==c&&this.edgeExceedsShortLineThreshold(S,t)){const n=te(S,o,t);d&&this._checkEdgeForParallelLines(n,Y(d.leftVertex.pos,o,t),e,a,t,i),c&&this._checkEdgeForParallelLines(n,Y(c.rightVertex.pos,o,t),e,a,t,i),s===h?this._checkEdgeForParallelLines(n,g,e,a,t,i):s===u&&this._checkEdgeForParallelLines(n,p,e,a,t,i)}S=S.rightVertex.rightEdge}while(S&&S!==f);return i}_checkEdgeForParallelLines(e,t,i,s,n,r){const o=e.left,a=e.right;if(ue(Fe,t,o,a),E(Fe,t)<m.parallelLineThreshold)return;ue(Fe,i,o,a,t);const{spatialReference:d,pointer:c}=n,h=ie(D(Fe[0],Fe[1],i[2]));if(ee(s,ce(h,d,y,this.view))<this.squaredProximityThreshold(c)){if(this.isVertical(h,t)||this.isVertical(o,a))return;if(this._parallelToPreviousCandidate(e,r))return;r.push(new Le({referenceLine:e,lineStart:t,targetPoint:h,isDraped:"on-the-ground"===n.elevationInfo?.mode}))}}_parallelToPreviousCandidate(e,t){const i=e.left,s=e.right;for(const n of t)if(ue(Fe,s,n.constraint.start,n.constraint.end,i),E(Fe,s)<m.parallelLineThreshold)return n.addReferenceLine(e),!0;return!1}}const Fe=fe();class Ie extends Ce{snapNewVertex(e,t){const i=t.editGeometryOperations.data.components[0],s=i.vertices.length,n=[];if(s<2)return n;const{view:r}=this,o=ce(e,t.spatialReference,y,r),a=i.vertices[s-1];if(this.edgeExceedsShortLineThreshold(a.leftEdge,t)){const i=Y(a.pos,r,t),s=Y(a.leftEdge.leftVertex.pos,r,t);this._checkForSnappingCandidate(n,s,i,e,o,t)}const d=i.vertices[0];if(this.edgeExceedsShortLineThreshold(d.rightEdge,t)){const i=Y(d.pos,r,t),s=Y(d.rightEdge.rightVertex.pos,r,t);this._checkForSnappingCandidate(n,s,i,e,o,t)}return n}snapExistingVertex(e,t){const i=[],s=r(t.vertexHandle);if(s.component.vertices.length<3)return i;const{view:n}=this,o=ce(e,t.spatialReference,y,n),a=s.leftEdge,d=s.rightEdge;if(a&&a.leftVertex.leftEdge){const s=a.leftVertex.leftEdge;if(this.edgeExceedsShortLineThreshold(s,t)){const r=Y(s.rightVertex.pos,n,t),a=Y(s.leftVertex.pos,n,t);this._checkForSnappingCandidate(i,a,r,e,o,t)}}if(d&&d.rightVertex.rightEdge){const s=d.rightVertex.rightEdge;if(this.edgeExceedsShortLineThreshold(s,t)){const r=Y(s.leftVertex.pos,n,t),a=Y(s.rightVertex.pos,n,t);this._checkForSnappingCandidate(i,a,r,e,o,t)}}return i}_checkForSnappingCandidate(e,t,i,s,n,r){const{spatialReference:o,pointer:a}=r;x(je,i,t);const d=q(Me,je[1],-je[0],0),c=T(d,x(je,s,i))/C(d),h=ie(P(j(s),i,d,c));if(ee(n,ce(h,o,y,this.view))<this.squaredProximityThreshold(a)){if(this.isVertical(h,i)||this.isVertical(i,t))return;const s=b(I(),i,d,Math.sign(c));e.push(new ye({targetPoint:h,constraint:new k(i,ie(s)),previousVertex:t,otherVertex:i,otherVertexType:me.CENTER,isDraped:"on-the-ground"===r.elevationInfo?.mode}))}}}const je=fe(),Me=I();class Oe extends G{constructor({targetPoint:e,point1:t,point2:i,isDraped:s}){super(e,new Q(ie(H(I(),t,i,.5)),.5*R(t,i)),s,_.SELF),this._p1=t,this._p2=i}get hints(){return[new v(J.REFERENCE,this.targetPoint,this._p1,this.isDraped,this.domain),new v(J.REFERENCE,this.targetPoint,this._p2,this.isDraped,this.domain),new oe(this._p1,this.targetPoint,this._p2,this.isDraped,this.domain)]}}class Ne extends Ce{snapNewVertex(e,t){const i=t.editGeometryOperations.data.components[0],s=[],n=i.vertices.length;if("polygon"!==t.editGeometryOperations.data.type||n<2)return s;const{view:r}=this,o=i.vertices[0],a=i.vertices[n-1],d=Y(o.pos,r,t),c=Y(a.pos,r,t);return this._processCandidateProposal(d,c,e,t,s),s}snapExistingVertex(e,t){const i=[],s=r(t.vertexHandle),n=s.component;if(n.edges.length<2)return i;if("polyline"===t.editGeometryOperations.data.type&&(0===s.index||s.index===n.vertices.length-1))return i;const{view:o}=this,a=Y(s.leftEdge.leftVertex.pos,o,t),d=Y(s.rightEdge.rightVertex.pos,o,t);return this._processCandidateProposal(a,d,e,t,i),i}_processCandidateProposal(e,t,i,s,n){if(!this.exceedsShortLineThreshold(e,t,s))return;const r=L(De,e,t,.5),o=.5*R(e,t),a=I();ge(a,i,r,o),a[2]=i[2];const d=ie(a),{spatialReference:c,pointer:h}=s,p=ce(i,c,y,this.view);if(ee(p,ce(d,c,y,this.view))<this.squaredProximityThreshold(h)){if(this.isVertical(e,d)||this.isVertical(d,t))return;n.push(new Oe({targetPoint:d,point1:e,point2:t,isDraped:"on-the-ground"===s.elevationInfo?.mode}))}}}const De=fe();let qe=class extends he{constructor(e){super(e),this.updating=!1,this._snappers=new pe,this._domain=_.SELF}initialize(){this._snappers.push(new Ve(this.view,this.options),new Re(this.view,this.options),new Ie(this.view,this.options),new Ne(this.view,this.options))}set options(e){this._set("options",e);for(const t of this._snappers)t.options=e}async fetchCandidates(e,t,i){if(!(t&this._domain&&this.options.effectiveSelfEnabled))return[];const s=[];for(const t of this._snappers.items)for(const n of t.snap(e,i))s.push(n);return K(e,s),s}};function be(e,t){return[new qe({view:e,options:t}),new _e({view:e,options:t,spatialReference:e.spatialReference})]}e([l({readOnly:!0})],qe.prototype,"updating",void 0),e([l({constructOnly:!0})],qe.prototype,"view",void 0),e([l()],qe.prototype,"options",null),qe=e([g("esri.views.interactive.snapping.SelfSnappingEngine")],qe);class He extends G{constructor(e,t,i,s){super(e,new B(e,t.constraint,i.constraint),s,_.ALL),this.first=t,this.second=i}get hints(){return this.first.targetPoint=this.targetPoint,this.second.targetPoint=this.targetPoint,[...this.first.hints,...this.second.hints,new de(this.targetPoint,this.isDraped,this.domain)]}}let Ae=class extends(t.EventedMixin(i)){constructor(e){super(e),this.options=new Se,this.snappingEnginesFactory=be,this._engines=[],this._currentMainCandidate=null,this._currentOtherActiveCandidates=[],this._currentSnappedType=ze.MAIN}initialize(){this.handles.add([h((()=>{const{effectiveFeatureEnabled:e,effectiveSelfEnabled:t,touchSensitivityMultiplier:i,distance:s}=this.options;return{effectiveFeatureEnabled:e,effectiveSelfEnabled:t,touchSensitivityMultiplier:i,distance:s}}),(()=>{this.doneSnapping(),this.emit("changed")}),c),h((()=>this.options),(e=>{for(const t of this._engines)t.options=e}),c),h((()=>({viewReady:this.view.ready,viewSpatialReference:this.view.spatialReference,snappingEnginesFactory:this.snappingEnginesFactory})),(({viewReady:e,snappingEnginesFactory:t})=>this._recreateEngines(e,t)),p)])}destroy(){this._destroyEngines()}get updating(){return this._engines.some((e=>e.updating))}_recreateEngines(e,t){if(this._destroyEngines(),!e)return;const{view:i,options:s}=this;this._engines=t(i,s)}_destroyEngines(){for(const e of this._engines)e.destroy();this._engines=[]}get _squaredMouseProximityTreshold(){return this.options.distance*this.options.distance}get _squaredTouchProximityThreshold(){const{distance:e,touchSensitivityMultiplier:t}=this.options,i=e*t;return i*i}get _squaredSatisfiesConstraintThreshold(){return m.satisfiesConstraintScreenThreshold*m.satisfiesConstraintScreenThreshold}async snap(e){return function(e){return s(e.scenePoint)}(e)?this._snapMultiPoint(e):this._snapSinglePoint(e)}update(e){const{point:t,context:i}=e;this._removeVisualization();const r=this._currentMainCandidate;if(n(r))return t;const o=this._selectUpdateInput(e);if(n(o))return t;const{spatialReference:a}=i,d=f(o,a);if(n(d))return t;const{view:c}=this,{elevationInfo:h,visualizer:p}=i,l=[],u=se(d,c,i),g=r.constraint.closestTo(u);if(!this._arePointsWithinScreenThreshold(u,g,i))return this._resetSnappingState(),t;r.targetPoint=g,l.push(...r.hints);for(const e of this._currentOtherActiveCandidates)e.targetPoint=g,l.push(...e.hints);return s(p)&&this.handles.add(p.draw(l,{spatialReference:a,elevationInfo:ke(i),view:c,selfSnappingZ:i.selfSnappingZ}),Ge),ne(g,c,{z:t.z,m:t.m,spatialReference:t.spatialReference,elevationInfo:h})}doneSnapping(){this._removeVisualization(),this._resetSnappingState()}_selectUpdateInput({point:e,scenePoint:t}){switch(this._currentSnappedType){case ze.MAIN:return e;case ze.SCENE:return t}}_resetSnappingState(){this._currentMainCandidate=null,this._currentOtherActiveCandidates=[],this._currentSnappedType=ze.MAIN}_removeVisualization(){this.handles.remove(Ge)}async _snapSinglePoint({point:e,context:t,signal:i}){const{view:s}=this,n=se(e,s,t),r=await this._fetchCandidates(n,_.ALL,t,i);return this._createSnapResult(n,ze.MAIN,r,s,t,{z:e.z,m:e.m,spatialReference:e.spatialReference,elevationInfo:t.elevationInfo},i)}async _snapMultiPoint({point:e,scenePoint:t,context:i,signal:s}){const{view:n}=this,{coordinateHelper:r,spatialReference:o}=i;await S(t.spatialReference,o);const a=f(t,o),d=se(a,n,i),c=await this._fetchCandidates(d,_.FEATURE,i,s);if(c.length>0){const e=await this._fetchCandidates(d,_.SELF,i,s);return this._createSnapResult(d,ze.SCENE,[...c,...e],n,i,{z:a.z,m:a.m,spatialReference:a.spatialReference,elevationInfo:i.elevationInfo},s)}const h=se(e,n,i),p=await this._fetchCandidates(h,_.SELF,i,s);return this._createSnapResult(h,ze.MAIN,p,n,i,{z:r.hasZ()&&e.hasZ?e.z??0:void 0,m:r.hasM()&&e.hasM?e.m??0:void 0,spatialReference:e.spatialReference,elevationInfo:i.elevationInfo},s)}async _fetchCandidates(e,t,i,s){return(await Promise.all(this._engines.map((n=>n.fetchCandidates(e,t,i,s))))).flat()}_createSnapResult(e,t,i,n,r,o,a){return{get valid(){return!d(a)},apply:()=>{const{spatialReference:a}=r,{snappedPoint:d,hints:c}=this._processCandidates(e,t,i,r);return this._removeVisualization(),s(r.visualizer)&&this.handles.add(r.visualizer.draw(c,{spatialReference:a,elevationInfo:y,view:n,selfSnappingZ:r.selfSnappingZ}),Ge),ne(d,n,o)}}}_processCandidates(e,t,i,n){if(i.length<1)return this.doneSnapping(),{snappedPoint:e,hints:[]};this._currentSnappedType!==t&&this._resetSnappingState(),K(e,i);const r=this._currentMainCandidate;if(s(r)){const s=this._findOldConstraintInNewCandidates(r,i);if(s>=0){if(!(i[s]instanceof He))return this._intersectWithOtherCandidates(s,i,e,t,n);if(this._arePointsWithinScreenThreshold(e,r.targetPoint,n))return this._updateSnappingCandidate(r,t,i,n)}}return this._intersectWithOtherCandidates(0,i,e,t,n)}_findOldConstraintInNewCandidates(e,t){return e instanceof He?this._findOldCandidateIndex(t,e.first)>=0&&this._findOldCandidateIndex(t,e.second)>=0?0:-1:this._findOldCandidateIndex(t,e)}_intersectWithOtherCandidates(e,t,i,s,n){const{coordinateHelper:r}=n,o=t[e],a=[];for(let s=0;s<t.length;++s){if(s===e)continue;const n=t[s];for(const e of o.constraint.intersect(n.constraint)){const t=e.closestTo(o.targetPoint);a.push([new He(t,o,n,n.isDraped),this._squaredScreenDistance(i,t,r)])}}return a.length>0&&(a.sort(((e,t)=>e[1]-t[1])),a[0][1]<this._squaredPointProximityThreshold(n.pointer))?this._updateSnappingCandidate(a[0][0],s,t,n):this._updateSnappingCandidate(o,s,t,n)}_updateSnappingCandidate(e,t,i,s){this.doneSnapping(),this._currentMainCandidate=e,this._currentSnappedType=t;const n=this._currentMainCandidate.targetPoint,r=[];r.push(...e.hints);for(const t of i){if(e instanceof He){if(t.constraint.equals(e.first.constraint)||t.constraint.equals(e.second.constraint))continue}else if(t.constraint.equals(e.constraint))continue;const i=t.constraint.closestTo(n);this._squaredScreenDistance(i,n,s.coordinateHelper)<this._squaredSatisfiesConstraintThreshold&&(t.targetPoint=n,this._currentOtherActiveCandidates.push(t),r.push(...t.hints))}return{snappedPoint:n,hints:r}}_squaredPointProximityThreshold(e){return"touch"===e?this._squaredTouchProximityThreshold:this._squaredMouseProximityTreshold}_arePointsWithinScreenThreshold(e,t,i){return this._squaredScreenDistance(e,t,i.coordinateHelper)<this._squaredPointProximityThreshold(i.pointer)}_squaredScreenDistance(e,t,i){return ee(this._toScreen(e,i),this._toScreen(t,i))}_toScreen(e,t){return ce(e,t.spatialReference,y,this.view)}_findOldCandidateIndex(e,t){let i=-1;for(let s=0;s<e.length;++s)if(t.constraint.equals(e[s].constraint)){i=s;break}return i}get test(){return{visualizationsActive:this.handles.has(Ge),engines:this._engines}}};var ze;e([l({constructOnly:!0})],Ae.prototype,"view",void 0),e([l()],Ae.prototype,"options",void 0),e([l({readOnly:!0})],Ae.prototype,"updating",null),e([l()],Ae.prototype,"snappingEnginesFactory",void 0),e([l()],Ae.prototype,"_engines",void 0),e([l()],Ae.prototype,"_squaredMouseProximityTreshold",null),e([l()],Ae.prototype,"_squaredTouchProximityThreshold",null),e([l()],Ae.prototype,"_squaredSatisfiesConstraintThreshold",null),Ae=e([g("esri.views.interactive.snapping.SnappingManager")],Ae),function(e){e[e.MAIN=0]="MAIN",e[e.SCENE=1]="SCENE"}(ze||(ze={}));const Ge="visualization-handle";function ke({coordinateHelper:e,elevationInfo:t}){return e.hasZ()?y:t}export{_e as F,Ae as S};
