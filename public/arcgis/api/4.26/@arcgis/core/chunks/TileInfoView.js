/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{h as t}from"./unitUtils.js";import{i as o}from"./maybe.js";import{T as e}from"./TileKey2.js";import{O as s}from"./ArrayPool.js";function l(t,o){return[t,o]}function i(t,o,e){return t[0]=o,t[1]=e,t}const r=new e("0/0/0/0");class n{static create(e,s,r=null){const a=t(e.spatialReference),h=s.origin||l(e.origin.x,e.origin.y),c=l(e.size[0]*s.resolution,e.size[1]*s.resolution),u=l(-1/0,-1/0),f=l(1/0,1/0),m=l(1/0,1/0);o(r)&&(i(u,Math.max(0,Math.floor((r.xmin-h[0])/c[0])),Math.max(0,Math.floor((h[1]-r.ymax)/c[1]))),i(f,Math.max(0,Math.floor((r.xmax-h[0])/c[0])),Math.max(0,Math.floor((h[1]-r.ymin)/c[1]))),i(m,f[0]-u[0]+1,f[1]-u[1]+1));const{cols:g,rows:d}=s;let w,y,M,F;return!r&&g&&d&&(i(u,g[0],d[0]),i(f,g[1],d[1]),i(m,g[1]-g[0]+1,d[1]-d[0]+1)),e.isWrappable?(w=l(Math.ceil(Math.round((a.valid[1]-a.valid[0])/s.resolution)/e.size[0]),m[1]),y=l(Math.floor((a.origin[0]-h[0])/c[0]),u[1]),M=l(w[0]+y[0]-1,f[1]),F=!0):(y=u,M=f,w=m,F=!1),new n(s.level,s.resolution,s.scale,h,u,f,m,c,y,M,w,F)}constructor(t,o,e,s,l,i,r,n,a,h,c,u){this.level=t,this.resolution=o,this.scale=e,this.origin=s,this.first=l,this.last=i,this.size=r,this.norm=n,this.worldStart=a,this.worldEnd=h,this.worldSize=c,this.wrap=u}normalizeCol(t){if(!this.wrap)return t;const o=this.worldSize[0];return t<0?o-1-Math.abs((t+1)%o):t%o}denormalizeCol(t,o){return this.wrap?this.worldSize[0]*o+t:t}getWorldForColumn(t){return this.wrap?Math.floor(t/this.worldSize[0]):0}getFirstColumnForWorld(t){return t*this.worldSize[0]+this.first[0]}getLastColumnForWorld(t){return t*this.worldSize[0]+this.first[0]+this.size[0]-1}getColumnForX(t){return(t-this.origin[0])/this.norm[0]}getXForColumn(t){return this.origin[0]+t*this.norm[0]}getRowForY(t){return(this.origin[1]-t)/this.norm[1]}getYForRow(t){return this.origin[1]-t*this.norm[1]}getTileBounds(t,o,e=!1){r.set(o);const s=e?r.col:this.denormalizeCol(r.col,r.world),l=r.row;return function(t,o,e,s,l){t[0]=o,t[1]=e,t[2]=s,t[3]=l}(t,this.getXForColumn(s),this.getYForRow(l+1),this.getXForColumn(s+1),this.getYForRow(l)),t}getTileCoords(t,o,e=!1){r.set(o);const s=e?r.col:this.denormalizeCol(r.col,r.world);return Array.isArray(t)?i(t,this.getXForColumn(s),this.getYForRow(r.row)):(t.x=this.getXForColumn(s),t.y=this.getYForRow(r.row)),t}}class a{constructor(){this.spans=[]}acquire(t){this.lodInfo=t}release(){this.lodInfo=null,this.spans.length=0}forEach(t,o){const{spans:e,lodInfo:s}=this,{level:l}=s;if(0!==e.length)for(const{row:i,colFrom:r,colTo:n}of e)for(let e=r;e<=n;e++)t.call(o,l,i,s.normalizeCol(e),s.getWorldForColumn(e))}}a.pool=new s(a);class h{constructor(t,o,e){this.row=t,this.colFrom=o,this.colTo=e}}const c=new e("0/0/0/0");class u{static create(t,o){t[1]>o[1]&&([t,o]=[o,t]);const[e,s]=t,[l,i]=o,r=l-e,n=i-s,a=0!==n?r/n:0,h=(Math.ceil(s)-s)*a,c=(Math.floor(s)-s)*a;return new u(e,Math.floor(s),Math.ceil(i),a,r<0?h:c,r<0?c:h,r<0?l:e,r<0?e:l)}constructor(t,o,e,s,l,i,r,n){this.x=t,this.ymin=o,this.ymax=e,this.invM=s,this.leftAdjust=l,this.rightAdjust=i,this.leftBound=r,this.rightBound=n}incrRow(){this.x+=this.invM}getLeftCol(){return Math.max(this.x+this.leftAdjust,this.leftBound)}getRightCol(){return Math.min(this.x+this.rightAdjust,this.rightBound)}}const f=[[0,0],[0,0],[0,0],[0,0]];class m{constructor(t,o=null){this.tileInfo=t,this.fullExtent=o,this.scales=[],this._infoByScale={},this._infoByLevel={};const e=t.lods.slice();e.sort(((t,o)=>o.scale-t.scale));const s=this._lodInfos=e.map((e=>n.create(t,e,o)));e.forEach(((t,o)=>{this._infoByLevel[t.level]=s[o],this._infoByScale[t.scale]=s[o],this.scales[o]=t.scale}),this),this._wrap=t.isWrappable}get spatialReference(){return this.tileInfo.spatialReference}getLODInfoAt(t){return this._infoByLevel["number"==typeof t?t:t.level]}getTileBounds(t,o,e=!1){c.set(o);const s=this._infoByLevel[c.level];return s?s.getTileBounds(t,c,e):t}getTileCoords(t,o,e=!1){c.set(o);const s=this._infoByLevel[c.level];return s?s.getTileCoords(t,c,e):t}getTileCoverage(t,o=192,e="closest"){const s="closest"===e?this.getClosestInfoForScale(t.scale):this.getSmallestInfoForScale(t.scale),l=a.pool.acquire(s),i=this._wrap;let r,n,c,m=1/0,g=-1/0;const d=l.spans;f[0][0]=f[0][1]=f[1][1]=f[3][0]=-o,f[1][0]=f[2][0]=t.size[0]+o,f[2][1]=f[3][1]=t.size[1]+o;for(const o of f)t.toMap(o,o),o[0]=s.getColumnForX(o[0]),o[1]=s.getRowForY(o[1]);const w=[];let y=3;for(let t=0;t<4;t++){if(f[t][1]===f[y][1]){y=t;continue}const o=u.create(f[t],f[y]);m=Math.min(o.ymin,m),g=Math.max(o.ymax,g),void 0===w[o.ymin]&&(w[o.ymin]=[]),w[o.ymin].push(o),y=t}if(null==m||null==g||g-m>100)return null;let M=[];for(r=m;r<g;){null!=w[r]&&(M=M.concat(w[r])),n=1/0,c=-1/0;for(let t=M.length-1;t>=0;t--){const o=M[t];n=Math.min(n,o.getLeftCol()),c=Math.max(c,o.getRightCol())}if(n=Math.floor(n),c=Math.floor(c),r>=s.first[1]&&r<=s.last[1])if(i)if(s.size[0]<s.worldSize[0]){const t=Math.floor(c/s.worldSize[0]);for(let o=Math.floor(n/s.worldSize[0]);o<=t;o++)d.push(new h(r,Math.max(s.getFirstColumnForWorld(o),n),Math.min(s.getLastColumnForWorld(o),c)))}else d.push(new h(r,n,c));else n>s.last[0]||c<s.first[0]||(n=Math.max(n,s.first[0]),c=Math.min(c,s.last[0]),d.push(new h(r,n,c)));r+=1;for(let t=M.length-1;t>=0;t--){const o=M[t];o.ymax>=r?o.incrRow():M.splice(t,1)}}return l}getTileParentId(t){c.set(t);const o=this._infoByLevel[c.level],e=this._lodInfos.indexOf(o)-1;return e<0?null:(this._getTileIdAtLOD(c,this._lodInfos[e],c),c.id)}getTileResolution(t){const o=this._infoByLevel["object"==typeof t?t.level:t];return o?o.resolution:-1}getTileScale(t){const o=this._infoByLevel[t.level];return o?o.scale:-1}intersects(t,o){c.set(o);const e=this._infoByLevel[c.level],s=t.lodInfo;if(s.resolution>e.resolution){this._getTileIdAtLOD(c,s,c);const o=s.denormalizeCol(c.col,c.world);for(const e of t.spans)if(e.row===c.row&&e.colFrom<=o&&e.colTo>=o)return!0}if(s.resolution<e.resolution){const[o,l,i,r]=t.spans.reduce(((t,o)=>(t[0]=Math.min(t[0],o.row),t[1]=Math.max(t[1],o.row),t[2]=Math.min(t[2],o.colFrom),t[3]=Math.max(t[3],o.colTo),t)),[1/0,-1/0,1/0,-1/0]),n=e.denormalizeCol(c.col,c.world),a=s.getColumnForX(e.getXForColumn(n)),h=s.getRowForY(e.getYForRow(c.row)),u=s.getColumnForX(e.getXForColumn(n+1))-1,f=s.getRowForY(e.getYForRow(c.row+1))-1;return!(a>r||u<i||h>l||f<o)}const l=s.denormalizeCol(c.col,c.world);return t.spans.some((t=>t.row===c.row&&t.colFrom<=l&&t.colTo>=l))}normalizeBounds(o,e,s){if(o[0]=e[0],o[1]=e[1],o[2]=e[2],o[3]=e[3],this._wrap){const e=t(this.tileInfo.spatialReference),l=-s*(e.valid[1]-e.valid[0]);o[0]+=l,o[2]+=l}return o}getSmallestInfoForScale(t){const o=this.scales;if(this._infoByScale[t])return this._infoByScale[t];if(t>o[0])return this._infoByScale[o[0]];for(let e=1;e<o.length-1;e++)if(t>o[e]+1e-6)return this._infoByScale[o[e-1]];return this._infoByScale[o[o.length-1]]}getClosestInfoForScale(t){const o=this.scales;return this._infoByScale[t]||(t=o.reduce(((o,e)=>Math.abs(e-t)<Math.abs(o-t)?e:o),o[0])),this._infoByScale[t]}scaleToLevel(t){const o=this.scales;if(this._infoByScale[t])return this._infoByScale[t].level;for(let e=o.length-1;e>=0;e--)if(t<o[e])return e===o.length-1?this._infoByScale[o[o.length-1]].level:this._infoByScale[o[e]].level+(o[e]-t)/(o[e]-o[e+1]);return this._infoByScale[o[0]].level}scaleToZoom(t){return this.tileInfo.scaleToZoom(t)}_getTileIdAtLOD(t,o,e){const s=this._infoByLevel[e.level];return t.set(e),o.resolution<s.resolution?null:(o.resolution===s.resolution||(t.level=o.level,t.col=Math.floor(e.col*s.resolution/o.resolution+.01),t.row=Math.floor(e.row*s.resolution/o.resolution+.01)),t)}}export{m as T,a};
