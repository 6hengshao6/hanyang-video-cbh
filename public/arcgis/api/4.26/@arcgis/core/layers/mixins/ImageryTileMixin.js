/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{_ as t}from"../../chunks/tslib.es6.js";import"../../geometry.js";import{rasterRendererTypes as e}from"../../rasterRenderers.js";import s from"../../request.js";import i from"../../core/Error.js";import{L as r}from"../../chunks/Logger.js";import{i as o,a as n,u as a,c as l}from"../../chunks/maybe.js";import{property as m}from"../../core/accessorSupport/decorators/property.js";import{m as c}from"../../chunks/ensureType.js";import"../../chunks/typedArrayUtil.js";import{subclass as p}from"../../core/accessorSupport/decorators/subclass.js";import{h as u}from"../../chunks/unitUtils.js";import{s as h}from"../../chunks/arcgisLayerUrl.js";import{u as d}from"../../chunks/commonProperties2.js";import f from"../support/DimensionalDefinition.js";import y from"../support/MultidimensionalSubset.js";import g from"../support/RasterFunction.js";import{R as x}from"../../chunks/RasterJobHandler.js";import j from"../support/TileInfo.js";import{JSONSupport as b}from"../../core/JSONSupport.js";import{EsriPromiseMixin as k}from"../../core/Promise.js";import{onAbort as I}from"../../core/promiseUtils.js";import S from"../support/LOD.js";import{R}from"../support/RasterInfo.js";import{b as w,c as v,d as T,e as _,a as F,h as D,f as C,g as P}from"../../chunks/multidimensionalUtils.js";import{g as M,a as J,p as H,d as B,b as z}from"../../chunks/RawBlockCache.js";import{c as U}from"../../chunks/pixelRangeUtils.js";import{d as O,R as L}from"../../chunks/RasterSymbolizer.js";import{m as E,j as V,k as W,n as N,u as A,d as q}from"../../chunks/vectorFieldUtils.js";import{l as G,g as $,p as Q,s as K,a as X,b as Y,c as Z,d as tt,e as et,f as st}from"../../chunks/rasterProjectionHelper.js";import it from"../../geometry/Extent.js";import rt from"../../geometry/Point.js";import{c as ot}from"../../chunks/rasterFunctionHelper.js";import{n as nt,b as at,d as lt,a as mt,c as ct}from"../../chunks/rasterRendererHelper.js";import{c as pt}from"../../chunks/dataUtils.js";import ut from"../../geometry/SpatialReference.js";import"../../geometry/Geometry.js";import"../../chunks/reader.js";import"../../core/Accessor.js";import"../../core/Handles.js";import"../../chunks/get.js";import"../../chunks/utils.js";import"../../chunks/handleUtils.js";import"../../core/lang.js";import"../../chunks/metadata.js";import"../../chunks/ArrayPool.js";import"../../chunks/tracking.js";import"../../chunks/watch.js";import"../../core/scheduling.js";import"../../chunks/nextTick.js";import"../../config.js";import"../../chunks/object.js";import"../../chunks/string.js";import"../../chunks/jsonMap.js";import"../../chunks/Ellipsoid.js";import"../../chunks/writer.js";import"../../geometry/Multipoint.js";import"../../chunks/zmUtils.js";import"../../geometry/support/webMercatorUtils.js";import"../../core/accessorSupport/decorators/cast.js";import"../../geometry/Polygon.js";import"../../chunks/extentUtils.js";import"../../chunks/aaBoundingRect.js";import"../../chunks/mathUtils.js";import"../../chunks/vec3.js";import"../../chunks/common.js";import"../../chunks/vec4.js";import"../../geometry/Polyline.js";import"../../chunks/typeUtils.js";import"../../geometry/support/jsonUtils.js";import"../../renderers/ClassBreaksRenderer.js";import"../../symbols.js";import"../../symbols/CIMSymbol.js";import"../../chunks/enumeration.js";import"../support/fieldUtils.js";import"../../chunks/arcadeOnDemand.js";import"../../symbols/Symbol.js";import"../../Color.js";import"../../chunks/colorUtils.js";import"../../symbols/ExtrudeSymbol3DLayer.js";import"../../symbols/Symbol3DLayer.js";import"../../chunks/utils2.js";import"../../symbols/edges/Edges3D.js";import"../../chunks/screenUtils.js";import"../../chunks/materialUtils.js";import"../../chunks/opacityUtils.js";import"../../symbols/edges/SketchEdges3D.js";import"../../symbols/edges/SolidEdges3D.js";import"../../chunks/Symbol3DMaterial.js";import"../../symbols/FillSymbol.js";import"../../symbols/SimpleLineSymbol.js";import"../../symbols/LineSymbol.js";import"../../symbols/LineSymbolMarker.js";import"../../chunks/lineMarkers.js";import"../../symbols/FillSymbol3DLayer.js";import"../../symbols/patterns/LineStylePattern3D.js";import"../../symbols/patterns/StylePattern3D.js";import"../../chunks/utils3.js";import"../../chunks/colors.js";import"../../chunks/symbolLayerUtils3D.js";import"../../chunks/aaBoundingBox.js";import"../../symbols/Font.js";import"../../symbols/IconSymbol3DLayer.js";import"../../core/urlUtils.js";import"../../chunks/persistableUrlUtils.js";import"../../chunks/Symbol3DAnchorPosition2D.js";import"../../symbols/LabelSymbol3D.js";import"../../core/Collection.js";import"../../core/Evented.js";import"../../chunks/shared.js";import"../../chunks/SimpleObservable.js";import"../../symbols/Symbol3D.js";import"../../chunks/collectionUtils.js";import"../../portal/Portal.js";import"../../kernel.js";import"../../core/Loadable.js";import"../../chunks/locale.js";import"../../portal/PortalQueryParams.js";import"../../portal/PortalQueryResult.js";import"../../portal/PortalUser.js";import"../../portal/PortalFolder.js";import"../../portal/PortalGroup.js";import"../../symbols/LineSymbol3DLayer.js";import"../../symbols/LineStyleMarker3D.js";import"../../core/Clonable.js";import"../../symbols/ObjectSymbol3DLayer.js";import"../../symbols/PathSymbol3DLayer.js";import"../../symbols/TextSymbol3DLayer.js";import"../../symbols/WaterSymbol3DLayer.js";import"../../symbols/support/StyleOrigin.js";import"../../chunks/Thumbnail.js";import"../../chunks/calloutUtils.js";import"../../symbols/callouts/Callout3D.js";import"../../symbols/callouts/LineCallout3D.js";import"../../symbols/support/Symbol3DVerticalOffset.js";import"../../symbols/LineSymbol3D.js";import"../../symbols/MarkerSymbol.js";import"../../symbols/MeshSymbol3D.js";import"../../symbols/PictureFillSymbol.js";import"../../chunks/urlUtils.js";import"../../symbols/PictureMarkerSymbol.js";import"../../symbols/PointSymbol3D.js";import"../../symbols/PolygonSymbol3D.js";import"../../symbols/SimpleFillSymbol.js";import"../../symbols/SimpleMarkerSymbol.js";import"../../symbols/TextSymbol.js";import"../../symbols/WebStyleSymbol.js";import"../../renderers/Renderer.js";import"../../renderers/support/AuthoringInfo.js";import"../../renderers/support/AuthoringInfoVisualVariable.js";import"../../chunks/colorRamps.js";import"../../rest/support/AlgorithmicColorRamp.js";import"../../rest/support/ColorRamp.js";import"../../rest/support/MultipartColorRamp.js";import"../../renderers/mixins/VisualVariablesMixin.js";import"../../renderers/visualVariables/ColorVariable.js";import"../../renderers/visualVariables/VisualVariable.js";import"../../chunks/LegendOptions.js";import"../../renderers/visualVariables/support/ColorStop.js";import"../../renderers/visualVariables/OpacityVariable.js";import"../../renderers/visualVariables/support/OpacityStop.js";import"../../renderers/visualVariables/RotationVariable.js";import"../../renderers/visualVariables/SizeVariable.js";import"../../renderers/visualVariables/support/SizeStop.js";import"../../chunks/sizeVariableUtils.js";import"../../chunks/visualVariableUtils.js";import"../../Graphic.js";import"../../PopupTemplate.js";import"../../popup/content.js";import"../../popup/content/AttachmentsContent.js";import"../../popup/content/Content.js";import"../../popup/content/CustomContent.js";import"../../popup/content/ExpressionContent.js";import"../../popup/ElementExpressionInfo.js";import"../../popup/content/FieldsContent.js";import"../../popup/FieldInfo.js";import"../../popup/support/FieldInfoFormat.js";import"../../chunks/date.js";import"../../chunks/number.js";import"../../popup/content/MediaContent.js";import"../../popup/content/BarChartMediaInfo.js";import"../../popup/content/mixins/ChartMediaInfo.js";import"../../popup/content/mixins/MediaInfo.js";import"../../popup/content/support/ChartMediaInfoValue.js";import"../../popup/content/support/ChartMediaInfoValueSeries.js";import"../../chunks/chartMediaInfoUtils.js";import"../../popup/content/ColumnChartMediaInfo.js";import"../../popup/content/ImageMediaInfo.js";import"../../popup/content/support/ImageMediaInfoValue.js";import"../../popup/content/LineChartMediaInfo.js";import"../../popup/content/PieChartMediaInfo.js";import"../../popup/content/RelationshipContent.js";import"../../popup/support/RelatedRecordsInfoFieldOrder.js";import"../../popup/content/TextContent.js";import"../../popup/ExpressionInfo.js";import"../../popup/LayerOptions.js";import"../../popup/RelatedRecordsInfo.js";import"../../support/actions/ActionBase.js";import"../../core/Identifiable.js";import"../../support/actions/ActionButton.js";import"../../support/actions/ActionToggle.js";import"../../chunks/compilerUtils.js";import"../../chunks/lengthUtils.js";import"../../renderers/support/ClassBreakInfo.js";import"../../chunks/commonProperties.js";import"../../symbols/support/jsonUtils.js";import"../../chunks/layerUtils.js";import"../../renderers/FlowRenderer.js";import"../../renderers/RasterColormapRenderer.js";import"../../renderers/support/ColormapInfo.js";import"../../chunks/colorRampUtils.js";import"../../chunks/colorUtils2.js";import"../../renderers/RasterShadedReliefRenderer.js";import"../../renderers/RasterStretchRenderer.js";import"../../chunks/stretchRendererUtils.js";import"../../renderers/UniqueValueRenderer.js";import"../../core/reactiveUtils.js";import"../../chunks/diffUtils.js";import"../../renderers/support/UniqueValue.js";import"../../renderers/support/UniqueValueClass.js";import"../../renderers/support/UniqueValueGroup.js";import"../../renderers/support/UniqueValueInfo.js";import"../../chunks/styleUtils.js";import"../../renderers/VectorFieldRenderer.js";import"../../geometry/support/normalizeUtils.js";import"../../chunks/normalizeUtilsCommon.js";import"../../chunks/simplify.js";import"../../chunks/utils4.js";import"../../chunks/utils5.js";import"../../chunks/utils6.js";import"../../chunks/asyncUtils.js";import"../../chunks/jsonUtils.js";import"../../chunks/parser.js";import"../../chunks/mat4f32.js";import"../../chunks/mat4.js";import"../../chunks/_commonjsHelpers.js";import"../../chunks/assets.js";import"../../chunks/ItemCache.js";import"../../chunks/MemCache.js";import"../../symbols/support/cimSymbolUtils.js";import"../../chunks/utils7.js";import"../support/PixelBlock.js";import"../../TimeExtent.js";import"../../chunks/timeUtils.js";import"../../support/timeUtils.js";import"../../chunks/ElevationInfo.js";import"../../chunks/unitConversionUtils.js";import"../../core/workers/workers.js";import"../../core/workers/Connection.js";import"../../chunks/Queue.js";import"../../core/workers/RemoteClient.js";import"../../intl.js";import"../../chunks/messages.js";import"../../chunks/TileKey.js";import"../../chunks/stretchUtils.js";import"../../chunks/pe.js";import"../../geometry/projection.js";import"../../chunks/geodesicConstants.js";import"../../geometry/support/GeographicTransformation.js";import"../../geometry/support/GeographicTransformationStep.js";import"../../chunks/zscale.js";import"../support/rasterFunctionConstants.js";import"../support/Field.js";import"../../chunks/domains.js";import"../support/CodedValueDomain.js";import"../support/Domain.js";import"../support/InheritedDomain.js";import"../support/RangeDomain.js";import"../../chunks/fieldType.js";import"../../chunks/generateRendererUtils.js";let ht=class extends(k(b)){constructor(){super(...arguments),this.rasterJobHandler=null,this.datasetName=null,this.datasetFormat=null,this.hasUniqueSourceStorageInfo=!0,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}async init(){const t=G();this.addResolvingPromise(t),await this.when()}normalizeCtorArgs(t){return t&&t.ioConfig&&(t={...t,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:j.create(),...t.ioConfig}}),t}get _isGlobalWrappableSource(){const{rasterInfo:t}=this,e=$(t.spatialReference);return o(e)&&t.extent.width>=e/2}get _hasNoneOrGCSShiftTransform(){const{transform:t}=this.rasterInfo;return n(t)||"gcs-shift"===t.type}set url(t){this._set("url",h(t,r.getLogger(this.declaredClass)))}async open(t){throw new i("BaseRaster:open-not-implemented","open() is not implemented")}async fetchTile(t,e,s,i={}){const r=i.tileInfo||this.rasterInfo.storageInfo.tileInfo,o=this.getTileExtentFromTileInfo(t,e,s,r);return this.fetchPixels(o,r.size[0],r.size[1],i)}async identify(t,e={}){t=c(rt,t).clone().normalize();const{multidimensionalDefinition:s,timeExtent:i}=e,{rasterInfo:r}=this,{hasMultidimensionalTranspose:l,multidimensionalInfo:m}=r;let{transposedVariableName:p}=e;const u=o(m)&&l&&(null!=i||w(s));u&&!p&&(p=o(s)&&s.length>0?s[0].variableName??void 0:m.variables[0].name,e={...e,transposedVariableName:p}),e=this._getRequestOptionsWithSliceId(e);const{spatialReference:h,extent:d}=r,{datumTransformation:f}=e;let y=Q(t,h,f);if(!d.intersects(y))return{location:y,value:null};if(o(r.transform)){const t=r.transform.inverseTransform(y);if(!r.nativeExtent.intersects(t))return{location:t,value:null};y=t}let g=0;const x=o(p)&&o(m)&&r.hasMultidimensionalTranspose;if("Function"===this.datasetFormat){const t=this.primaryRasters.rasters[0];if(x)return t.identify(y,e);const{pixelSize:s}=r,i=3,a=s.x*i/2,l=s.y*i/2,m=new it({xmin:y.x-a,xmax:y.x+a,ymin:y.y-l,ymax:y.y+l,spatialReference:h}),c={interpolation:"nearest"},{pixelBlock:p}=await t.fetchPixels(m,i,i,c),{pixelBlock:u}=await this.fetchPixels(m,i,i,c);if(n(p))return{location:y,value:null};const d=Math.floor(i*i*.5),f=!p.mask||p.mask[d]?p.pixels.map((t=>t[d])):null;let g;return o(u)&&(g=!u.mask||u.mask[d]?u.pixels.map((t=>t[d])):void 0),{location:y,value:f,processedValue:g,pyramidLevel:0}}if(!x)if(e.srcResolution)g=K(e.srcResolution,r,this.ioConfig.sampling).pyramidLevel;else if(g=await this.computeBestPyramidLevelForLocation(t,e),null==g)return{location:y,value:null};const j=this.identifyPixelLocation(y,g,null,x);if(null===j)return{location:y,value:null};const{row:b,col:k,rowOffset:I,colOffset:S,blockWidth:R}=j,v=p??a(e.sliceId),T=M(this.url,v),_=`${g}/${b}/${k}`;let F=J(T,null,_);n(F)&&(F=this.fetchRawTile(g,b,k,e),H(T,null,_,F));const D=await F;if(n(D)||!D.pixels?.length)return{location:y,value:null};const C=I*R+S;return this._processIdentifyResult(D,{srcLocation:y,position:C,pyramidLevel:g,useTransposedTile:!!x,requestSomeSlices:u,identifyOptions:e})}async fetchPixels(t,e,s,i={}){t=X(t),i=this._getRequestOptionsWithSliceId(i);const{_hasNoneOrGCSShiftTransform:r}=this;if(i.requestRawData&&r)return this._fetchPixels(t,e,s,i);const o=$(t.spatialReference),a=Y(t);if(n(o)||0===a||1===a&&this._isGlobalWrappableSource&&r)return this._fetchPixels(t,e,s,i);if(a>=3)return{extent:t,pixelBlock:null};const l=[],{xmin:m,xmax:c}=t,p=Math.round(o/(c-m)*e),u=p-Math.round((o/2-m)/(c-m)*e);let h=0;const d=[];for(let r=0;r<=a;r++){const n=new it({xmin:0===r?m:-o/2,xmax:r===a?c-o*r:o/2,ymin:t.ymin,ymax:t.ymax,spatialReference:t.spatialReference}),f=0===r?p-u:r===a?e-h:p;h+=f,d.push(f);const y=i.disableWrapAround&&r>0?null:this._fetchPixels(n,f,s,i);l.push(y)}const f=(await Promise.all(l)).map((t=>t?.pixelBlock));let y=null;const g={width:e,height:s};return y=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:f,srcMosaicSize:g,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:d},i)).pixelBlock:E(f,g,{blockWidths:d}),{extent:t,srcExtent:Z(t,this.rasterInfo.spatialReference,i.datumTransformation),pixelBlock:y}}async fetchRawPixels(t,e,s,i={}){e={x:Math.floor(e.x),y:Math.floor(e.y)};const r=await this._fetchRawTiles(t,e,s,i),{nativeExtent:n,nativePixelSize:a,storageInfo:l}=this.rasterInfo,m=2**t,c=a.x*m,p=a.y*m,u=new it({xmin:n.xmin+c*e.x,xmax:n.xmin+c*(e.x+s.width-1),ymin:n.ymax-p*(e.y+s.height-1),ymax:n.ymax-p*e.y,spatialReference:n.spatialReference});if(!r)return{extent:u,srcExtent:u,pixelBlock:null};const{pixelBlocks:h,mosaicSize:d}=r;if(1===h.length&&o(h[0])&&h[0].width===s.width&&h[0].height===s.height)return{extent:u,srcExtent:u,pixelBlock:r.pixelBlocks[0]};const f=t>0?l.pyramidBlockWidth:l.blockWidth,y=t>0?l.pyramidBlockHeight:l.blockHeight,g={x:e.x%f,y:e.y%y};let x;return x=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:h,srcMosaicSize:d,destDimension:s,clipOffset:g,clipSize:s,coefs:null,sampleSpacing:null,interpolation:i.interpolation,alignmentInfo:null,blockWidths:null},i)).pixelBlock:E(h,d,{clipOffset:g,clipSize:s}),{extent:u,srcExtent:u,pixelBlock:x}}fetchRawTile(t,e,s,r){throw new i("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(t){return Z(this.rasterInfo.extent,t)}decodePixelBlock(t,e){return!this.rasterJobHandler||e.useCanvas?O(t,e):this.rasterJobHandler.decode({data:t,options:e})}async request(t,e,i=0){const{customFetchParameters:r}=this.ioConfig,{range:o,query:n,headers:a}=e;i=i??e.retryCount??this.ioConfig.retryCount;const l=o?{Range:`bytes=${o.from}-${o.to}`}:null;try{return await s(t,{...e,query:{...n,...r},headers:{...a,...l}})}catch(s){if(i>0)return i--,this.request(t,e,i);throw s}}getSliceIndex(t){const{multidimensionalInfo:e}=this.rasterInfo;return n(e)||n(t)||0===t.length?null:v(t,e)}getTileExtentFromTileInfo(t,e,s,i){const r=l(i.lodAt(t));return this.getTileExtent({x:r.resolution,y:r.resolution},e,s,i.origin,i.spatialReference,i.size)}updateTileInfo(){const{storageInfo:t,spatialReference:e,extent:s,pixelSize:i}=this.rasterInfo;if(!t.tileInfo){const r=[],o=t.maximumPyramidLevel||0;let n=Math.max(i.x,i.y),a=1/.0254*96*n;for(let t=0;t<=o;t++)r.push(new S({level:o-t,resolution:n,scale:a})),n*=2,a*=2;const l=new rt({x:s.xmin,y:s.ymax,spatialReference:e});t.tileInfo=new j({origin:l,size:[t.blockWidth,t.blockHeight],spatialReference:e,lods:r}),t.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(t,e=512,s=512,i){const{width:r,height:o,nativeExtent:n,pixelSize:a,spatialReference:l}=t,m=new rt({x:n.xmin,y:n.ymax,spatialReference:l});null==i&&(i=Math.max(0,Math.round(Math.log(Math.max(r,o))/Math.LN2-8)));const c=this.computeBlockBoundary(n,512,512,{x:n.xmin,y:n.ymax},[a],i);t.storageInfo=new R({blockWidth:e,blockHeight:s,pyramidBlockWidth:e,pyramidBlockHeight:s,origin:m,firstPyramidLevel:1,maximumPyramidLevel:i,blockBoundary:c})}async computeBestPyramidLevelForLocation(t,e={}){return 0}computeBlockBoundary(t,e,s,i,r,o=0,n=2){if(1===r.length&&o>0){r=[...r];let{x:t,y:e}=r[0];for(let s=0;s<o;s++)t*=n,e*=n,r.push({x:t,y:e})}const a=[],{x:l,y:m}=i;for(let i=0;i<r.length;i++){const{x:o,y:n}=r[i];a.push({minCol:Math.floor((t.xmin-l+.1*o)/e/o),maxCol:Math.floor((t.xmax-l-.1*o)/e/o),minRow:Math.floor((m-t.ymax+.1*n)/s/n),maxRow:Math.floor((m-t.ymin-.1*n)/s/n)})}return a}getPyramidPixelSize(t){const{nativePixelSize:e}=this.rasterInfo,{pyramidResolutions:s,pyramidScalingFactor:i}=this.rasterInfo.storageInfo;if(0===t)return e;if(o(s)&&s.length)return s[t-1];const r=i**t;return{x:e.x*r,y:e.y*r}}identifyPixelLocation(t,e,s,i){const{spatialReference:r,nativeExtent:n,storageInfo:a}=this.rasterInfo,{maximumPyramidLevel:l,origin:m,transposeInfo:c}=a,p=i&&o(c)?c.tileSize[0]:a.blockWidth,u=i&&o(c)?c.tileSize[1]:a.blockHeight,h=Q(t,r,s);if(!n.intersects(h))return null;if(e<0||e>l)return null;const d=this.getPyramidPixelSize(e),{x:f,y}=d,g=(m.y-h.y)/y/u,x=(h.x-m.x)/f/p,j=Math.min(u-1,Math.floor((g-Math.floor(g))*u)),b=Math.min(p-1,Math.floor((x-Math.floor(x))*p));return{pyramidLevel:e,row:Math.floor(g),col:Math.floor(x),rowOffset:j,colOffset:b,blockWidth:p,srcLocation:h}}getTileExtent(t,e,s,i,r,o){const[n,a]=o,l=i.x+s*n*t.x,m=l+n*t.x,c=i.y-e*a*t.y,p=c-a*t.y;return new it({xmin:l,xmax:m,ymin:p,ymax:c,spatialReference:r})}getBlockWidthHeight(t){return{blockWidth:t>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:t>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(t,e,s){const i=this.rasterInfo.storageInfo.blockBoundary[t];return!i||i.maxRow<e||i.maxCol<s||i.minRow>e||i.minCol>s}async _fetchPixels(t,e,s,i={}){let r=Y(t);if(r>=2)return{extent:t,pixelBlock:null};const n=this._getSourceDataInfo(t,e,s,i),{pyramidLevel:l,srcResolution:m,srcExtent:c,srcWidth:p,srcHeight:u,ul:h}=n;if(0===p||0===u)return{extent:t,srcExtent:c,pixelBlock:null};const{rasterInfo:d}=this,f=a(d.transform),y="gcs-shift"===f?.type,g=o($(t.spatialReference));!y&&g||(r=Y(n.srcExtent,y));const x=await this._fetchRawTiles(l,h,{width:p,height:u,wrapCount:r},i);if(!x)return{extent:t,srcExtent:c,pixelBlock:null};const j=d.storageInfo,b=l>0?j.pyramidBlockWidth:j.blockWidth,k=l>0?j.pyramidBlockHeight:j.blockHeight;let{x:I,y:S}=d.pixelSize;if(l>0){const{pyramidResolutions:t,pyramidScalingFactor:e}=j;if(o(t)&&t[l-1])({x:I,y:S}=t[l-1]);else{const t=e**l;I*=t,S*=t}}const R=new rt({x:I,y:S,spatialReference:d.spatialReference}),w=b===p&&k===u&&h.x%b==0&&h.y%k==0,v=new rt({x:(t.xmax-t.xmin)/e,y:(t.ymax-t.ymin)/s,spatialReference:t.spatialReference}),T=!t.spatialReference.equals(this.rasterInfo.spatialReference),{datumTransformation:_}=i;if(!T&&w&&1===x.pixelBlocks.length&&b===e&&k===s&&m.x===v.x&&m.y===v.y)return{extent:t,srcExtent:c,srcTilePixelSize:R,pixelBlock:x.pixelBlocks[0]};const F=g&&o($(c.spatialReference))&&this._hasNoneOrGCSShiftTransform,D=i.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");D&&!this.rasterJobHandler&&await G();const C=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:t,srcBufferExtent:x.extent,pixelSize:v.toJSON(),datumTransformation:_,rasterTransform:f,hasWrapAround:r>0||F,isAdaptive:!1!==this.ioConfig.optimizeProjectionAccuracy,includeGCSGrid:D},i):tt({projectedExtent:t,srcBufferExtent:x.extent,pixelSize:v,datumTransformation:_,rasterTransform:f,hasWrapAround:r>0||F,isAdaptive:!1,includeGCSGrid:D});let P;const M=!i.requestRawData,J={rows:C.spacing[0],cols:C.spacing[1]},H=this._hasNoneOrGCSShiftTransform?a(this._getRasterTileAlignmentInfo(l,x.extent.xmin)):void 0,{pixelBlocks:B,mosaicSize:z,isPartiallyFilled:U}=x;let O=null;if(this.rasterJobHandler){const t=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:B,srcMosaicSize:z,destDimension:M?{width:e,height:s}:null,coefs:M?C.coefficients:null,sampleSpacing:M?J:null,projectDirections:D,gcsGrid:D?C.gcsGrid:null,isUV:"vector-uv"===this.rasterInfo.dataType,interpolation:i.interpolation,alignmentInfo:H,blockWidths:null},i);({pixelBlock:P,localNorthDirections:O}=t)}else{const t=E(B,z,{alignmentInfo:H});P=M?V(t,{width:e,height:s},C.coefficients,J,i.interpolation):t,D&&C.gcsGrid&&(O=W({width:e,height:s},C.gcsGrid),P=N(P,this.rasterInfo.dataType,O))}return i.requestRawData||D?{extent:t,srcExtent:c,srcTilePixelSize:R,pixelBlock:P,transformGrid:C,localNorthDirections:O,isPartiallyFilled:U}:{extent:t,srcExtent:c,srcTilePixelSize:R,pixelBlock:P}}async _fetchRawTiles(t,e,s,i){const{origin:r,blockBoundary:n}=this.rasterInfo.storageInfo,{blockWidth:a,blockHeight:l}=this.getBlockWidthHeight(t);let{x:m,y:c}=e,{width:p,height:u,wrapCount:h}=s;const d=this._getRasterTileAlignmentInfo(t,0);i.buffer&&(m-=i.buffer.cols,c-=i.buffer.rows,p+=2*i.buffer.cols,u+=2*i.buffer.rows);let f=0,y=0,g=0;h&&o(d)&&(({worldColumnCountFromOrigin:y,originColumnOffset:g,rightPadding:f}=d),y*d.blockWidth-f>=m+p&&(f=0));const x=Math.floor(m/a),j=Math.floor(c/l),b=Math.floor((m+p+f-1)/a),k=Math.floor((c+u+f-1)/l),I=n[t];if(!I)return null;const{minRow:S,minCol:R,maxCol:w,maxRow:v}=I;if(0===h&&(k<S||b<R||j>v||x>w))return null;const T=new Array;let _=!1;const F=null==this.ioConfig.allowPartialFill?i.allowPartialFill:this.ioConfig.allowPartialFill;for(let e=j;e<=k;e++)for(let s=x;s<=b;s++){let r=s;if(!i.disableWrapAround&&h&&o(d)&&y<=s&&(r=s-y-g),e>=S&&r>=R&&v>=e&&w>=r){const s=this._fetchRawTile(t,e,r,i);F?T.push(new Promise((t=>{s.then((e=>t(e))).catch((()=>{_=!0,t(null)}))}))):T.push(s)}else T.push(Promise.resolve(null))}if(0===T.length)return null;const D=await Promise.all(T),C={height:(k-j+1)*l,width:(b-x+1)*a},{spatialReference:P}=this.rasterInfo,M=this.getPyramidPixelSize(t),{x:J,y:H}=M;return{extent:new it({xmin:r.x+x*a*J,xmax:r.x+(b+1)*a*J,ymin:r.y-(k+1)*l*H,ymax:r.y-j*l*H,spatialReference:P}),pixelBlocks:D,mosaicSize:C,isPartiallyFilled:_}}_fetchRawTile(t,e,s,i){const r=this.rasterInfo.storageInfo.blockBoundary[t];if(!r)return Promise.resolve(null);const{minRow:o,minCol:a,maxCol:l,maxRow:m}=r;if(e<o||s<a||e>m||s>l)return Promise.resolve(null);const c=M(this.url,i.sliceId),p=`${t}/${e}/${s}`;let u=J(c,i.registryId,p);if(n(u)){const r=new AbortController;u=this.fetchRawTile(t,e,s,{...i,signal:r.signal}),H(c,i.registryId,p,u,r),u.catch((()=>B(c,i.registryId,p)))}return i.signal&&I(i,(()=>{z(c,i.registryId,p)})),u}_computeMagDirValues(t){const{bandCount:e,dataType:s}=this.rasterInfo;if((2!==e||"vector-magdir"!==s)&&"vector-uv"!==s||2!==t?.length||!t[0]?.length)return null;const i=t[0].length;if("vector-magdir"===s){const e=t[1].map((t=>(t+360)%360));return[t[0],e]}const[r,o]=t,n=[],a=[];for(let t=0;t<i;t++){const[e,s]=A([r[t],o[t]]);n.push(e),a.push(s)}return[n,a]}_getRasterTileAlignmentInfo(t,e){return null==this._rasterTileAlighmentInfo&&(this._rasterTileAlighmentInfo=et(this.rasterInfo)),n(this._rasterTileAlighmentInfo.pyramidsInfo)?null:{startX:e,halfWorldWidth:this._rasterTileAlighmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlighmentInfo.hasGCSSShiftTransform,...this._rasterTileAlighmentInfo.pyramidsInfo[t]}}_getSourceDataInfo(t,e,s,i={}){const r={datumTransformation:i.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};i.srcResolution&&(r.srcResolution=i.srcResolution,this._updateSourceDataInfo(t,r));const o=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:n,srcHeight:a,pyramidLevel:l}=r,m=n/e,c=a/s,p=l<o&&m*c>=16,u=l===o&&this._requireTooManySrcTiles(n,a,e,s);if(p||u||0===n||0===a){const n=new rt({x:(t.xmax-t.xmin)/e,y:(t.ymax-t.ymin)/s,spatialReference:t.spatialReference});let a=st(n,this.rasterInfo.spatialReference,t,r.datumTransformation);const u=!a||i.srcResolution&&a.x+a.y<i.srcResolution.x+i.srcResolution.y;if(p&&i.srcResolution&&u){const t=Math.round(Math.log(Math.max(m,c))/Math.LN2)-1;if(o-l+3>=t){const e=2**t;a={x:i.srcResolution.x*e,y:i.srcResolution.y*e}}}a&&(r.srcResolution=a,this._updateSourceDataInfo(t,r))}return this._requireTooManySrcTiles(r.srcWidth,r.srcHeight,e,s)&&(r.srcWidth=0,r.srcHeight=0),r}_requireTooManySrcTiles(t,e,s,i){const{tileInfo:r}=this.rasterInfo.storageInfo;return Math.ceil(t/r.size[0])*Math.ceil(e/r.size[1])>=256||t/s>8||e/i>8}_updateSourceDataInfo(t,e){e.srcWidth=0,e.srcHeight=0;const{rasterInfo:s}=this,i=s.spatialReference,{srcResolution:r,datumTransformation:o}=e,{pyramidLevel:n,pyramidResolution:l,excessiveReading:m}=K(r,s,this.ioConfig.sampling);if(m)return;let c=e.srcExtent||Z(t,i,o);if(null==c)return;const p=a(s.transform);p&&(c=p.inverseTransform(c)),e.srcExtent=c;const{x:u,y:h}=s.storageInfo.origin,d=Math.floor((c.xmin-u)/l.x+.1),f=Math.floor((h-c.ymax)/l.y+.1),y=Math.floor((c.xmax-u)/l.x-.1),g=Math.floor((h-c.ymin)/l.y-.1),x=c.width<.1*l.x?0:y-d+1,j=c.height<.1*l.y?0:g-f+1;e.pyramidLevel=n,e.pyramidResolution=l,e.srcWidth=x,e.srcHeight=j,e.ul={x:d,y:f}}_getRequestOptionsWithSliceId(t){return o(this.rasterInfo.multidimensionalInfo)&&null==t.sliceId&&(t={...t,sliceId:this.getSliceIndex(t.multidimensionalDefinition)}),t}_processIdentifyResult(t,e){const{srcLocation:s,position:i,pyramidLevel:r,useTransposedTile:l}=e,m=t.pixels[0].length/t.width/t.height;if(t.mask&&!t.mask[i])return{location:s,value:null};const{multidimensionalInfo:c}=this.rasterInfo;if(n(c)||!l){const e=t.pixels.map((t=>t[i])),o={location:s,value:e,pyramidLevel:r},n=this._computeMagDirValues(e.map((t=>[t])));return n?.length&&(o.magdirValue=n.map((t=>t[0]))),o}let p=t.pixels.map((t=>t.slice(i*m,i*m+m))),u=this._computeMagDirValues(p);const{requestSomeSlices:h,identifyOptions:d}=e;let y=T(c,d.transposedVariableName);if(h){const t=_(y,a(d.multidimensionalDefinition),a(d.timeExtent));p=p.map((e=>t.map((t=>e[t])))),u=u?.map((e=>t.map((t=>e[t])))),y=t.map((t=>y[t]))}const g=t.noDataValues||this.rasterInfo.noDataValue,x={pixels:p,pixelType:t.pixelType};let j;return o(g)&&(U(x,g),j=x.mask),{location:s,value:null,dataSeries:y.map(((t,e)=>{const s={value:0===j?.[e]?null:p.map((t=>t[e])),multidimensionalDefinition:t.multidimensionalDefinition.map((t=>new f({...t,isSlice:!0})))};return u?.length&&(s.magdirValue=[u[0][e],u[1][e]]),s})),pyramidLevel:r}}};t([m()],ht.prototype,"_rasterTileAlighmentInfo",void 0),t([m({readOnly:!0})],ht.prototype,"_isGlobalWrappableSource",null),t([m({readOnly:!0})],ht.prototype,"_hasNoneOrGCSShiftTransform",null),t([m(d)],ht.prototype,"url",null),t([m({type:String,json:{write:!0}})],ht.prototype,"datasetName",void 0),t([m({type:String,json:{write:!0}})],ht.prototype,"datasetFormat",void 0),t([m()],ht.prototype,"hasUniqueSourceStorageInfo",void 0),t([m()],ht.prototype,"rasterInfo",void 0),t([m()],ht.prototype,"ioConfig",void 0),t([m()],ht.prototype,"sourceJSON",void 0),ht=t([p("esri.layers.support.rasterDatasets.BaseRaster")],ht);const dt=ht;let ft=class extends dt{constructor(){super(...arguments),this.datasetFormat="Function",this.tileType="Raster",this.rasterFunction=null}async open(t){await this.init();const{rasterFunction:e}=this;this.primaryRasters?.rasters?.length?e.sourceRasters=this.primaryRasters.rasters:this.primaryRasters=e.getPrimaryRasters();const{rasters:s,rasterIds:r}=this.primaryRasters,o=s.map((e=>e.rasterInfo?void 0:e.open(t)));await Promise.all(o);const n=s.map((({rasterInfo:t})=>t)),a=e.bind({rasterInfos:n,rasterIds:r});if(!a.success||0===n.length)throw new i("raster-function:open",`cannot bind the function: ${a.error??""}`);await this.syncJobHandler();const l=n[0];this.hasUniqueSourceStorageInfo=1===n.length||n.slice(1).every((t=>this._hasSameStorageInfo(t,l))),this.set("sourceJSON",s[0].sourceJSON),this.set("rasterInfo",e.rasterInfo)}async syncJobHandler(){return this.rasterJobHandler?.updateRasterFunction(this.rasterFunction)}async fetchPixels(t,e,s,i={}){const{rasters:r,rasterIds:a}=this.primaryRasters;let l=!1;const{interpolation:m}=i,c=this.rasterFunction.flatWebGLFunctionChain?.hasSurfaceFunction;!i.requestRawData&&"bilinear"!==m&&c&&(l=1===r.length&&!i.skipRasterFunction,i={...i,interpolation:"bilinear",requestRawData:l});const p=r.map((r=>r.fetchPixels(t,e,s,i))),u=await Promise.all(p),h=u.map((t=>t.pixelBlock)),d=l||i.requestRawData?u.map((t=>t.srcTilePixelSize)):null;if(i.skipRasterFunction||h.every((t=>n(t))))return u[0];const f=u.find((t=>o(t.pixelBlock)))?.extent??t,y=this.rasterJobHandler?await this.rasterJobHandler.process({extent:f,primaryPixelBlocks:h,primaryPixelSizes:d,primaryRasterIds:a}):this.rasterFunction.process({extent:f,primaryPixelBlocks:h,primaryPixelSizes:d,primaryRasterIds:a}),{transformGrid:g}=u[0];if(!l||n(y)||n(g))return{...u[0],pixelBlock:y};const x={rows:g.spacing[0],cols:g.spacing[1]};let j;return j=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:[y],srcMosaicSize:{width:y.width,height:y.height},destDimension:{width:e,height:s},coefs:g.coefficients,sampleSpacing:x,projectDirections:!1,gcsGrid:null,isUV:!1,interpolation:m,alignmentInfo:void 0,blockWidths:null},i)).pixelBlock:V(y,{width:e,height:s},g.coefficients,x,m),{extent:t,srcExtent:u[0].srcExtent,pixelBlock:j}}_hasSameStorageInfo(t,e){const{storageInfo:s,pixelSize:i,spatialReference:r,extent:o}=t,{storageInfo:n,pixelSize:a,spatialReference:l,extent:m}=e;return i.x===a.x&&i.y===a.y&&r.equals(l)&&o.equals(m)&&s.blockHeight===n.blockHeight&&s.blockWidth===n.blockWidth&&s.maximumPyramidLevel===n.maximumPyramidLevel}};t([m({type:String,json:{write:!0}})],ft.prototype,"datasetFormat",void 0),t([m()],ft.prototype,"tileType",void 0),t([m()],ft.prototype,"rasterFunction",void 0),t([m()],ft.prototype,"primaryRasters",void 0),ft=t([p("esri.layers.support.rasterDatasets.FunctionRaster")],ft);const yt=ft,gt=r.getLogger("esri.layers.mixins.ImageryTileMixin"),xt=r=>{let a=class extends r{constructor(...t){super(...t),this._isConstructedFromFunctionRaster=!1,this._rasterJobHandler={instance:null,refCount:0,connectionPromise:null},this.bandIds=null,this.copyright=null,this.interpolation="nearest",this.multidimensionalSubset=null,this.raster=null,this.rasterFunction=null,this.rasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.symbolizer=null,this._isConstructedFromFunctionRaster="Function"===t[0]?.raster?.datasetFormat}get fullExtent(){return this.rasterInfo?.extent}set multidimensionalDefinition(t){this._set("multidimensionalDefinition",t),this.updateRenderer()}get tileInfo(){return this.rasterInfo?.storageInfo.tileInfo}set url(t){this._set("url",h(t,gt))}set renderer(t){this._set("renderer",t),this.updateRenderer()}async convertVectorFieldData(t,e){if(n(t)||!this.rasterInfo)return null;const s=this._rasterJobHandler.instance,i=this.rasterInfo.dataType;return s?s.convertVectorFieldData({pixelBlock:t,dataType:i},e):q(t,i)}async createFlowMesh(t,e){const s=this._rasterJobHandler.instance;return s?s.createFlowMesh(t,e):pt(t.meshType,t.simulationSettings,t.flowData,o(e.signal)?e.signal:(new AbortController).signal)}normalizeRasterFetchOptions(t){const{multidimensionalInfo:e}=this.rasterInfo??{};if(n(e))return t;let s=t.multidimensionalDefinition||this.multidimensionalDefinition;!n(s)&&s.length||(s=F(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset}));const i=t.timeExtent||this.timeExtent;if(o(s)&&o(i)&&(o(i.start)||o(i.end))){s=s.map((t=>t.clone()));const r=e.variables.find((({name:t})=>t===s[0].variableName))?.dimensions?.find((({name:t})=>"StdTime"===t)),a=s.find((({dimensionName:t})=>"StdTime"===t));if(!r||!a)return{...t,multidimensionalDefinition:null};const{start:l,end:m}=i,c=n(l)?null:l.getTime(),p=n(m)?null:m.getTime(),u=c??p,h=p??c;if(o(r.values)){const t=r.values.filter((t=>{if(Array.isArray(t)){if(u===h)return t[0]<=u&&t[1]>=u;const e=t[0]<=u&&t[1]>u||t[0]<h&&t[1]>=h,s=t[0]>=u&&t[1]<=h||t[0]<u&&t[1]>h;return e||s}return u===h?t===u:t>=u&&t<=h}));if(t.length){const e=t.sort(((t,e)=>u===h?(t[0]??t)-(e[0]??e):Math.abs((t[1]??t)-h)-Math.abs((e[1]??e)-h)))[0];a.values=[e]}else s=null}else if(r.hasRegularIntervals&&r.extent){const[t,e]=r.extent;u>e||h<t?s=null:a.values=u===h?[u]:[Math.max(t,u),Math.min(e,h)]}}return o(s)&&D(s,this.multidimensionalSubset)?{...t,multidimensionalDefinition:null}:{...t,multidimensionalDefinition:s}}async updateRasterFunction(){if("imagery-tile"!==this.type||!this.rasterFunction&&!this._cachedRasterFunctionJson||JSON.stringify(this.rasterFunction)===JSON.stringify(this._cachedRasterFunctionJson))return;if(this._isConstructedFromFunctionRaster&&"Function"===this.raster.datasetFormat){const t=this.raster.rasterFunction.toJSON();return!this.rasterFunction&&t&&this._set("rasterFunction",g.fromJSON(t)),void(this._cachedRasterFunctionJson=this.rasterFunction?.toJSON())}let t,e=this.raster,s=!1;"Function"===e.datasetFormat?(t=e.primaryRasters.rasters,e=t[0],s=!0):t=[e];const{rasterFunction:i}=this;if(i){const s={raster:e};t.length>1&&t.forEach((t=>s[t.url]=t));const r=ot(i.rasterFunctionDefinition??i.toJSON(),s),o=new yt({rasterFunction:r});o.rasterJobHandler=this._rasterJobHandler.instance,await o.open(),this._cachedRasterFunctionJson=this.rasterFunction?.toJSON(),this.raster=o}else this.raster=e,this._cachedRasterFunctionJson=null;if(this._cachedRendererJson=null,!s&&!i)return;const{bandIds:r}=this,{bandCount:o}=this.raster.rasterInfo,n=r?.length?r.some((t=>t>=o)):o>=3;r&&(n||"raster-stretch"!==this.renderer.type)&&this._set("bandIds",null),this._configDefaultRenderer("auto")}async updateRenderer(){const{loaded:t,symbolizer:e}=this;if(!t||!e)return;const{rasterInfo:s}=this.raster,i=C(s,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),r=i?.name,o=nt({...this.renderer.toJSON(),variableName:r});if(JSON.stringify(this._cachedRendererJson)===JSON.stringify(o))return;const n=this._rasterJobHandler.instance;n&&(e.rasterInfo=at(s,r),e.rendererJSON=o,e.bind(),await n.updateSymbolizer(e),this._cachedRendererJson=o)}async applyRenderer(t,e){const s=t&&t.pixelBlock;if(!(o(s)&&s.pixels&&s.pixels.length>0))return null;let i;await this.updateRenderer();const r=this._rasterJobHandler.instance,n=this.bandIds??[];return i=r?await r.symbolize({...t,simpleStretchParams:e,bandIds:n}):this.symbolizer.symbolize({...t,simpleStretchParams:e,bandIds:n}),i}getTileUrl(t,e,s){return"RasterTileServer"===this.raster.datasetFormat?`${this.url}/tile/${t}/${e}/${s}`:""}getCompatibleTileInfo(t,e,s=!1){if(!this.loaded||n(e))return null;if(s&&t.equals(this.spatialReference))return this.tileInfo;const i=u(t);return j.create({size:256,spatialReference:t,origin:i?{x:i.origin[0],y:i.origin[1]}:{x:e.xmin,y:e.ymax}})}getCompatibleFullExtent(t){return this.loaded?(this._compatibleFullExtent&&this._compatibleFullExtent.spatialReference.equals(t)||(this._compatibleFullExtent=this.raster.computeExtent(t)),this._compatibleFullExtent):null}async fetchTile(t,e,i,r={}){if(l(this),r.requestAsImageElement){const o=this.getTileUrl(t,e,i);return s(o,{responseType:"image",query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:r.signal}).then((t=>t.data))}const{rasterInfo:a}=this;if(o(a.multidimensionalInfo)&&(r=this.normalizeRasterFetchOptions(r),n(r.multidimensionalDefinition))){const s=r.tileInfo||a.storageInfo.tileInfo;return{extent:this.raster.getTileExtentFromTileInfo(t,e,i,s),pixelBlock:null}}return await this._initJobHandler(),await this.updateRasterFunction(),"raster-shaded-relief"===this.renderer.type&&(r={...r,buffer:{cols:1,rows:1}}),this.raster.fetchTile(t,e,i,r)}async fetchPixels(t,e,s,i={}){return o(this.rasterInfo.multidimensionalInfo)&&(i=this.normalizeRasterFetchOptions(i),n(i.multidimensionalDefinition))?{extent:t,pixelBlock:null}:(await this._initJobHandler(),await this.updateRasterFunction(),this.raster.fetchPixels(t,e,s,i))}async identify(t,e={}){const{raster:s,rasterInfo:r}=this;if(o(r.multidimensionalInfo)&&(!r.hasMultidimensionalTranspose||!(w(e.multidimensionalDefinition)||e.transposedVariableName||e.timeExtent))&&(e=this.normalizeRasterFetchOptions(e),n(e.multidimensionalDefinition)))return{location:t,value:null};const a=this.multidimensionalSubset?.areaOfInterest;if(a&&!a.contains(t))throw new i("imagery-tile-mixin:identify","the request cannot be fulfilled when falling outside of the multidimensional subset");return s.identify(t,e)}increaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount++}decreaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount--,this._rasterJobHandler.refCount<=0&&this._shutdownJobHandler()}hasStandardTime(){const t=this.rasterInfo?.multidimensionalInfo;if(n(t)||"standard-time"!==this.rasterInfo?.dataType)return!1;const e=this.multidimensionalDefinition,s=e?.[0]?.variableName;return t.variables.some((t=>t.name===s&&(!e?.[0].dimensionName||t.dimensions.some((t=>"StdTime"===t.name)))))}getStandardTimeValue(t){return new Date(24*(t-25569)*3600*1e3).toString()}getMultidimensionalSubsetVariables(t){const e=t??this.rasterInfo?.multidimensionalInfo;return P(this.multidimensionalSubset,e)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=F(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset})),this._configDefaultRenderer()}_initJobHandler(){if(null!=this._rasterJobHandler.connectionPromise)return this._rasterJobHandler.connectionPromise;const t=new x;return this._rasterJobHandler.connectionPromise=t.initialize().then((()=>{l(this),this._rasterJobHandler.instance=t,this.raster.rasterJobHandler=t,this.renderer&&this.updateRenderer(),"Function"===this.raster.datasetFormat&&this.raster.syncJobHandler()})).catch((()=>{})),this._rasterJobHandler.connectionPromise}_shutdownJobHandler(){this._rasterJobHandler.instance&&this._rasterJobHandler.instance.destroy(),this._rasterJobHandler.instance=null,this._rasterJobHandler.connectionPromise=null,this._rasterJobHandler.refCount=0,this._cachedRendererJson=null,this.raster&&(this.raster.rasterJobHandler=null)}_configDefaultInterpolation(){if(null==this.interpolation){l(this);const{raster:t}=this,e=lt(t.rasterInfo,t.tileType,this.sourceJSON?.defaultResamplingMethod);this._set("interpolation",e)}}_configDefaultRenderer(t="no"){l(this);const{rasterInfo:e}=this.raster;!this.bandIds&&e.bandCount>1&&(this.bandIds=mt(e));const s=C(e,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),i=s?.name;if(!this.renderer||"override"===t){const t=ct(e,{bandIds:this.bandIds,variableName:i});"WCSServer"===this.raster.datasetFormat&&"raster-stretch"===t.type&&((e.statistics?.[0].max??0)>1e24||(e.statistics?.[0].min??0)<-1e24)&&(t.dynamicRangeAdjustment=!0,t.statistics=null,"none"===t.stretchType&&(t.stretchType="min-max")),this.renderer=t}const r=nt({...this.renderer.toJSON(),variableName:i}),n=at(e,i);this.symbolizer?(this.symbolizer.rendererJSON=r,this.symbolizer.rasterInfo=n):this.symbolizer=new L({rendererJSON:r,rasterInfo:n});const a=this.symbolizer.bind();if(a.success){if("auto"===t){const{colormap:t}=this.raster.rasterInfo,e=this.renderer;if(o(t))if("raster-colormap"!==e.type)this._configDefaultRenderer("override");else{const t=ct(this.raster.rasterInfo);JSON.stringify(t)!==JSON.stringify(e)&&this._configDefaultRenderer("override")}else if("raster-stretch"===e.type){const t=this.bandIds?.length,s=e.statistics?.length;!e.dynamicRangeAdjustment&&s&&t&&s!==t&&this._configDefaultRenderer("override")}}}else gt.warn("imagery-tile-mixin",a.error||"The given renderer is not supported by the layer."),"auto"===t&&this._configDefaultRenderer("override")}};function l(t){if(!t.raster||!t.rasterInfo)throw new i("imagery-tile","no raster")}return t([m()],a.prototype,"_cachedRendererJson",void 0),t([m()],a.prototype,"_cachedRasterFunctionJson",void 0),t([m()],a.prototype,"_compatibleFullExtent",void 0),t([m()],a.prototype,"_isConstructedFromFunctionRaster",void 0),t([m()],a.prototype,"_rasterJobHandler",void 0),t([m()],a.prototype,"bandIds",void 0),t([m({json:{origins:{service:{read:{source:"copyrightText"}}}}})],a.prototype,"copyright",void 0),t([m({json:{read:!1}})],a.prototype,"fullExtent",null),t([m()],a.prototype,"interpolation",void 0),t([m()],a.prototype,"ioConfig",void 0),t([m({type:[f],json:{write:!0}})],a.prototype,"multidimensionalDefinition",null),t([m({type:y,json:{write:!0}})],a.prototype,"multidimensionalSubset",void 0),t([m()],a.prototype,"raster",void 0),t([m({type:g})],a.prototype,"rasterFunction",void 0),t([m()],a.prototype,"rasterInfo",void 0),t([m()],a.prototype,"sourceJSON",void 0),t([m({readOnly:!0,type:ut,json:{read:!1}})],a.prototype,"spatialReference",void 0),t([m({json:{read:!1}})],a.prototype,"tileInfo",null),t([m(d)],a.prototype,"url",null),t([m({types:e})],a.prototype,"renderer",null),t([m()],a.prototype,"symbolizer",void 0),a=t([p("esri.layers.ImageryTileMixin")],a),a};export{dt as B,yt as F,xt as ImageryTileMixin};
