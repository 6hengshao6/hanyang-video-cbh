/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import e from"../request.js";import t from"../core/Error.js";import{L as r}from"../chunks/Logger.js";import{a as o,i as s}from"../chunks/maybe.js";import{g as i}from"../chunks/object.js";import{removeTrailingSlash as a}from"../core/urlUtils.js";import{a as n,p as u}from"../chunks/utils4.js";import{_ as l}from"../chunks/tslib.es6.js";import{JSONSupport as p}from"../core/JSONSupport.js";import{property as c}from"../core/accessorSupport/decorators/property.js";import"../chunks/ensureType.js";import"../chunks/typedArrayUtil.js";import{e as d}from"../chunks/enumeration.js";import{r as m}from"../chunks/reader.js";import{subclass as f}from"../core/accessorSupport/decorators/subclass.js";import{w as v}from"../chunks/writer.js";import{i as h,d as y,n as g,u as k,a as T}from"../chunks/networkEnums.js";import j from"./support/TravelMode.js";import"../config.js";import"../core/lang.js";import"../kernel.js";import"../chunks/string.js";import"../core/promiseUtils.js";import"../core/Accessor.js";import"../core/Handles.js";import"../chunks/get.js";import"../chunks/utils.js";import"../chunks/handleUtils.js";import"../chunks/metadata.js";import"../chunks/ArrayPool.js";import"../chunks/tracking.js";import"../chunks/watch.js";import"../core/scheduling.js";import"../chunks/nextTick.js";import"../chunks/jsonMap.js";import"../core/Clonable.js";let w=class extends p{constructor(e){super(e),this.dataType=null,this.name=null,this.parameterNames=null,this.restrictionUsageParameterName=null,this.timeNeutralAttributeName=null,this.trafficSupport=null,this.units=null,this.usageType=null}};l([c({type:String})],w.prototype,"dataType",void 0),l([d(h,{ignoreUnknown:!1})],w.prototype,"name",void 0),l([c({type:[String]})],w.prototype,"parameterNames",void 0),l([c({type:String})],w.prototype,"restrictionUsageParameterName",void 0),l([d(y,{ignoreUnknown:!1})],w.prototype,"timeNeutralAttributeName",void 0),l([c({type:String})],w.prototype,"trafficSupport",void 0),l([d(g)],w.prototype,"units",void 0),l([d(k)],w.prototype,"usageType",void 0),w=l([f("esri.rest.support.NetworkAttribute")],w);const M=w;let N=class extends p{constructor(e){super(e),this.buildTime=null,this.name=null,this.networkAttributes=null,this.networkSources=null,this.state=null}};l([c({type:Number})],N.prototype,"buildTime",void 0),l([c({type:String})],N.prototype,"name",void 0),l([c({type:[M]})],N.prototype,"networkAttributes",void 0),l([c()],N.prototype,"networkSources",void 0),l([c({type:String})],N.prototype,"state",void 0),N=l([f("esri.rest.support.NetworkDataset")],N);const S=N;let b=class extends p{constructor(e){super(e),this.accumulateAttributeNames=null,this.attributeParameterValues=null,this.currentVersion=null,this.defaultTravelMode=null,this.directionsLanguage=null,this.directionsLengthUnits=null,this.directionsSupportedLanguages=null,this.directionsTimeAttribute=null,this.hasZ=null,this.impedance=null,this.networkDataset=null,this.supportedTravelModes=null}readAccumulateAttributes(e){return o(e)?null:e.map((e=>h.fromJSON(e)))}writeAccumulateAttributes(e,t,r){!o(e)&&e.length&&(t[r]=e.map((e=>h.toJSON(e))))}readDefaultTravelMode(e,t){const r=t.supportedTravelModes?.find((({id:e})=>e===t.defaultTravelMode))??t.supportedTravelModes?.find((({itemId:e})=>e===t.defaultTravelMode));return r?j.fromJSON(r):null}};l([c()],b.prototype,"accumulateAttributeNames",void 0),l([m("accumulateAttributeNames")],b.prototype,"readAccumulateAttributes",null),l([v("accumulateAttributeNames")],b.prototype,"writeAccumulateAttributes",null),l([c()],b.prototype,"attributeParameterValues",void 0),l([c()],b.prototype,"currentVersion",void 0),l([c()],b.prototype,"defaultTravelMode",void 0),l([m("defaultTravelMode",["defaultTravelMode","supportedTravelModes"])],b.prototype,"readDefaultTravelMode",null),l([c()],b.prototype,"directionsLanguage",void 0),l([d(T)],b.prototype,"directionsLengthUnits",void 0),l([c()],b.prototype,"directionsSupportedLanguages",void 0),l([d(y,{ignoreUnknown:!1})],b.prototype,"directionsTimeAttribute",void 0),l([c()],b.prototype,"hasZ",void 0),l([d(h,{ignoreUnknown:!1})],b.prototype,"impedance",void 0),l([c({type:S})],b.prototype,"networkDataset",void 0),l([c({type:[j]})],b.prototype,"supportedTravelModes",void 0),b=l([f("esri.rest.support.NetworkServiceDescription")],b);const A=b,U=r.getLogger("esri.rest.networkService");function L(e,t,r,o){o[r]=[t.length,t.length+e.length],e.forEach((e=>{t.push(e.geometry)}))}function O(e,t){for(let r=0;r<t.length;r++){const o=e[t[r]];if(o&&o.length)for(const e of o)e.z=void 0}U.warnOnce("The remote Network Analysis service is powered by a network dataset which is not Z-aware.\nZ-coordinates of the input geometry are ignored.")}function x(e,t){for(let r=0;r<t.length;r++){const o=e[t[r]];if(o&&o.length)for(const e of o)if(s(e)&&e.hasZ)return!0}return!1}async function D(r,o,s){if(!r)throw new t("network-service:missing-url","Url to Network service is missing");const l=n({f:"json",token:o},s),{data:p}=await e(r,l),c=p.currentVersion>=10.4?async function(r,o,s){try{const t=n({f:"json",token:o},s),i=a(r)+"/retrieveTravelModes",{data:{supportedTravelModes:u,defaultTravelMode:l}}=await e(i,t);return{supportedTravelModes:u,defaultTravelMode:l}}catch(e){throw new t("network-service:retrieveTravelModes","Could not get to the NAServer's retrieveTravelModes.",{error:e})}}(r,o,s):async function(t,r){const o=n({f:"json"},r),{data:s}=await e(t.replace(/\/rest\/.*$/i,"/info"),o);if(!s||!s.owningSystemUrl)return{supportedTravelModes:[],defaultTravelMode:null};const{owningSystemUrl:l}=s,p=a(l)+"/sharing/rest/portals/self",{data:c}=await e(p,o),d=i("helperServices.routingUtilities.url",c);if(!d)return{supportedTravelModes:[],defaultTravelMode:null};const m=u(l),f=/\/solve$/i.test(m.path)?"Route":/\/solveclosestfacility$/i.test(m.path)?"ClosestFacility":"ServiceAreas",v=n({f:"json",serviceName:f},r),h=a(d)+"/GetTravelModes/execute",y=await e(h,v),g=[];let k=null;if(y?.data?.results?.length){const e=y.data.results;for(const t of e)if("supportedTravelModes"===t.paramName){if(t.value?.features)for(const{attributes:e}of t.value.features)if(e){const t=JSON.parse(e.TravelMode);g.push(t)}}else"defaultTravelMode"===t.paramName&&(k=t.value)}return{supportedTravelModes:g,defaultTravelMode:k}}(r,s),{defaultTravelMode:d,supportedTravelModes:m}=await c;return p.defaultTravelMode=d,p.supportedTravelModes=m,A.fromJSON(p)}export{L as collectGeometries,O as dropZValuesOffInputGeometry,D as fetchServiceDescription,x as isInputGeometryZAware};
