// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.27/esri/copyright.txt for details.
//>>built
define("require exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../core/shaderLibrary/ShaderOutput ../core/shaderTechnique/ReloadableShaderModule ../core/shaderTechnique/ShaderTechnique ../core/shaderTechnique/ShaderTechniqueConfiguration ../lib/basicInterfaces ../lib/OrderIndependentTransparency ../lib/Program ../lib/StencilUtils ../lib/TransparencyPassType ../lib/VertexAttribute ../materials/DefaultTechniqueConfiguration ../materials/PatternStyle ../../../../chunks/Pattern.glsl ../../../webgl/renderState".split(" "),
function(z,l,g,c,m,b,n,d,x,k,A,u,p,q,B,C,D,r){n=function(f){function e(){return v.apply(this,arguments)}g._inherits(e,f);var v=g._createSuper(e);f=e.prototype;f.initializeProgram=function(a){return new A.Program(a.rctx,e.shader.get().build(this.configuration),y)};f._setPipelineState=function(a,t){const h=this.configuration,w=a===p.TransparencyPassType.NONE,E=a===p.TransparencyPassType.FrontFace;return r.makePipelineState({blending:h.output===m.ShaderOutput.Color||h.output===m.ShaderOutput.Alpha?w?
k.blendingDefault:k.oitBlending(a):null,culling:r.cullingParams(h.cullFace),depthTest:{func:k.oitDepthTest(a)},depthWrite:w?h.writeDepth?r.defaultDepthWriteParams:null:k.oitDepthWrite(a),colorWrite:r.defaultColorWriteParams,stencilWrite:h.hasOccludees?u.stencilWriteMaskOn:null,stencilTest:h.hasOccludees?t?u.stencilToolMaskBaseParams:u.stencilBaseAllZerosParams:null,polygonOffset:w||E?h.polygonOffset?F:null:k.getOITPolygonOffset(h.enableOffset)})};f.initializePipeline=function(){this._occludeePipelineState=
this._setPipelineState(this.configuration.transparencyPassType,!0);return this._setPipelineState(this.configuration.transparencyPassType,!1)};f.getPipelineState=function(a,t){return t?this._occludeePipelineState:g._get(g._getPrototypeOf(e.prototype),"getPipelineState",this).call(this,a,t)};return g._createClass(e)}(n.ShaderTechnique);n.shader=new b.ReloadableShaderModule(D.Pattern,()=>new Promise((f,e)=>z(["./Pattern.glsl"],f,e)));const F={factor:1,units:1};b=function(f){function e(){var a=v.apply(this,
arguments);a.output=m.ShaderOutput.Color;a.cullFace=x.CullFaceOptions.None;a.transparencyPassType=p.TransparencyPassType.NONE;a.hasSlicePlane=!1;a.hasVertexColors=!1;a.polygonOffset=!1;a.writeDepth=!0;a.hasOccludees=!1;a.enableOffset=!0;a.hasMultipassTerrain=!1;a.cullAboveGround=!1;return a}g._inherits(e,f);var v=g._createSuper(e);return g._createClass(e)}(B.DefaultTechniqueConfiguration);c.__decorate([d.parameter({count:m.ShaderOutput.COUNT})],b.prototype,"output",void 0);c.__decorate([d.parameter({count:x.CullFaceOptions.COUNT})],
b.prototype,"cullFace",void 0);c.__decorate([d.parameter({count:C.Style.COUNT})],b.prototype,"style",void 0);c.__decorate([d.parameter({count:p.TransparencyPassType.COUNT})],b.prototype,"transparencyPassType",void 0);c.__decorate([d.parameter()],b.prototype,"hasSlicePlane",void 0);c.__decorate([d.parameter()],b.prototype,"hasVertexColors",void 0);c.__decorate([d.parameter()],b.prototype,"polygonOffset",void 0);c.__decorate([d.parameter()],b.prototype,"writeDepth",void 0);c.__decorate([d.parameter()],
b.prototype,"hasOccludees",void 0);c.__decorate([d.parameter()],b.prototype,"patternSpacing",void 0);c.__decorate([d.parameter()],b.prototype,"lineWidth",void 0);c.__decorate([d.parameter()],b.prototype,"enableOffset",void 0);c.__decorate([d.parameter()],b.prototype,"draped",void 0);c.__decorate([d.parameter()],b.prototype,"hasMultipassTerrain",void 0);c.__decorate([d.parameter()],b.prototype,"cullAboveGround",void 0);const y=new Map([[q.VertexAttribute.POSITION,0],[q.VertexAttribute.COLOR,3],[q.VertexAttribute.UVMAPSPACE,
4],[q.VertexAttribute.BOUNDINGRECT,5]]);l.PatternTechnique=n;l.PatternTechniqueConfiguration=b;l.vertexAttributeLocations=y;Object.defineProperty(l,Symbol.toStringTag,{value:"Module"})});