// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.27/esri/copyright.txt for details.
//>>built
define("exports ../../../core/mathUtils ../../../core/maybe ../../../chunks/vec4 ../../../geometry/support/aaBoundingBox ../../../geometry/support/aaBoundingRect ./ElevationData ./interfaces ./PatchGeometry ./PatchGeometryLUT ./PatchRenderData ./terrainUtils ./Tile ./tileUtils".split(" "),function(lb,T,Ma,Jc,Xb,Kc,ha,pb,da,Lc,Yb,B,Zb,zb){function Mc(a){var e=a.tile;if(e.intersectsClippingArea){var r=a.geometryState,A=r.numVerticesPerSide,m=A-2;--A;var x=a.geometryInfo,E=x.vertexAttributes,f=E.position,
J=E.uv0;E=E.normalCompressed;var z=e.extent,N=z[0],R=z[2],P=z[1];z=z[3];e=e.ellipsoid.radius;r=r.samplerData;var Q=a.localOrigin;a=Q[0];var v=Q[1];Q=Q[2];var g=f.typedBuffer;f=f.typedBufferStride;var V=1/A;x=x.boundingBox;var W=0;if(1<=m){var K=P*(1-V)+z*V,n=ua.sinLatLUT[1],d=ua.cosLatLUT[1];for(var h=1;h<=m;h++){var q=h*V,k=ua.sinLonLUT[h],l=ua.cosLonLUT[h],p=e+ha.sampleElevation(N*(1-q)+R*q,K,r);l=-a+p*l*d;k=-v+p*k*d;p=-Q+p*n;da.minMaxBoundingBox(l,k,p,x);var C=(h-1)*f;g[C]=l;g[C+1]=k;g[C+2]=p;
da.encodeUVInBuffer(J,h-1,q,V)}}for(K=1;K<=m;K++){n=K*V;n=P*(1-n)+z*n;d=ua.sinLatLUT[K];h=ua.cosLatLUT[K];k=K+1;q=k*V;l=P*(1-q)+z*q;p=ua.sinLatLUT[k];k=ua.cosLatLUT[k];var t=ua.sinLonLUT[0];C=ua.cosLonLUT[0];var y=e+ha.sampleElevation(N,n,r);C=C*h*y-a;t=t*h*y-v;y=d*y-Q;var u=W*f;let na=g[u],ra=g[u+1];u=g[u+2];for(let ja=1;ja<=m;ja++){var b=ja*V,w=N*(1-b)+R*b,L=ua.sinLonLUT[ja],M=ua.cosLonLUT[ja],Y=0,Z=0,O=0;ja<m?(O=(W+1)*f,Y=g[O],Z=g[O+1],O=g[O+2]):(Z=ua.sinLonLUT[A],Y=ua.cosLonLUT[A],O=e+ha.sampleElevation(R,
n,r),Y=Y*h*O-a,Z=Z*h*O-v,O=d*O-Q);var aa=C,U=t,ba=y;C=na;t=ra;y=u;na=Y;ra=Z;u=O;Y-=aa;Z-=U;O-=ba;aa=U=ba=0;if(1<K)aa=(W-m)*f,ba=g[aa],U=g[aa+1],aa=g[aa+2];else{aa=ua.sinLatLUT[0];U=ua.cosLatLUT[0];var ca=e+ha.sampleElevation(w,P,r);ba=M*U*ca-a;U=L*U*ca-v;aa=aa*ca-Q}ca=e+ha.sampleElevation(w,l,r);const va=M*k*ca-a;w=L*k*ca-v;ca=p*ca-Q;if(K<m){const oa=W+m,c=oa*f;g[c]=va;g[c+1]=w;g[c+2]=ca;da.minMaxBoundingBox(va,w,ca,x);da.encodeUVInBuffer(J,oa,b,q)}b=ba-va;w=U-w;ba=aa-ca;M*=h;L*=h;U=d;.999>U*U&&(M=
O*w-Z*ba,L=Y*ba-O*b,U=Z*b-Y*w);b=1/Math.sqrt(M*M+L*L+U*U);da.encodeNormalInBuffer(E,W,M*b,L*b,U*b);++W}}}}function $b(a){a.tile.intersectsClippingArea&&(Ab(a),ac(a))}function ac(a,e=!1){var r=a.geometryState;const A=a.geometryInfo,m=r.neighborData,x=a.tile,E=x.level,f=x.extent,J=x.ellipsoid.radius;var z=x.extentInRadians;const N=z[0],R=z[2],P=z[1];z=z[3];const Q=r.samplerData,v=f[0],g=f[2],V=f[1],W=f[3],K=Eb(a),n=A.boundingBox;r=a.localOrigin;const d=r[0],h=r[1],q=r[2];r=A.vertexAttributes;var k=
r.position;const l=k.typedBuffer,p=k.typedBufferStride,C=r.uv0;for(let u=0;4>u;++u){const b=1===u||3===u;r=m.edgeResolutions[u];B.internalAssert(T.isPowerOfTwo(r));const w=r+1;var t=Yb.neighborTileIfLoadedOrSelf(x,m.edgePeerNeighbors[u]);if(bc(x,t,u)){cc(a,u,t);continue}const L=Ma.isSome(t);B.internalAssert(!L||t.level===x.level);B.internalAssert(!L||0>=zb.compareTilesByLij(x,t));k=t?.renderData?.geometryState;if(B.ENABLE_TERRAIN_INTERNAL_CHECKS){var y=x.surface;if(!t&&y&&!y.updatingRootTiles){const D=
B.neighborEdgeIndices[u],F=x.findNeighborTile(D,X=>X.isLoaded||X.isLeaf||X.level===x.level);F?F.intersectsClippingArea&&(B.internalAssert(!F.isLoaded),B.internalAssert(!F.isLeaf),B.internalAssert(F.level===E)):B.internalAssert(Ma.isNone(y?.rootTiles)||!x.shouldHaveNeighbor(D))}}const M=1===u?f[2]:f[0],Y=(t=t?.extent)&&b?1===u?t[0]:t[2]:M,Z=0===u?f[3]:f[1],O=1===u?1:0,aa=0===u?1:0,U=1===u?R:N,ba=0===u?z:P,ca=Math.sin(U),na=Math.cos(U),ra=Math.sin(ba),ja=Math.cos(ba),va=k?.samplerData;k=(D,F,X)=>ha.sampleElevation(D,
F,Q);y=(D,F,X)=>.5*(ha.sampleElevation(D,F,Q)+ha.sampleElevation(X,F,va));const oa=L?y:k,c=A.outerEdges[u],H=e&&3<w?w-3:1;k=Ma.isSome(Q)&&Q.some(D=>null!=D);y=Ma.isSome(va)&&va.some(D=>null!=D);const I=k||y,G=1/r,S=c.index0;B.internalAssert(!t||B.almostEquals(t[2]-t[0],f[2]-f[0]));(()=>{const D=1===u?-1:3===u?1:0,F=0===u?-1:2===u?1:0,X=(f[2]-f[0])*G,Ba=D*X,ka=F*X,cb=R-N,wa=b?D*cb*G:0,Oa=b?0:F*G,Ca=aa,xa=b?U+wa:U,Ta=b?Math.sin(xa):ca,sa=b?Math.cos(xa):na,pa=b?U-wa:U,Ha=b?Math.sin(pa):ca,ta=b?Math.cos(pa):
na,ya=b?ba:K(Ca+Oa),za=b?ra:Math.sin(ya),Ka=b?ja:Math.cos(ya),Ua=b?ba:K(Ca-Oa),Da=b?ra:Math.sin(Ua),ia=b?ja:Math.cos(Ua);let ea=0,qa=0,Ia=0;const fa=0*G,db=b?M:v*(1-fa)+g*fa,gb=b?Y:db,hb=b?V*(1-fa)+W*fa:Z,Ya=b?U:N*(1-fa)+R*fa,eb=b?ca:Math.sin(Ya),Va=b?na:Math.cos(Ya),Za=b?K(fa):ba,$a=b?Math.sin(Za):ra,ab=b?Math.cos(Za):ja,Wa=J+oa(db,hb,gb);ea=Va*ab*Wa;qa=eb*ab*Wa;Ia=$a*Wa;let Pa=0,Na=0,Qa=0;const la=1*G,La=b?M:v*(1-la)+g*la,Fa=b?Y:La,Ea=b?V*(1-la)+W*la:Z,Aa=b?U:N*(1-la)+R*la,Ra=b?ca:Math.sin(Aa),
Ga=b?na:Math.cos(Aa),ma=b?K(la):ba,Ja=b?Math.sin(ma):ra,fb=b?Math.cos(ma):ja,ib=J+oa(La,Ea,Fa);Pa=Ga*fb*ib;Na=Ra*fb*ib;Qa=Ja*ib;for(let Sa=1;Sa<w-1;Sa+=H){let mb=0,jb=0,bb=0;const Xa=(Sa+1)*G,kb=b?M:v*(1-Xa)+g*Xa,qb=b?Y:kb,vb=b?V*(1-Xa)+W*Xa:Z,nb=b?U:N*(1-Xa)+R*Xa,Bb=b?ca:Math.sin(nb),Nc=b?na:Math.cos(nb),dc=b?K(Xa):ba,Oc=b?Math.sin(dc):ra,ec=b?Math.cos(dc):ja,Fb=J+oa(kb,vb,qb);mb=Nc*ec*Fb;jb=Bb*ec*Fb;bb=Oc*Fb;const fc=mb,gc=jb,hc=bb,Gb=Pa,Hb=Na,Ib=Qa;Pa=fc;Na=gc;Qa=hc;const ic=S+Sa,Jb=ic*p,jc=Gb-
d,kc=Hb-h,lc=Ib-q;l[Jb]=jc;l[Jb+1]=kc;l[Jb+2]=lc;da.minMaxBoundingBox(jc,kc,lc,n);const mc=Sa*G;da.encodeUVInBuffer(C,ic,b?O:mc,b?mc:aa);const Pc=ea,Qc=qa,Rc=Ia;ea=Gb;qa=Hb;Ia=Ib;const wb=Gb,xb=Hb,rb=Ib,Cb=1/Math.sqrt(wb*wb+xb*xb+rb*rb),nc=rb*Cb;let sb=0,tb=0,ub=0;if(I&&.999>nc*nc){let Kb=0,Lb=0,Mb=0;const Nb=0===u?-1:1;Kb=Nb*(fc-Pc);Lb=Nb*(gc-Qc);Mb=Nb*(hc-Rc);const ob=Sa*G,oc=b?M:v*(1-ob)+g*ob,Sc=b?Y:oc,pc=b?V*(1-ob)+W*ob:Z,qc=b?U:N*(1-ob)+R*ob,rc=b?ca:Math.sin(qc),sc=b?na:Math.cos(qc),tc=b?K(ob):
ba,uc=b?Math.sin(tc):ra,vc=b?Math.cos(tc):ja;let Ob=wb,Pb=xb,Qb=rb;if(L){const Rb=J+ha.sampleElevation(Sc-Ba,pc-ka,va),Tc=b?Ha:rc,Uc=b?uc:Da,wc=b?vc:ia;Ob=(b?ta:sc)*wc*Rb;Pb=Tc*wc*Rb;Qb=Uc*Rb}const Sb=J+ha.sampleElevation(oc+Ba,pc+ka,Q),xc=b?vc:Ka,yc=(b?sa:sc)*xc*Sb,zc=(b?Ta:rc)*xc*Sb,Ac=(b?uc:za)*Sb;L||(Ob=2*wb-yc,Pb=2*xb-zc,Qb=2*rb-Ac);const Tb=3===u?-1:1,Bc=Tb*(Ob-yc),Cc=Tb*(Pb-zc),Dc=Tb*(Qb-Ac);sb=Mb*Cc-Lb*Dc;tb=Kb*Dc-Mb*Bc;ub=Lb*Bc-Kb*Cc;const Ub=1/Math.sqrt(sb*sb+tb*tb+ub*ub);sb*=Ub;tb*=Ub;
ub*=Ub}else sb=wb*Cb,tb=xb*Cb,ub=rb*Cb;c.setNormalFromValues(Sa,sb,tb,ub)}})()}}function Eb(a){a=a.tile;if(a.surface.isWebMercator){const r=a.extent,A=a.ellipsoid.radius;return m=>Math.PI/2-2*Math.atan(Math.exp(-(r[1]*(1-m)+r[3]*m)/A))}const e=a.extentInRadians;return r=>e[1]*(1-r)+e[3]*r}function Vc(a){const e=a.tile;if(e.intersectsClippingArea){var r=a.geometryState,A=r.samplerData,m=a.localOrigin,x=e.surface.isWebMercatorOnPlateeCarree,E=r.clippingArea,f=Ma.isSome(E)?E:Vb,J=e.extent,z=J[0],N=J[1],
R=J[2],P=J[3],Q=Math.max(z,f[0]),v=Math.min(R,f[2]),g=Math.max(N,f[1]),V=Math.min(P,f[3]),W=e.ellipsoid.radius,K=e.horizontalScale,n=r.numVerticesPerSide,d=n-1,h=n-2,q=a.geometryInfo,k=q.vertexAttributes,l=k.position,p=k.uv0,C=k.normalCompressed,t=q.uvRange,y=t[0],u=t[1],b=t[2],w=t[3],L=q.boundingBox,M=m[0],Y=m[1],Z=m[2],O=l.typedBuffer,aa=l.typedBufferStride,U=0,ba=T.clamp(N,g,V),ca=x?(Math.PI/2-2*Math.atan(Math.exp(-ba/W)))*W:ba*K,na=1/d,ra=T.clamp(N*(1-na)+P*na,g,V),ja=ca,va=x?(Math.PI/2-2*Math.atan(Math.exp(-ra/
W)))*W:ra*K;for(let oa=1;oa<=h;oa++){const c=oa/d,H=T.clamp(N*(1-c)+P*c,g,V),I=T.clamp(c,u,w),G=va,S=(oa-1)/d,D=T.clamp(N*(1-S)+P*S,g,V),F=ja,X=(oa+1)/d,Ba=T.clamp(N*(1-X)+P*X,g,V),ka=x?(Math.PI/2-2*Math.atan(Math.exp(-Ba/W)))*W:Ba*K,cb=T.clamp(X,u,w);ja=va;va=ka;const wa=T.clamp(z,Q,v);let Oa=wa*K,Ca=ha.sampleElevation(wa,H,A);const xa=1/d,Ta=T.clamp(xa,y,b),sa=T.clamp(z*(1-Ta)+R*Ta,Q,v);let pa=Ta,Ha=sa,ta=sa*K,ya=ha.sampleElevation(sa,H,A);if(1===oa){const za=ta-M,Ka=ja-Y,Ua=ya-Z,Da=0*aa;O[Da]=
za;O[Da+1]=Ka;O[Da+2]=Ua;da.minMaxBoundingBox(za,Ka,Ua,L);const ia=T.clamp(xa,y,b);da.encodeUVInBuffer(p,U,ia,I)}for(let za=1;za<=h;za++){const Ka=ta,Ua=ya,Da=(za+1)/d,ia=T.clamp(Da,y,b),ea=T.clamp(z*(1-Da)+R*Da,Q,v),qa=Ha;Ha=ea;const Ia=U+1,fa=Ia*aa;if(1===oa||za===h){const la=ha.sampleElevation(ea,H,A),La=ea*K,Fa=G,Ea=la;if(1===oa&&za<h){const Aa=La-M,Ra=Fa-Y,Ga=Ea-Z;O[fa]=Aa;O[fa+1]=Ra;O[fa+2]=Ga;da.minMaxBoundingBox(Aa,Ra,Ga,L);da.encodeUVInBuffer(p,Ia,ia,I)}ta=La;ya=Ea}else ta=O[fa]+M,ya=O[fa+
2]+Z;const db=ta,gb=ya,hb=Oa,Ya=Ca;Oa=Ka;Ca=Ua;const eb=(U-h)*aa,Va=1===oa?ha.sampleElevation(qa,D,A):O[eb+2]+Z,Za=ha.sampleElevation(qa,Ba,A);if(oa<h){const la=U+h,La=la*aa,Fa=Ka-M,Ea=ka-Y,Aa=Za-Z;O[La]=Fa;O[La+1]=Ea;O[La+2]=Aa;da.minMaxBoundingBox(Fa,Ea,Aa,L);const Ra=pa;pa=ia;da.encodeUVInBuffer(p,la,Ra,cb)}const $a=db-hb,ab=F-ka,Wa=ab*(gb-Ya),Pa=$a*(Va-Za),Na=-ab*$a,Qa=Wa*Wa+Pa*Pa+Na*Na;if(0===Qa)da.encodeNormalInBuffer(C,U,0,0,1);else{const la=1/Math.sqrt(Qa);da.encodeNormalInBuffer(C,U,Wa*la,
Pa*la,Na*la)}++U}}}}function Ec(a,e){a.tile.intersectsClippingArea&&(Ab(a),Fc(a,!1))}function Fc(a,e){const r=a.geometryState,A=r.neighborData,m=a.tile,x=m.surface,E=m.extent,f=r.clippingArea,J=Ma.isSome(f)?f:Vb,z=E[0],N=E[2],R=E[1],P=E[3],Q=[P>J[3],N>J[2],R<J[1],z<J[0]],v=a.geometryInfo,g=m.horizontalScale,V=Gc(x.isWebMercatorOnPlateeCarree,m.ellipsoid.radius,g),W=v.boundingBox,K=v.uvRange[0],n=v.uvRange[1],d=v.uvRange[2],h=v.uvRange[3],q=Math.max(z,J[0]),k=Math.min(N,J[2]),l=Math.max(R,J[1]),p=
Math.min(P,J[3]),C=a.localOrigin,t=C[0],y=C[1],u=C[2],b=r.samplerData;for(let w=0;4>w;++w){const L=1===w||3===w,M=A.edgeResolutions[w];B.internalAssert(T.isPowerOfTwo(M));const Y=M+1,Z=Q[w],O=Yb.neighborTileIfLoadedOrSelf(m,A.edgePeerNeighbors[w]);if(!Z&&bc(m,O,w)){cc(a,w,O);continue}const aa=Ma.isSome(O)&&!Z,U=O?.renderData?.geometryState;if(B.ENABLE_TERRAIN_INTERNAL_CHECKS&&(B.internalAssert(!aa||O.level===m.level),B.internalAssert(!aa||0>=zb.compareTilesByLij(m,O)),m&&!O&&!x.updatingRootTiles)){const ia=
B.neighborEdgeIndices[w],ea=m.findNeighborTile(ia,qa=>qa.isLoaded||qa.isLeaf||qa.level===m.level);x.updatingRootTiles||(ea?ea.intersectsClippingArea&&(B.internalAssert(!ea.isLoaded),B.internalAssert(!ea.isLeaf),B.internalAssert(ea.level===m.level)):B.internalAssert(Ma.isNone(x?.rootTiles)||!m.shouldHaveNeighbor(ia)))}const ba=T.clamp(1===w?N:z,q,k),ca=T.clamp(0===w?P:R,l,p),na=U?.samplerData,ra=v.outerEdges[w],ja=e&&3<Y?Y-3:1,va=T.clamp(1===w?1:0,K,d),oa=T.clamp(0===w?1:0,n,h),c=(ia,ea)=>ha.sampleElevation(ia,
ea,b),H=(ia,ea)=>.5*(ha.sampleElevation(ia,ea,na)+ha.sampleElevation(ia,ea,b)),I=aa?H:c,G=(N-z)/M,S=L?1===w?G:-G:0,D=L?0:0===w?G:-G,F=-S,X=-D;let Ba=0,ka=0,cb=0;const wa=0/M,Oa=L?ba:T.clamp(z*(1-wa)+N*wa,q,k),Ca=L?T.clamp(R*(1-wa)+P*wa,l,p):ca,xa=I(Oa,Ca);Ba=Oa*g;ka=V(Ca);cb=xa;let Ta=0,sa=0,pa=0;const Ha=1/M,ta=L?ba:T.clamp(z*(1-Ha)+N*Ha,q,k),ya=L?T.clamp(R*(1-Ha)+P*Ha,l,p):ca,za=I(ta,ya),Ka=ta*g,Ua=V(ya),Da=za;Ta=Ka;sa=Ua;pa=Da;for(let ia=1;ia<Y-1;ia+=ja){const ea=ia/M,qa=Ta,Ia=sa,fa=pa,db=L?va:
T.clamp(ea,K,d),gb=L?T.clamp(ea,n,h):oa,hb=qa-t,Ya=Ia-y,eb=fa-u;da.minMaxBoundingBox(qa,Ya,eb,W);ra.setVertexFromValuesRawPositionUV(ia,hb,Ya,eb,db,gb);const Va=(ia+1)/M,Za=L?ba:T.clamp(z*(1-Va)+N*Va,q,k),$a=L?T.clamp(R*(1-Va)+P*Va,l,p):ca,ab=I(Za,$a);Ta=Za*g;sa=V($a);pa=ab;const Wa=Ta,Pa=sa,Na=pa,Qa=Ba,la=ka,La=cb;Ba=qa;ka=Ia;cb=fa;let Fa=0,Ea=0,Aa=0;if(L){const Ga=Pa-Ia,ma=Na-fa,Ja=la-Ia,fb=La-fa,ib=T.clamp(R*(1-ea)+P*ea,l,p),Sa=ba+F,mb=Sa*g,jb=ha.sampleElevation(Sa,ib,b),bb=mb-qa,Xa=jb-fa,kb=3===
w?-1:1;Fa=kb*(-Ja+Ga)*Xa;Ea=kb*bb*(-fb+ma);Aa=-kb*bb*(-Ja+Ga);if(aa){const qb=ba+S,vb=qb*g,nb=ha.sampleElevation(qb,ib,na),Bb=vb-qa;Fa=(-Ja+Ga)*(Xa-(nb-fa));Ea=(bb-Bb)*(-fb+ma);Aa=-(bb-Bb)*(-Ja+Ga)}}else{const Ga=Wa-qa,ma=Na-fa,Ja=Qa-qa,fb=La-fa,ib=T.clamp(z*(1-ea)+N*ea,q,k),Sa=ca+X,mb=ha.sampleElevation(ib,Sa,b)-fa,jb=V(Sa)-Ia,bb=2===w?-1:1;Fa=bb*jb*(-fb+ma);Ea=bb*(-Ja+Ga)*mb;Aa=-bb*jb*(-Ja+Ga);if(aa){const Xa=ib,kb=ca+D,qb=V(kb),vb=ha.sampleElevation(Xa,kb,na)-fa,nb=qb-Ia;Fa=(-jb+nb)*(-fb+ma);Ea=
(-Ja+Ga)*(-mb+vb);Aa=-(-jb+nb)*(-Ja+Ga)}}const Ra=1/Math.sqrt(Fa*Fa+Ea*Ea+Aa*Aa);ra.setNormalFromValues(ia,Fa*Ra,Ea*Ra,Aa*Ra)}}}function Gc(a,e,r){return a?A=>(Math.PI/2-2*Math.atan(Math.exp(-A/e)))*e:A=>A*r}function Hc(a,e,r,A,m,x){const E=e-1,f=a.vertexAttributes.count,J=2*(Math.min(e-2,A[1])-Math.max(1,A[0]))*(Math.min(e-2,m[1])-Math.max(1,m[0])),z=B.neighborEdgeIndices.map((n,d)=>0===d&&m[1]<e-2||1===d&&A[1]<e-2||2===d&&1<m[0]||3===d&&1<A[0]),N=a.outerEdges.reduce((n,d,h)=>n+(z[h]?0:E-2+d.count-
1),0),R=r.reduce((n,d)=>n+E*(2*(d.latitudeResolution-1)+1),0),P=x?2:1,Q=3*(J+N+R)*P,v=65536<=f?new Uint32Array(Q):new Uint16Array(Q);let g=0;const V=e-2,W=E-2;B.internalAssert(0<=W);const K=(n,d,h,q,k,l)=>{var p=n*k;n=l[p];const C=l[p+1];p=l[p+2];var t=d*k;d=l[t];const y=l[t+1];t=l[t+2];var u=h*k;h=l[u];const b=l[u+1];u=l[u+2];const w=q*k;q=l[w];k=l[w+1];l=l[w+2];return(d-q)*(d-q)+(y-k)*(y-k)+(t-l)*(t-l)>(n-h)*(n-h)+(C-b)*(C-b)+(p-u)*(p-u)};if(x){const n=(d,h,q)=>{v[g++]=d;v[g++]=h;v[g++]=h;v[g++]=
q;v[g++]=q;v[g++]=d;B.ENABLE_TERRAIN_INTERNAL_CHECKS&&(B.internalAssert(d<f),B.internalAssert(h<f),B.internalAssert(q<f),B.internalAssert(g<=Q))};(()=>{for(let d=Math.max(m[0],1)-1;d<Math.min(m[1],e-2)-1;++d){const h=d*V;for(let q=Math.max(A[0],1)-1;q<Math.min(A[1],e-2)-1;++q){const k=d*V+q,l=k+1,p=l+V,C=p-1,t=h+q,y=t+1,u=y+V;K(t,y,u,u-1,a.vertexAttributes.position.typedBufferStride,a.vertexAttributes.position.typedBuffer)?(n(k,l,p),n(p,C,k)):(n(k,l,C),n(C,p,l))}}})();B.internalAssert(g===3*J*P);
(()=>{for(let h=0;4>h;++h){const q=g;if(z[h])continue;const k=a.outerEdges[h],l=a.innerEdges[h];let p=0,C=0;const t=k.count,y=l.count;B.internalAssert(y===E-1);let u=0;const b=1===h||2===h?(w,L,M)=>n(w,L,M):(w,L,M)=>n(w,M,L);for(;p<t-1||C<y-1;){const w=l.getVertexIndex(C),L=k.getVertexIndex(p);var d=p<t-1;const M=C<y-1,Y=d?E*(p+.5)/(t-1):0,Z=M?1+W*(C+.5)/(y-1):0;d&&(!M||Y<=Z)?(++p,B.ENABLE_TERRAIN_INTERNAL_CHECKS&&B.internalAssert(p<t),d=k.getVertexIndex(p),b(w,L,d)):(++C,B.ENABLE_TERRAIN_INTERNAL_CHECKS&&
B.internalAssert(C<y),d=l.getVertexIndex(C),b(w,L,d));u++}B.ENABLE_TERRAIN_INTERNAL_CHECKS&&(B.internalAssert(p===t-1),B.internalAssert(C===y-1),B.internalAssert(u===t+y-2),B.internalAssert(u===E-2+k.count-1),B.internalAssert(g===q+3*u*P))}})();B.internalAssert(g===3*(J+N)*P);r.forEach(d=>{var h=a.outerEdges[d.connectedOuterEdgeOffset];let q=h.getVertexIndex(0);h=h.stride;for(let k=0;k<d.latitudeResolution;++k){const l=0===k?d.rowOffset:q+e;for(let p=0;p<E;p++)n(q,q+1,l+p),k<d.latitudeResolution-
1&&n(q+1,l+p+1,l+p),q+=h;q=l;h=1}})}else(()=>{var n=Math.max(m[0],1)-1;const d=Math.min(m[1],e-2)-1,h=Math.max(A[0],1)-1,q=Math.min(A[1],e-2)-1;for(;n<d;++n){const k=n*V;for(let l=h;l<q;++l){const p=k+l,C=p+1,t=C+V,y=t-1;K(p,C,t,y,a.vertexAttributes.position.typedBufferStride,a.vertexAttributes.position.typedBuffer)?(v[g]=p,v[g+1]=C,v[g+2]=t,v[g+3]=t,v[g+4]=y,v[g+5]=p):(v[g]=p,v[g+1]=C,v[g+2]=y,v[g+3]=y,v[g+4]=C,v[g+5]=t);g+=6}}})(),B.internalAssert(g===3*J*P),(()=>{for(let k=0;4>k;++k){if(z[k])continue;
var n=a.outerEdges[k],d=a.innerEdges[k];let l=0,p=0;const C=n.count,t=d.count;B.internalAssert(t===E-1);var h=1===k||2===k;const y=h?1:2;h=h?2:1;const u=n.index0;n=n.stride;const b=d.index0;for(d=d.stride;l<C-1||p<t-1;){const w=b+p*d,L=u+l*n;var q=l<C-1;const M=p<t-1,Y=q?E*(l+.5)/(C-1):0,Z=M?1+W*(p+.5)/(t-1):0;(q=q&&(!M||Y<=Z))?++l:++p;q=q?L+n:w+d;v[g]=w;v[g+y]=L;v[g+h]=q;g+=3}}})(),B.internalAssert(g===3*(J+N)*P),r.forEach(n=>{var d=a.outerEdges[n.connectedOuterEdgeOffset];let h=d.getVertexIndex(0);
d=d.stride;for(let q=0;q<n.latitudeResolution;++q){const k=0===q?n.rowOffset:h+e;for(let l=0;l<E;l++){const p=k+l;v[g]=h;v[g+1]=h+1;v[g+2]=p;q<n.latitudeResolution-1?(v[g+3]=h+1,v[g+4]=p+1,v[g+5]=p,g+=6):g+=3;h+=d}h=k;d=1}});B.internalAssert(g===Q);a.indices=v;a.indexCount=Q}function Ic(a,e){const r=a.localOrigin,A=a.geometryInfo;a=a.geometryState.neighborData.edgeResolutions;const m=A.numVerticesPerSide-2,x=A.vertexAttributes;for(let f=0;4>f;++f){var E=0===f||2===f;A.innerEdges[f]=new da.EdgeDescriptor(x,
r,(0===f?m-1:0)*m+(1===f?m-1:0),(E?0:1)*m+(E?1:0),m);E=a[f]+1;A.outerEdges[f]=new da.EdgeDescriptor(x,r,e,1,E);e+=E}}function cc(a,e,r){var A=(e+2)%4,m=a.tile,x=m.level-r.level;const E=1===e||3===e,f=a.geometryState.neighborData.edgeResolutions[e];B.internalAssert(T.isPowerOfTwo(f));const J=f+1;var z=a.geometryInfo;const N=z.boundingBox;var R=z.outerEdges[e];const P=z.uvRange[0],Q=z.uvRange[1],v=z.uvRange[2];z=z.uvRange[3];const g=T.clamp(1===e?1:0,P,v),V=T.clamp(0===e?1:0,Q,z);var W=r.renderData,
K=W.geometryState,n=W.geometryInfo.outerEdges[A];e=m.getNeighborEdgeStartVertexIndex(e,r)*f;x=f*2**x;B.internalAssert(K.neighborData.edgeResolutions[A]===x);B.internalAssert(n.count-1===x);A=W.localOrigin[0]-a.localOrigin[0];x=W.localOrigin[1]-a.localOrigin[1];a=W.localOrigin[2]-a.localOrigin[2];var d=R.attributes;W=R.index0;R=R.stride;K=d.position.typedBuffer;r=d.position.typedBufferStride;m=d.normalCompressed.typedBuffer;const h=d.normalCompressed.typedBufferStride;d=d.uv0;var q=n.attributes;const k=
n.index0;n=n.stride;const l=q.position.typedBuffer,p=q.position.typedBufferStride,C=q.normalCompressed.typedBuffer;q=q.normalCompressed.typedBufferStride;for(let b=1;b<J-1;++b){const w=W+R*b;var t=k+n*(e+b),y=w*r,u=t*p;const L=l[u]+A,M=l[u+1]+x;u=l[u+2]+a;K[y]=L;K[y+1]=M;K[y+2]=u;da.minMaxBoundingBox(L,M,u,N);y=w*h;t*=q;m[y]=C[t];m[y+1]=C[t+1];y=b/f;t=E?g:T.clamp(y,P,v);y=E?T.clamp(y,Q,z):V;da.encodeUVInBuffer(d,w,t,y)}}function Ab(a){const e=a.geometryState,r=a.localOrigin,A=e.neighborData.cornerNeighborData,
m=a.geometryInfo,x=m.outerEdges,E=m.boundingBox,f=a.tile,J="local"===a.tile.surface.view?.viewingMode,z=f.ellipsoid.radius,N=f.extentInRadians,R=f.horizontalScale;let P=0,Q=0,v=0;const g=()=>{const c=a.geometryState.clippingArea,H=f.extent,I=Ma.isSome(c)&&(H[3]>c[3]||H[2]>c[2]||H[1]<c[1]||H[0]<c[0]),G=Gc(f.surface.isWebMercatorOnPlateeCarree,f.ellipsoid.radius,R);return(S,D,F)=>{S=0===S?u[0]:u[2];D=0===D?u[1]:u[3];S=I?T.clamp(S,c[0],c[2]):S;D=I?T.clamp(D,c[1],c[3]):D;P=S*R;Q=G(D);v=F}},V=(c,H,I)=>
{var G=N[0===H?1:3];c=N[0===c?0:2];H=Math.cos(G);G=Math.sin(G);const S=Math.sin(c);I=z+I;P=Math.cos(c)*H*I;Q=S*H*I;v=G*I},W=J?g():V;let K=0,n=0,d=0,h=0,q=0,k=0,l=0,p=0,C=0;const t=J&&a.tile.surface.isWebMercatorOnPlateeCarree,y=(c,H,I,G,S)=>{var D=0,F=0;let X=0;J?(I=t?(Math.PI/2-2*Math.atan(Math.exp(-I/z)))*z:I*R,D=H*R-P,F=I-Q,X=G-v):(D=Eb(c),c=c.tile,F=c.extent,c=c.extentInRadians,H=(H-F[0])/(F[2]-F[0]),H=c[0]*(1-H)+c[2]*H,D=D((I-F[1])/(F[3]-F[1])),I=Math.cos(D),c=Math.sin(D),F=Math.sin(H),G=z+G,
D=Math.cos(H)*I*G-P,F=F*I*G-Q,X=c*G-v);switch(S){case 0:l+=D;p+=F;C+=X;break;case 1:h-=D;q-=F;k-=X;break;case 2:l-=D;p-=F;C-=X;break;case 3:h+=D,q+=F,k+=X}},u=f.extent,b=e.clippingArea,w=Ma.isSome(b)?b:Vb,L=u[0],M=u[2],Y=u[1],Z=u[3],O=[Z>w[3],M>w[2],Y<w[1],L<w[0]],aa=Math.max(L,w[0]),U=Math.min(M,w[2]),ba=Math.max(Y,w[1]),ca=Math.min(Z,w[3]),na=m.uvRange[0],ra=m.uvRange[1],ja=m.uvRange[2],va=m.uvRange[3],oa=c=>{c=A[c].cornerTiles;n=K=0;d=1;var H=Infinity;for(var I=0;4>I;++I)H=Math.min(H,c[I]?.level??
Infinity);for(I=0;4>I;++I){var G=c[I];yb[I]=G?.level===H?G:null}c=1;H=0;for(I=0;4>I;++I)if(G=yb[I])c=Math.max(c,G?.renderData.geometryState.numVerticesPerSide),H=G.extent[2]-G.extent[0];B.internalAssert(1<c);c=H/c;for(H=0;4>H;++H){var S=yb[(H+3)%4],D=yb[H%4];if(S||D){G=0===H?1:1===H?2:2===H?3:0;var F=0===H?2:1===H?3:2===H?0:1;if(S&&D){var X=Wb[H][0]*c,Ba=Wb[H][1]*c,ka=S.extent;I=ka[0===G||1===G?2:0]+X;G=ka[0===G||3===G?3:1]+Ba;ka=D.extent;X=ka[0===F||1===F?2:0]+X;F=ka[0===F||3===F?3:1]+Ba;S=S.renderData;
Ba=D.renderData;D=ha.sampleElevation(I,G,S.geometryState.samplerData);F=ha.sampleElevation(X,F,Ba.geometryState.samplerData);y(S,I,G,.5*(D+F),H)}else I=S??D,S=S?G:F,D=I.extent,F=Wb[H],G=D[0===S||1===S?2:0]+F[0]*c,S=D[0===S||3===S?3:1]+F[1]*c,I=I.renderData,D=ha.sampleElevation(G,S,I.geometryState.samplerData),y(I,G,S,D,H)}}J||(c=Math.sqrt(P*P+Q*Q+v*v),K=P/c,n=Q/c,d=v/c);c=Math.sqrt(h*h+q*q+k*k);h/=c;q/=c;k/=c;c=Math.sqrt(l*l+p*p+C*C);l/=c;p/=c;C/=c;if(J||.999>d*d)K=k*p-q*C,n=h*C-k*l,d=q*l-h*p,c=1/
Math.sqrt(K*K+n*n+d*d),K*=c,n*=c,d*=c};for(let c=0;4>c;++c){const H=c,I=(c+1)%4,G=0===c||1===c?1:0,S=0===c||3===c?1:0,D=T.clamp(G,na,ja),F=T.clamp(S,ra,va),X=x[H],Ba=0===c||3===c?X.count-1:0,ka=x[I],cb=0===c||1===c?ka.count-1:0,wa=A[c].cornerTiles;let Oa=-1;for(let sa=0;4>sa;++sa){const pa=wa[sa];pa&&(-1===Oa||0<zb.compareTilesByLij(wa[Oa],pa))&&(Oa=sa)}const Ca=Oa,xa=wa[Ca],Ta=xa!==f;n=K=0;d=1;if(Ta){const sa=f.level-xa.level,pa=2**sa,Ha=[xa.lij[0]+sa,xa.lij[1]*pa,xa.lij[2]*pa],ta=[Ha[1]+pa===f.lij[1],
0===c&&(1===Ca||0===Ca&&xa!==wa[3])||1===c&&(0===Ca||1===Ca&&xa!==wa[2]),Ha[1]===f.lij[1]+1,2===c&&(3===Ca||2===Ca&&xa!==wa[1])||3===c&&(2===Ca||3===Ca&&xa!==wa[0])],ya=ta.reduce((ma,Ja)=>ma+(Ja?1:0),0);B.internalAssert(1===ya||2===ya);let za=-1,Ka=-1;const Ua=xa.renderData;if(1===ya){const ma=ta.findIndex(fb=>fb);B.internalAssert(0<=ma&&3>=ma);za=(ma+2)%4;const Ja=a.geometryState.neighborData.edgeResolutions[ma];Ka=f.getNeighborEdgeStartVertexIndex(ma,xa)*Ja+Ja*(0===ma&&0===c||1===ma&&0===c||2===
ma&&1===c||3===ma&&3===c?1:0)}else{B.internalAssert(ta[1]||ta[3]);za=ta[1]?3:1;const ma=Ua.geometryState.neighborData.edgeResolutions[za];Ka=0===c||3===c?0:ma}const Da=Ua.geometryInfo.outerEdges[za],ia=X.index0+Ba*X.stride,ea=ka.index0+cb*ka.stride,qa=Da.index0+Ka*Da.stride,Ia=Da.attributes.position,fa=Ia.typedBuffer,db=qa*Ia.typedBufferStride,gb=a.localOrigin,hb=Da.localOrigin,Ya=fa[db]+hb[0]-gb[0],eb=fa[db+1]+hb[1]-gb[1],Va=fa[db+2]+hb[2]-gb[2];da.minMaxBoundingBox(Ya,eb,Va,E);const Za=X.attributes.position,
$a=Za.typedBuffer,ab=ia*Za.typedBufferStride;$a[ab]=Ya;$a[ab+1]=eb;$a[ab+2]=Va;const Wa=ka.attributes.position,Pa=Wa.typedBuffer,Na=ea*Wa.typedBufferStride;Pa[Na]=Ya;Pa[Na+1]=eb;Pa[Na+2]=Va;da.encodeUVInBuffer(X.attributes.uv0,ia,D,F);da.encodeUVInBuffer(ka.attributes.uv0,ea,D,F);const Qa=Da.attributes.normalCompressed.typedBuffer,la=qa*Da.attributes.normalCompressed.typedBufferStride,La=X.attributes.normalCompressed,Fa=La.typedBuffer,Ea=ia*La.typedBufferStride;Fa[Ea]=Qa[la];Fa[Ea+1]=Qa[la+1];const Aa=
ka.attributes.normalCompressed,Ra=Aa.typedBuffer,Ga=ea*Aa.typedBufferStride;Ra[Ga]=Qa[la];Ra[Ga+1]=Qa[la+1]}else{const sa=O[I];let pa=void 0;if(O[H]||sa){const za=T.clamp(L*(1-G)+M*G,aa,U),Ka=T.clamp(Y*(1-S)+Z*S,ba,ca);pa=ha.sampleElevation(za,Ka,e.samplerData)}else pa=Wc(wa);W(G,S,pa);oa(c);const Ha=P-r[0],ta=Q-r[1],ya=v-r[2];da.minMaxBoundingBox(Ha,ta,ya,E);X.setVertexFromValuesRawPositionUVNormal(Ba,Ha,ta,ya,D,F,K,n,d);ka.setVertexFromValuesRawPositionUVNormal(cb,Ha,ta,ya,D,F,K,n,d)}}for(let c=
0;4>c;++c)yb[c]=null}function Wc(a){const e=a.reduce((x,E)=>Math.min(x,E?.level??Infinity),Infinity);B.ENABLE_TERRAIN_INTERNAL_CHECKS&&(B.internalAssert(!a[0]||!a[2]||Zb.isCornerNeighbor(a[0],a[2],pb.NeighborIndex.SOUTH_WEST)),B.internalAssert(!a[1]||!a[3]||Zb.isCornerNeighbor(a[1],a[3],pb.NeighborIndex.NORTH_WEST)));let r=0,A=0;for(let x=0;4>x;++x){var m=a[x];if(m&&m.level===e){const E=m.extent;m=ha.sampleElevation(E[0===x||1===x?0:2],E[0===x||3===x?1:3],m.renderData?.geometryState?.samplerData);
A+=m;r++}}a=r?A/r:0;B.internalAssert(null!=a);return a}function Db(a){const e=a.geometryInfo.vertexAttributes.position.typedBuffer;a.vao.vertexBuffers.geometry.setSubData(e,0,0,e.length)}function bc(a,e,r){if(!e)return!1;a=zb.compareTilesByLij(a,e);return 0<a||0===a&&2<=r}const Wb=[[0,1],[1,0],[0,-1],[-1,0]],ua=new Lc.PatchGeometryLUT,Vb=Kc.fromValues(-Infinity,-Infinity,Infinity,Infinity),yb=[null,null,null,null];lb.createPlanarGlobePatch=function(a,e){var r=a.tile.extent;e=a.geometryState;var A=
r[0],m=r[1],x=r[2]-A,E=r[3]-m,f=e.clippingArea;r=Ma.isSome(f)?Math.max(0,(f[0]-A)/x):0;const J=Ma.isSome(f)?Math.max(0,(f[1]-m)/E):0;A=Ma.isSome(f)?Math.min(1,(f[2]-A)/x):1;m=Ma.isSome(f)?Math.min(1,(f[3]-m)/E):1;x=e.numVerticesPerSide;E=(x-2)**2;f=e.neighborData.edgeResolutions.reduce((N,R)=>N+R+1,0);f=da.acquireTerrainAttributes(E+f);const z=a.geometryInfo;Xb.empty(z.boundingBox);z.numVerticesPerSide=e.numVerticesPerSide;z.vertexAttributes=f;Jc.set(z.uvRange,r,J,A,m);Vc(a);Ic(a,E);Ec(a);Hc(z,e.numVerticesPerSide,
[],[0,x-1],[0,x-1],e.wireframe);a.intersectionData=null};lb.createSphericalGlobePatch=function(a,e){const r=a.tile,{extent:A,extentInRadians:m,surface:x}=r,E=a.localOrigin,f=a.geometryState;var J=x.isWebMercator;const z=f.numVerticesPerSide,N=z-1,R=(z-2)**2,P=J&&(e===pb.PatchType.HAS_SOUTH_POLE||e===pb.PatchType.HAS_BOTH_POLES),Q=J&&(e===pb.PatchType.HAS_NORTH_POLE||e===pb.PatchType.HAS_BOTH_POLES);J=6*((P?1:0)+(Q?1:0))*(N+1);e=f.neighborData;const v=e.edgeResolutions.reduce((n,d)=>n+d+1,0),g=da.acquireTerrainAttributes(R+
J+v);J=a.geometryInfo;J.numVerticesPerSide=f.numVerticesPerSide;J.vertexAttributes=g;const V=J.boundingBox;Xb.empty(V);const W=Eb(a);ua.update(N,m,W);Mc(a);Ic(a,R);$b(a);const K=[];(()=>{let n=R+v;const d=E[0],h=E[1],q=E[2],k=r.ellipsoid.radius,l=A[1],p=A[3],C=(t,y)=>{y*=z;da.minMaxBoundingBox(-d,-h,-q+t*k,V);K.push({connectedRowOffset:y,connectedOuterEdgeOffset:1===t?0:2,rowOffset:n,latitudeResolution:6});y=Math.PI/2-2*Math.atan(Math.exp(-(-1===t?l:p)/k));const u=t*Math.PI/2-y;t=.99*(1===t?1:-1);
const b=k+0,w=g.position,L=g.uv0,M=g.normalCompressed;for(let Z=1;6>=Z;++Z){var Y=y+Z/6*u;const O=Math.cos(Y);Y=Math.sin(Y);for(let aa=0;aa<=N;aa++){const U=aa/N,ba=ua.cosLonLUT[aa]*O,ca=ua.sinLonLUT[aa]*O,na=Y,ra=ba*b-d,ja=ca*b-h,va=na*b-q;da.minMaxBoundingBox(ra,ja,va,V);w.setValues(n,ra,ja,va);da.encodeUVInBuffer(L,n,U,t);da.encodeNormalInBuffer(M,n,ba,ca,na);++n}}};P&&C(-1,0);Q&&C(1,N)})();Hc(J,f.numVerticesPerSide,K,[0,z-1],[0,z-1],f.wireframe);a.intersectionData=null;if(B.ENABLE_TERRAIN_INTERNAL_CHECKS)for(a=
0;4>a;++a)B.internalAssert(J.outerEdges[a].count===e.edgeResolutions[a]+1)};lb.updateCornerSpherical=function(a){a.tile.intersectsClippingArea&&(Ab(a),ac(a,!0),Db(a))};lb.updateCornersPlanar=function(a,e){a.tile.intersectsClippingArea&&(Ab(a),Fc(a,!0),Db(a))};lb.updateEdgesAndCornersPlanar=function(a,e){a.tile.intersectsClippingArea&&(Ec(a),Db(a))};lb.updateEdgesAndCornersSpherical=function(a){a.tile.intersectsClippingArea&&($b(a),Db(a))};Object.defineProperty(lb,Symbol.toStringTag,{value:"Module"})});