// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.27/esri/copyright.txt for details.
//>>built
define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../core/mathUtils ../../../chunks/vec3 ../../../chunks/vec3f64 ../../../geometry/projection ../../../geometry/support/DoubleArray ../../../geometry/support/frustum ../../../chunks/sphere ./interfaces ./PatchGeometryFactory ./terrainUtils ./Tile ./tileUtils".split(" "),function(ea,T,fa,g,m,qa,ra,ca,sa,J,da,C,R,ta){function ha(n,y,K,b,a,d){n=b-n;y=a-y;K=d-K;return n*n+y*y+K*K}let wa=function(n){function y(b,a,d){var e=K.call(this);e._convexHull=
Array(24);e._boundingSphere=sa.create();void 0!==b&&e.init(b,a,d);return e}T._inherits(y,n);var K=T._createSuper(y);n=y.prototype;n.init=function(b,a,d){T._get(T._getPrototypeOf(y.prototype),"init",this).call(this,b,a,d);a=this.ellipsoid.radius;d=this.extentInRadians[0];const e=this.extentInRadians[1],c=this.extentInRadians[2],f=this.extentInRadians[3];b=b[0];const z=fa.lerp(e,f,.5),l=fa.lerp(d,c,.5);this._edgeLen=(c-d)*Math.cos(0===b?0:Math.min(Math.abs(e),Math.abs(f)))*a;this._edgeLen2=this._edgeLen*
this._edgeLen;this._curvatureHeight=a-Math.sqrt(a*a-this._edgeLen2/4);qa.lonLatToSphericalPCPF(this.centerAtSeaLevel,l,z,this.ellipsoid.radius);g.normalize(this.up,this.centerAtSeaLevel);this.updateRadiusAndCenter()};n.updateRadiusAndCenter=function(){this._updateBoundingVolumes();const b=this._center;if(0===this.lij[0])g.set(b[R.CenterPosition.MIDDLE],0,0,0),g.set(b[R.CenterPosition.TOP],0,0,0),g.set(b[R.CenterPosition.BOTTOM],0,0,0),b[R.CenterPosition.MIDDLE][3]=this.ellipsoid.radius+this.elevationBounds[1];
else{this._updateCenter();const f=b[R.CenterPosition.MIDDLE],z=this.convexHull;var a=0;for(let l=0;8>l;++l){var d=Math,e=d.max;var c=3*l;c=ha(f[0],f[1],f[2],z[c],z[c+1],z[c+2]);a=e.call(d,a,c)}b[R.CenterPosition.MIDDLE][3]=Math.sqrt(a)}};n._calculateFrustumVisibilityStatus=function(b){if(!ca.intersectsSphere(b,this._boundingSphere))return J.TileFrustumVisibility.OUTSIDE;if(10>this.lij[0])return J.TileFrustumVisibility.INTERSECTS;const a=this.convexHull,d=this.surface.view.state.camera.near;let e=
!0;for(let f=0;f<ca.NumPlanes.NUM;f++){var c=b[f];const z=c[0],l=c[1],E=c[2];c=c[3]-(f===ca.PlaneIndex.NEAR?d:0);let G=!1;for(let L=0;8>L;++L){const A=3*L;if(0>z*a[A]+l*a[A+1]+E*a[A+2]+c){if(G=!0,!e)break}else e=!1}if(!G)return J.TileFrustumVisibility.OUTSIDE}return e?J.TileFrustumVisibility.INSIDE:J.TileFrustumVisibility.INTERSECTS};n.computeElevationBounds=function(){T._get(T._getPrototypeOf(y.prototype),"computeElevationBounds",this).call(this);this._updateBoundingVolumes()};n.createGeometry=function(){da.createSphericalGlobePatch(this.renderData,
this._getPatchType());this._updateBoundingVolumes();this.setMemoryDirty()};n._updateBoundingVolumes=function(){this._updateConvexHull();this._updateBoundingSphere();C.ENABLE_TERRAIN_INTERNAL_CHECKS&&this._checkBVs()};n._updateBoundingSphere=function(){const b=this._boundingSphere;var a=this.elevationBounds,d=this.ellipsoid.radius,e=a[1];if(0===this.level)g.set(b,0,0,0),b[3]=d+e;else{e=this.extentInRadians;var c=.5*(e[0]+e[2]),f=e[3];N(ia,c,e[1],d);N(ja,c,f,d);g.add(b,ia,ja);g.scale(b,b,(d+.5*(a[0]+
a[1]))/g.len(b));a=this.convexHull;d=0;for(e=0;8>e;++e){c=b[0]-a[3*e];f=b[1]-a[3*e+1];const z=b[2]-a[3*e+2];d=Math.max(d,Math.sqrt(c*c+f*f+z*z))}b[3]=d+2}};n._updateConvexHull=function(){var b=this.extentInRadians,a=this.ellipsoid.radius;if(0!==this.level){var d=this.elevationBounds,e=this._getPatchType(),c=this.surface.isWebMercator,f=c&&e===J.PatchType.HAS_NORTH_POLE,z=(e=c&&e===J.PatchType.HAS_SOUTH_POLE)||f;c=Math.PI/2;var l=b[0],E=b[2];e=e?-c:b[1];var G=f?c:b[3],L=.5*(l+E);b=d[0];var A=a+(z?
Math.min(0,b-1):b);b=m.create();f=m.create();c=m.create();var M=m.create();N(b,l,e,A);N(f,l,G,A);N(c,E,G,A);N(M,E,e,A);l=(F,w)=>{for(let H=0;3>H;++H)this._convexHull[3*w+H]=F[H]};l(b,0);l(f,1);l(c,2);l(M,3);d=d[1];var Z=a+(z?Math.max(0,d+1):d),h=m.create();a=m.create();d=m.create();N(a,L,G,A);N(d,L,e,A);g.add(h,a,d);g.normalize(h,h);var x=m.create(),D=m.create();e=(F,w)=>{g.sub(D,F,w);g.normalize(D,D);w=-g.dot(F,x)/g.dot(D,x);C.internalAssert(0<=w);g.scale(D,D,w);g.add(F,F,D)};2**this.lij[0]>2*this.lij[1]?
(a=m.create(),g.cross(a,ka,d),g.normalize(a,a),g.cross(x,d,a),g.normalize(x,x),C.internalAssert(C.almostEquals(g.dot(x,d)/g.len(d),0)),e(b,f),e(M,c),l(b,0),l(M,3)):2**this.lij[0]!==2*this.lij[1]&&(d=m.create(),g.cross(d,ka,a),g.normalize(d,d),g.cross(x,d,a),g.normalize(x,x),e(f,b),e(c,M),l(f,1),l(c,2));a=(F,w)=>{const H=Z/g.dot(w,h);for(let O=0;3>O;++O)this._convexHull[3*F+O]=w[O]*H};a(4,b);a(5,f);a(6,c);a(7,M)}};n._getPatchType=function(){const b=this.lij[1],a=b===(1<<this.level)-1;return 0===b?
a?J.PatchType.HAS_BOTH_POLES:J.PatchType.HAS_NORTH_POLE:a?J.PatchType.HAS_SOUTH_POLE:J.PatchType.REGULAR};n.intersectsRay=function(b,a,d,e){var c=this._boundingSphere;d=c[3]+d;var f=c[0]-b[0];e=c[1]-b[1];b=c[2]-b[2];c=(f*a[0]+e*a[1]+b*a[2])/(a[0]*a[0]+a[1]*a[1]+a[2]*a[2]);f=a[0]*c-f;e=a[1]*c-e;a=a[2]*c-b;return f*f+e*e+a*a<d*d};n.getDefaultVerticesPerSide=function(){return this.level<la.length?la[this.level]+1:2};n.updateCornerElevations=function(){da.updateCornerSpherical(this.renderData);this._updateBoundingVolumes()};
n.updateEdgeElevations=function(){da.updateEdgesAndCornersSpherical(this.renderData);this._updateBoundingVolumes()};n._checkBVs=function(){if(C.ENABLE_TERRAIN_INTERNAL_CHECKS&&!(2>=this.level)){var b=this._boundingSphere,a=b[3],d=m.create(),e=this.ellipsoid.radius,c=this.elevationBounds;c[1]-c[0];var f=e+c[0],z=this._center[R.CenterPosition.MIDDLE][3],l=this.convexHull,E=(k,r)=>{for(let p=0;3>p;++p)k[p]=l[3*r+p]},G=m.create(),L=m.create(),A=m.create(),M=m.create(),Z=m.create(),h=(k,r,p,I)=>{E(L,k);
E(A,r);E(M,p);g.sub(L,L,A);g.sub(M,M,A);g.cross(G,L,M);g.normalize(G,G);var W=g.dot(G,A);E(Z,I);const aa=g.dot(G,Z);W=Math.abs(aa-W);C.internalAssert(C.almostEquals(W,0),`Non coplanar ${k},${r},${p},${I} diff = ${W}`)};h(0,1,2,3);h(4,5,6,7);h(0,1,4,5);h(1,2,5,6);h(2,3,6,7);h(3,0,7,4);var x=ra.newDoubleArray(24),D=m.create(),F=m.create(),w=m.create(),H=m.create();h=(k,r,p,I)=>{E(D,r);E(F,p);E(w,I);g.sub(D,D,F);g.normalize(D,D);g.sub(w,w,F);g.normalize(w,w);g.cross(H,D,w);g.normalize(H,H);r=g.dot(H,
F);k*=4;for(p=0;3>p;++p)x[k+p]=H[p];x[k+3]=r};h(0,0,1,2);h(1,1,0,4);h(2,1,5,2);h(3,3,2,6);h(4,4,0,3);h(5,4,6,5);var O=(k,r,p,I)=>{k*=4;return x[k]*r+x[k+1]*p+x[k+2]*I-x[k+3]},B=(k,r,p,I)=>-1<=O(k,r,p,I),P=2**this.lij[0]>2*this.lij[1];h=(k,r,p)=>Math.sqrt(ha(k,r,p,b[0],b[1],b[2]))<a;var q=this.extentInRadians,u=.5*(q[0]+q[2]),S=q[1],t=q[3];q=m.create();var v=m.create();N(q,u,t,f);N(v,u,S,f);f=P?"Upper":"Lower";P=!0;for(u=0;6>u;++u){for(S=0;8>S;++S)t=3*S,t=-1<=O(u,l[t],l[t+1],l[t+2]),P&&(P=t),C.internalAssert(t,
`Tile[${this.lij}] Convex hull point ${S} outside of plane ${u}`);C.internalAssert(B(u,v[0],v[1],v[2]),`Tile[${this.lij}] (${f}) bottom mid outside of plane ${u}`);C.internalAssert(B(u,q[0],q[1],q[2]),`Tile[${this.lij}] (${f}) top mid outside of plane ${u}`)}C.internalAssert(P,"Not all convex hull points are inside  convex hull polyhedron");C.internalAssert(h(v[0],v[1],v[2]),`Tile[${this.lij}] (${f}) bottom mid outside of bounding sphere`);C.internalAssert(h(q[0],q[1],q[2]),`Tile[${this.lij}] (${f}) top mid outside of bounding sphere`);
for(B=0;8>B;++B)q=3*B,q=h(l[q],l[q+1],l[q+2]),C.internalAssert(q,`Tile[${this.lij}] Convex hull point ${B} outside of bounding sphere`);for(h=0;6>h;++h)for(B=0;8>B;++B)q=3*B,-1<=O(h,l[q],l[q+1],l[q+2])||console.error(`Tile[${this.lij}] Convex hull point ${B} outside of plane ${h}`);h=this.extentInRadians;h=Math.round(Math.max(h[2]-h[0],h[3]-h[1])*e);if(u=this.renderData){var {geometryInfo:ma,localOrigin:ua}=u;if(B=ma.vertexAttributes?.position){q=B.count;v=m.create();f=ma.numVerticesPerSide-2;P=f*
f;u=u.geometryState.neighborData;S=u.edgeResolutions.reduce((k,r)=>k+r+1,0);for(let k=0;k<q;++k){const r=k<P,p=!r&&k<P+S;let I=!1;t=-1;if(p){var U=P;for(var V=0;4>V;++V){var Y=u.edgeResolutions[V];if(k===U||k===U+Y-1){I=!0;break}U+=Y;if(k<U){t=V;break}}}t=p?u.edgePeerNeighbors[t]:null;const W=p&&t&&0<ta.compareTilesByLij(this,t);B.getVec(k,d);g.add(v,d,ua);t=g.len(v)-e;U=0;V=!1;Y=c[0]-t;const aa=t-c[1],na=1<Y,oa=1<aa;var Q=na||oa;const pa=()=>{const ba=p&&!I;return`Tile[${this.lij}].vertex[${k}]:${r?
"internal":ba?"edge":I?"corner":"pole"}`+(na?"(below)":oa?"(above)":"")+(W?"(Neighbor)":"")};var X=g.dist(v,b);X>=a+0&&(X-=a,Q||(console.error(`${pa()} is out of the bounding sphere by ${X.toFixed(0)} / ${a.toFixed(0)}`+"[tol\x3d0]"+` h=${t.toFixed(0)} / [${c[0].toFixed(0)}..${c[1].toFixed(0)}] (${(X/a).toFixed(0)})`),V=!0));for(Q=0;6>Q;++Q)if(!(-1<=O(Q,v[0],v[1],v[2]))){X=O(Q,v[0],v[1],v[2]);const ba=k%f,va=(k-ba)/f;0===Q&&Y||5===Q&&aa||(console.error(`${pa()} (${ba},${va})|${f}] is out of the bounding trapezoid plane ${Q}`+
` h=${Math.round(t)} / [${Math.round(c[0])}..${Math.round(c[1])}] dist=${Math.round(X)}`+` radii = ${Math.round(a)}/${Math.round(z)}} : maxL = ${h}`),++U)}if(V||0<U)break}}}}};T._createClass(y,[{key:"convexHull",get:function(){return this._convexHull}}]);return y}(R.Tile);const la=[128,64,64,32,16,8,8,4],N=(n,y,K,b)=>{const a=Math.sin(y),d=Math.cos(K);K=Math.sin(K);n[0]=b*d*Math.cos(y);n[1]=b*d*a;n[2]=b*K},ka=[0,0,1],ia=m.create(),ja=m.create();ea.SphericalPatch=wa;Object.defineProperty(ea,Symbol.toStringTag,
{value:"Module"})});