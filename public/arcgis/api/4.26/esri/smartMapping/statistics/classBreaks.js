// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.27/esri/copyright.txt for details.
//>>built
define("../../core/Error ../../core/maybe ./support/utils ../support/binningUtils ../support/utils ../support/adapters/support/layerUtils".split(" "),function(c,t,g,u,n,f){async function v(a){if(!a||!a.layer||!a.field&&!a.valueExpression)throw new c("class-breaks:missing-parameters","'layer' and 'field' or 'valueExpression' parameters are required");if(a.valueExpression&&!a.view)throw new c("class-breaks:missing-parameters","View is required when 'valueExpression' is specified");a.forBinning&&u.verifyBinningParams(a,
"class-breaks");const {layer:h,...k}=a;var b=a.forBinning?f.binningCapableLayerTypes:f.featureCapableLayerTypes;a=f.createLayerAdapter(h,b,a.forBinning);if(!a)throw new c("class-breaks:invalid-parameters","'layer' must be one of these types: "+f.getLayerTypeLabels(b).join(", "));b={layerAdapter:a,...k};b.normalizationType=n.getNormalizationType(b);b.numClasses=b.numClasses||5;var d=t.isSome(b.signal)?{signal:b.signal}:null;await a.load(d);var e=b.field;d=b.minValue;const l=b.maxValue,w=null!=d||null!=
l,p=b.classificationMethod,q="percent-of-total"===b.normalizationType,r=!1!==b.analyzeData;e=e?a.getField(e):null;var m=await n.getFieldsList({field:b.field,normalizationField:b.normalizationField,valueExpression:b.valueExpression});if(m=g.verifyBasicFieldValidity(a,m,"class-breaks:invalid-parameters"))throw m;if(e&&(a=g.verifyNumericField(a,e,"class-breaks:invalid-parameters")))throw a;if(b.valueExpression&&b.normalizationType)throw new c("class-breaks:invalid-parameters","Normalization is not allowed when 'valueExpression' is specified");
if(w)if(r){if(q&&null==b.normalizationTotal)throw new c("class-breaks:missing-parameters","'normalizationTotal' is required when 'normalizationType' is 'precent-of-total' and 'minValue', 'maxValue' are specified");}else{if(null==d||null==l)throw new c("class-breaks:missing-parameters","Both 'minValue' and 'maxValue' are required when 'analyzeData' is false");if(d>=l)throw new c("class-breaks:invalid-parameters","'minValue' should be less than 'maxValue'");if(p&&"equal-interval"!==p)throw new c("class-breaks:invalid-parameters",
"'classificationMethod' other than 'equal-interval' is not allowed when 'analyzeData' is false");if(q&&null==b.normalizationTotal)throw new c("class-breaks:missing-parameters","'normalizationTotal' is required when 'normalizationType' is 'precent-of-total' and 'analyzeData' is false");}else if(!r)throw new c("class-breaks:missing-parameters","Both 'minValue' and 'maxValue' are required when 'analyzeData' is false");if(a=g.verifyFilterValidty(b.filter,"class-breaks:invalid-parameters"))throw a;return b}
return async function(a){const {layerAdapter:h,...k}=await v(a);return h.classBreaks(k)}});