// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.27/esri/copyright.txt for details.
//>>built
define("exports ../../../geometry ../../../core/Error ../../../core/maybe ../../../core/screenUtils ../../../geometry/SpatialReference ../../../geometry/support/quantizationUtils ../../../geometry/support/spatialReferenceUtils ../../../layers/support/fieldUtils ../../../renderers/support/heatmapUtils ../../../statistics/utils ../../../support/arcadeOnDemand ../../../geometry/Point".split(" "),function(q,R,v,C,H,I,J,D,E,F,y,K,L){function G(a,b){a=C.isSome(a)?a:"";C.isSome(b)&&b&&(a=a?"("+a+") AND ("+
b+")":b);return a}function M(a){const b=a.layer;return a.fields.filter(c=>!b.getField(c))}function N(a){const b=a.layer;return a.fields.filter(c=>{c=b.getFieldUsageInfo(c);return!c||!c.supportsStatistics})}let x=null;q.calculateHeatmapStats=function(a,b=18,c,d,g,u){const n=new Float64Array(g*u);b=Math.round(H.pt2px(b));let e=Number.POSITIVE_INFINITY,k=Number.NEGATIVE_INFINITY;var f=0;let p=0,h=0,l=0;c=F.createValueFunction(d,c);for(const {geometry:z,attributes:w}of a){const {x:r,y:m}=z;a=Math.max(0,
r-b);f=Math.max(0,m-b);d=Math.min(u,m+b);const O=Math.min(g,r+b),P=+c(w);for(let A=f;A<d;A++)for(let B=a;B<O;B++){f=A*g+B;const Q=F.evaluateDensityKernel(B-r,A-m,b);var t=n[f];f=n[f]+=Q*P;t=f-t;p+=t;h+=t*t;f<e&&(e=f);f>k&&(k=f);l++}}return l?{mean:p/l,stdDev:Math.sqrt((h-p*p/l)/l),min:e,max:k,mid:(k-e)/2,count:l}:{mean:0,stddev:0,min:0,max:0,mid:0,count:0}};q.getDataValues=async function(a,b){if(!b)return[];const {field:c,field2:d,field3:g,fieldDelimiter:u}=a,n=a.valueExpression,e=a.normalizationType,
k=a.normalizationField,f=a.normalizationTotal,p=[],h=a.viewInfoParams;let l=null,t=null;if(n){if(!x){const {arcadeUtils:w}=await K.loadArcade();x=w}l=x.createFunction(n);t=h&&x.getViewInfo({viewingMode:h.viewingMode,scale:h.scale,spatialReference:new I(h.spatialReference)})}a=a.fieldInfos;const z=b[0]&&"declaredClass"in b[0]&&"esri.Graphic"===b[0].declaredClass||!a?null:{fields:a};b.forEach(w=>{var r=w.attributes;if(n){var m=x.createExecContext(z?{...w,layer:z}:w,t);m=x.executeFunction(l,m)}else r&&
(m=r[c],d&&(m=`${y.processNullValue(m)}${u}${y.processNullValue(r[d])}`,g&&(m=`${m}${u}${y.processNullValue(r[g])}`)));e&&"number"===typeof m&&isFinite(m)&&(r=r&&parseFloat(r[k]),m=y.getNormalizedValue(m,e,r,f));p.push(m)});return p};q.getRangeExpr=function(a,b,c){b=null!=b?a+" \x3e\x3d "+b:"";a=null!=c?a+" \x3c\x3d "+c:"";c="";return(c=b&&a?G(b,a):b||a)?"("+c+")":""};q.getSQLFilterForNormalization=function(a){const b=a.field,c=a.normalizationType;a=a.normalizationField;let d;if("field"===c)d="(NOT "+
a+" \x3d 0)";else if("log"===c||"natural-log"===c||"square-root"===c)d=`(${b} > 0)`;return d};q.getSumOfAttributesExpr=function(a,b,c){const d=[],g=[],u=[],n=[],e=[];a.forEach((p,h)=>{const l=p.field?"field":"expression",t=p.field||p.valueExpression;p.field?(e.push(t),g.push(`var ${l}${h} = Number($feature["${t}"]);`)):(d.push(`function getValueForExpr${h}() {\n  ${t} \n}`),g.push(`var ${l}${h} = Number(getValueForExpr${h}());`));c||u.push(`${l}${h} = IIf(${l}${h} < 0, 0, ${l}${h});`);n.push(`${l}${h}`)});
a="return sum;";const k=d.length?null:e.reduce((p,h)=>`${p} + ${h}`);let f=null;b||c?b?c||(a="return IIf(sum \x3e\x3d 0, sum, null);",k&&(f=`(( ${k} ) >= 0)`)):(a="return IIf(sum !\x3d 0, sum, null);",k&&(f=`(( ${k} ) <> 0)`)):(a="return IIf(sum \x3e 0, sum, null);",k&&(f=`(( ${k} ) > 0)`));return{valueExpression:[d.length?d.join("\n"):"",g.join("\n"),u.join("\n"),`var sum = ${n.join(" + ")};`,a].filter(Boolean).join("\n\n"),sqlExpression:k,sqlWhere:f}};q.mergeWhereClauses=G;q.quantizeFeatures=function(a,
b,c,d){const g=D.isWrappable(c)?D.getInfo(c):null,u=g?Math.round((g.valid[1]-g.valid[0])/b.scale[0]):null;return a.map(n=>{const e=new L(C.unwrap(n.geometry));J.quantizePoint(b,e,e,e.hasZ,e.hasM);if(g){var k=u??0,f=d[0];0>e.x?e.x+=k:e.x>f&&(e.x-=k)}n.geometry=e;return n})};q.verifyBasicFieldValidity=function(a,b,c){const d=M({layer:a,fields:b});if(d.length)return new v(c,"Unknown fields: "+d.join(", ")+". You can only use fields defined in the layer schema");a=N({layer:a,fields:b});if(a.length)return new v(c,
"Unsupported fields: "+a.join(", ")+". You can only use fields that can be fetched i.e. AdapterFieldUsageInfo.supportsStatistics must be true")};q.verifyFieldType=function(a,b,c,d){let g;b?b.name!==a.objectIdField&&d.includes(b.type)||(g=new v(c,"'field' should be one of these types: "+d.join(","))):g=new v(c,"'field' is not defined in the layer schema");return g};q.verifyFilterValidty=function(a,b){if(a&&"intersects"!==a.spatialRelationship)return new v(b,"Only 'intersects' spatialRelationship is supported for featureFilter")};
q.verifyNumericField=function(a,b,c){let d;b?b.name!==a.objectIdField&&E.isNumericField(b)||(d=new v(c,"'field' should be one of these numeric types: "+E.numericTypes.join(","))):d=new v(c,"'field' is not defined in the layer schema");return d};Object.defineProperty(q,Symbol.toStringTag,{value:"Module"})});