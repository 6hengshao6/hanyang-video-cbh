// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.27/esri/copyright.txt for details.
//>>built
define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/arrayUtils ../../../core/Error ../../../core/maybe ../../../core/promiseUtils ../../../core/Logger ../../../core/accessorSupport/ensureType ../../../core/has ../../../core/accessorSupport/decorators/subclass ../../../layers/support/fieldType ../../../layers/support/fieldUtils ../../statistics/support/predominanceUtils ../../statistics/support/statsWorker ../../statistics/support/utils ../../statistics/support/WorkerClient ../utils ./FeatureLayerAdapter ./support/utils".split(" "),
function(y,F,G,p,B,H,z,P,Q,I,J,C,K,u,L,M,D,N,q){z=function(k){function w(a){return O.call(this,a)}y._inherits(w,k);var O=y._createSuper(w);k=w.prototype;k._getNormalizationTotalFromMemory=async function(a,b,c){const {featuresJSON:e,graphics:n,layerView:g,query:l}=b;a=(!e&&!n&&g&&"queryAggregateSummaryStatistics"in g?await g.queryAggregateSummaryStatistics(l,{field:a},{signal:c}):e?await this.workerClient.summaryStatistics({field:a},e):await u.summaryStatistics({attribute:{field:a},features:n})).sum;
if(null==a)throw new p("feature-layer-binning-adapter:invalid","invalid normalizationTotal");return a};k._processStatsFromMemoryParams=async function(a){const {features:b,filter:c}=a;if(b?.length)return this._getFilteredFeatures(b,c);const {view:e,field:n,field2:g,field3:l,normalizationField:d,valueExpression:f,returnGeometry:m,layerViewFunc:h,signal:t}=a;let r=a=null,v=null,A=null,E=null;if(e)try{if(a=await e.whenLayerView(this.layer),r=null!=h&&h in a&&"function"===typeof a[h]){await this._waitForLayerViewUpdate(a);
const x=await D.getFieldsList({field:n,field2:g,field3:l,normalizationField:d,valueExpression:f});q.getMissingFieldsForBinning(this,x).length?r=!1:(v="createAggregateQuery"in a?a.createAggregateQuery():null)?(v.outFields=x,v.returnGeometry=!1,this._updateQueryWithFeatureFilter(v,c)):r=!1;a.suspended&&(r=!1)}}catch{r=!1}if(!r&&(E=q.getFeatureReductionFields(this.layer).map(x=>x.toJSON()),A=await this._fetchFeaturesForStats({field:n,field2:g,field3:l,valueExpression:f,normalizationField:d,returnGeometry:m,
filter:c,view:e,signal:t},"json"),!A?.length))throw new p("feature-layer-binning-adapter:insufficient-data","No features are available to calculate statistics");return{layerView:a,query:v,featuresJSON:A,fieldInfos:E}};k._summaryStatsFromMemory=async function(a,b){const {view:c,field:e,valueExpression:n,normalizationType:g,signal:l}=a,d={field:e,valueExpression:n,normalizationType:g,normalizationField:a.normalizationField,normalizationTotal:a.normalizationTotal,minValue:a.minValue,maxValue:a.maxValue},
{featuresJSON:f,graphics:m,layerView:h,query:t,fieldInfos:r}=await this._processStatsFromMemoryParams({...a,layerViewFunc:"queryAggregateSummaryStatistics"});n&&c&&(f||m)&&(d.fieldType=b?.type?J.kebabDict.toJSON(b.type):null,d.viewInfoParams=q.getViewInfoParams(c),d.fieldInfos=r);"percent-of-total"===g&&null==a.normalizationTotal&&(d.normalizationTotal=await this._getNormalizationTotalFromMemory(e,{featuresJSON:f,graphics:m,layerView:h,query:t},l));return!f&&!m&&h&&"queryAggregateSummaryStatistics"in
h?h.queryAggregateSummaryStatistics(t,d,{signal:l}):f?this.workerClient.summaryStatistics(d,f):u.summaryStatistics({attribute:d,features:m})};k._uvFromMemory=async function(a,b){const {view:c,field:e,valueExpression:n,returnAllCodedValues:g,signal:l}=a,{featuresJSON:d,graphics:f,layerView:m,query:h,fieldInfos:t}=await this._processStatsFromMemoryParams({...a,layerViewFunc:"queryAggregateUniqueValues"});a={field:e,field2:a.field2,field3:a.field3,fieldDelimiter:D.FIELD_DELIMITER,valueExpression:n,domains:b,
returnAllCodedValues:g};n&&c&&(d||f)&&(a.viewInfoParams=q.getViewInfoParams(c),a.fieldInfos=t);return!d&&!f&&m&&"queryAggregateUniqueValues"in m?m.queryAggregateUniqueValues(h,a,{signal:l}):d?this.workerClient.uniqueValues(a,d):u.uniqueValues({attribute:a,features:f})};k._histogramFromMemory=async function(a){const {view:b,field:c,valueExpression:e,signal:n}=a,{featuresJSON:g,graphics:l,layerView:d,query:f,fieldInfos:m}=await this._processStatsFromMemoryParams({...a,layerViewFunc:"queryAggregateHistogram"}),
h={field:c,valueExpression:e,normalizationType:a.normalizationType,normalizationField:a.normalizationField,normalizationTotal:a.normalizationTotal,minValue:a.minValue,maxValue:a.maxValue,standardDeviationInterval:a.standardDeviationInterval,classificationMethod:a.classificationMethod,numBins:a.numBins};e&&b&&(g||l)&&(h.viewInfoParams=q.getViewInfoParams(b),h.fieldInfos=m);"percent-of-total"===a.normalizationType&&null==a.normalizationTotal&&(h.normalizationTotal=await this._getNormalizationTotalFromMemory(c,
{featuresJSON:g,graphics:l,layerView:d,query:f},n));return!g&&!l&&d&&"queryAggregateHistogram"in d?d.queryAggregateHistogram(f,h,{signal:n}):g?this.workerClient.histogram(h,g):u.histogram({attribute:h,features:l})};k._classBreaksFromMemory=async function(a){const {view:b,field:c,valueExpression:e,signal:n}=a,{featuresJSON:g,graphics:l,layerView:d,query:f,fieldInfos:m}=await this._processStatsFromMemoryParams({...a,layerViewFunc:"queryAggregateClassBreaks"}),h={field:c,valueExpression:e,normalizationType:a.normalizationType,
normalizationField:a.normalizationField,normalizationTotal:a.normalizationTotal,minValue:a.minValue,maxValue:a.maxValue,standardDeviationInterval:a.standardDeviationInterval,classificationMethod:a.classificationMethod,numClasses:a.numClasses};e&&b&&(g||l)&&(h.viewInfoParams=q.getViewInfoParams(b),h.fieldInfos=m);"percent-of-total"===a.normalizationType&&null==a.normalizationTotal&&(h.normalizationTotal=await this._getNormalizationTotalFromMemory(c,{featuresJSON:g,graphics:l,layerView:d,query:f},n));
return!g&&!l&&d&&"queryAggregateClassBreaks"in d?d.queryAggregateClassBreaks(f,h,{signal:n}):g?this.workerClient.classBreaks(h,g):u.classBreaks({attribute:h,features:l})};k.getField=function(a=""){return q.getFeatureReductionFields(this.layer)?.find(b=>b.name.toLowerCase()===a?.toLowerCase())};k.getFieldUsageInfo=function(a){return this.getField(a)?{supportsLabelingInfo:!0,supportsRenderer:!0,supportsPopupTemplate:!0,supportsLayerQuery:!1,supportsStatistics:!0}:null};k.getFieldDomain=function(a,b){return null};
k.summaryStatistics=async function(a){var {field:b}=a;const c=b?this.getField(b):null,e=C.isDateField(c);b=a.sqlExpression&&!a.valueExpression&&!b;if(e||b)throw new p("feature-layer-binning-adapter:not-supported","Date field and sqlExpression are not supported");return this._summaryStatsFromMemory(a,c)};k.uniqueValues=async function(a){const b=await q.getDomainsForFields(a,this);return this._uvFromMemory(a,b)};k.histogram=async function(a){var {field:b}=a,c=b?this.getField(b):null;c=C.isDateField(c);
b=a.sqlExpression&&!a.valueExpression&&!b;if(c||b)throw new p("feature-layer-binning-adapter:not-supported","Date field and sqlExpression are not supported");return this._histogramFromMemory(a)};k.classBreaks=async function(a){return(!1!==a.analyzeData?this._classBreaksFromMemory(a):this._classBreaksFromInterpolation(a)).catch(()=>{H.throwIfAborted(a.signal);return this._classBreaksFromMemory(a)})};k.queryFeatureCount=async function(a){const b=await a.view?.whenLayerView(this.layer);if(!(b&&"queryAggregateCount"in
b&&b.queryAggregateCount))throw new p("feature-layer-binning-adapter:not-supported","LayerView is not supported.");await this._waitForLayerViewUpdate(b);const c=b.createAggregateQuery();c.where=L.mergeWhereClauses(c.where,a.whereClause);this._updateQueryWithFeatureFilter(c,a.filter);return b.queryAggregateCount(c,{signal:a.signal})};k.generateRenderer=function(a,b){throw new p("feature-layer-binning-adapter:not-supported","'generateRenderer' is not supported.");};k.heatmapStatistics=function(a){throw new p("feature-layer-binning-adapter:not-supported",
"'heatmapStatistics' is not supported.");};k.predominantCategories=async function(a){const {fields:b,view:c,signal:e}=a;a=K.getArcadeForPredominantCategory(b);a=await this._uvFromMemory({valueExpression:a,view:c,signal:e});return q.getPredominantCategoriesFromUVInfos(a.uniqueValueInfos,b)};k.getSampleFeatures=async function(a,b){const {view:c,sampleSize:e,requiredFields:n,returnGeometry:g,filter:l,signal:d}=a;if(!c)throw new p("feature-layer-binning-adapter:not-supported","'view' is required to get sample features for binning.");
if("3d"===c.type)throw new p("feature-layer-binning-adapter:not-supported","3d 'view' is not supported to get sample features for binning.");const f=await c.whenLayerView(this.layer);if(!("queryAggregateJSON"in f&&f.queryAggregateJSON&&"queryAggregates"in f&&f.queryAggregates))throw new p("feature-layer-binning-adapter:not-supported","LayerView is not supported.");await this._waitForLayerViewUpdate(f);if(q.getMissingFieldsForBinning(this,n).length)throw new p("feature-layer-binning-adapter:insufficient-data",
"Layer does not have required fields");b="json"===b;const m=f.createAggregateQuery();m.outSpatialReference=a.spatialReference||c&&c.spatialReference;m.returnGeometry=!!g;m.outFields=n;this._updateQueryWithFeatureFilter(m,l);({features:a}=b?await f.queryAggregateJSON(m,{signal:d}):await f.queryAggregates(m,{signal:d}));return a.length&&null!=e&&0<e&&e<=a.length?G.pickRandom(a,e,1):a};k.load=function(a){const b=this.layer.load(a).then(async c=>{this.geometryType="polygon";this.objectIdField=null;this._hasLocalSource=
this.supportsSQLExpression=!1;this.hasQueryEngine=!0;this.minScale=c.minScale;this.maxScale=c.maxScale;this.fullExtent=c.fullExtent;if("geometryType"in c&&"point"!==c.geometryType)throw new p("feature-layer-binning-adapter:invalid-parameters","Only 'point' geometry type is supported");c="featureReduction"in c?c.featureReduction:null;if("binning"!==c?.type&&"cluster"!==c?.type)throw new p("feature-layer-binning-adapter:invalid-parameters",`Feature reduction type ${c?.type} is not supported`);this.workerClient=
M.WorkerClient.getInstance();await this.workerClient.open(B.unwrap(B.unwrap(a).signal))});this.addResolvingPromise(b);return Promise.resolve(this)};return y._createClass(w)}(N);return z=F.__decorate([I.subclass("esri.smartMapping.support.adapters.FeatureLayerBinningAdapter")],z)});