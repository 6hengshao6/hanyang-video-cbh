// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.27/esri/copyright.txt for details.
//>>built
define("exports ../../renderers/ClassBreaksRenderer ../../renderers/DictionaryRenderer ../../renderers/DotDensityRenderer ../../renderers/HeatmapRenderer ../../renderers/PieChartRenderer ../../renderers/Renderer ../../renderers/SimpleRenderer ../../renderers/UniqueValueRenderer ../../renderers/support/jsonUtils ../../core/Error ../../core/maybe ../heuristics/outline ../heuristics/sizeRange ./support/utils ../support/binningUtils ../support/adapters/support/layerUtils ../symbology/location".split(" "),
function(p,B,C,D,E,F,G,t,H,I,h,m,u,v,f,w,k,n){async function x(b){if(!b||!b.layer)throw new h("location-renderer:missing-parameters","'layer' parameter is required");b.forBinning&&w.verifyBinningParams(b,"location-renderer");const a={...b,layer:b.layer};a.symbolType=a.symbolType||"2d";var c=b.forBinning?k.binningCapableLayerTypes:k.featureCapableLayerTypes;b=k.createLayerAdapter(a.layer,c,b.forBinning);if(!b)throw new h("location-renderer:invalid-parameters","'layer' must be one of these types: "+
k.getLayerTypeLabels(c).join(", "));a.layer=b;c=m.isSome(a.signal)?{signal:a.signal}:null;await b.load(c);c=b.geometryType;a.outlineOptimizationEnabled="polygon"===c?a.outlineOptimizationEnabled:!1;a.sizeOptimizationEnabled="point"===c||"multipoint"===c||"polyline"===c?a.sizeOptimizationEnabled:!1;if("mesh"===c)a.symbolType="3d-volumetric",a.colorMixMode=a.colorMixMode||"replace",a.edgesType=a.edgesType||"none";else{if("3d-volumetric-uniform"===a.symbolType&&"point"!==c)throw new h("location-renderer:not-supported",
"3d-volumetric-uniform symbols are supported for point layers only");if(a.symbolType.includes("3d-volumetric")&&(!a.view||"3d"!==a.view.type))throw new h("location-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'");}return a}async function y(b,a){let c=b.locationScheme,e=null;var d=null;d=await f.getBasemapInfo(b.basemap,b.view);e=m.isSome(d.basemapId)?d.basemapId:null;d=m.isSome(d.basemapTheme)?
d.basemapTheme:null;if(c)return{scheme:n.cloneScheme(c),basemapId:e,basemapTheme:d};if(b=n.getSchemes({basemap:e,basemapTheme:d,geometryType:a,worldScale:!!b.symbolType?.includes("3d-volumetric"),view:b.view}))c=b.primaryScheme,e=b.basemapId,d=b.basemapTheme;return{scheme:c,basemapId:e,basemapTheme:d}}p.createRenderer=async function(b){var a=await x(b);const c=a.layer.geometryType;b=await y(a,c);const e=b.scheme;if(!e)throw new h("location-renderer:insufficient-info","Unable to find location scheme");
const {view:d,layer:q,signal:r}=a,[g,l]=await Promise.all([a.outlineOptimizationEnabled?u({view:d,layer:q,signal:r}).catch(f.errorCallback):null,a.sizeOptimizationEnabled?v({view:d,layer:q,signal:r}).catch(f.errorCallback):null]),z=g&&g.opacity;a=new t({symbol:f.createSymbol(c,{type:a.symbolType,color:e.color,size:f.getSymbolSizeFromScheme(e,c),outline:f.getSymbolOutlineFromScheme(e,c,z),meshInfo:{colorMixMode:a.colorMixMode,edgesType:a.edgesType}})});g&&g.visualVariables&&g.visualVariables.length&&
(a.visualVariables=g.visualVariables.map(A=>A.clone()));l&&l.minSize&&(a.visualVariables?a.visualVariables.push(l.minSize):a.visualVariables=[l.minSize]);return{renderer:a,locationScheme:n.cloneScheme(e),basemapId:b.basemapId,basemapTheme:b.basemapTheme}};Object.defineProperty(p,Symbol.toStringTag,{value:"Module"})});