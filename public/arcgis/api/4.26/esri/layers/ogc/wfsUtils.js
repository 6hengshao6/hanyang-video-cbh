// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.27/esri/copyright.txt for details.
//>>built
define("exports ../../geometry ../../request ../../core/Error ../../core/iteratorUtils ../../core/maybe ../../core/promiseUtils ../../core/urlUtils ../../geometry/projection ../../geometry/support/spatialReferenceUtils ../../geometry/support/typeUtils ../graphics/sources/geojson/geojson ./dateUtils ./xmlUtils ../support/Field ../../geometry/SpatialReference ../../geometry/Extent".split(" "),function(l,aa,r,k,x,t,L,u,B,v,M,N,O,m,q,C,P){function D(a){a=y(a);Q(a);z(a);a=a.firstElementChild;const b=x.cache(R(a));
return{operations:S(a),get featureTypes(){return Array.from(b())},readFeatureTypes:b}}function S(a){let b=!1;const c={GetCapabilities:{url:""},DescribeFeatureType:{url:""},GetFeature:{url:"",outputFormat:null,supportsPagination:!1}};m.visitXML(a,{OperationsMetadata:{Operation:e=>{switch(e.getAttribute("name")){case "GetCapabilities":return{DCP:{HTTP:{Get:d=>{c.GetCapabilities.url=d.getAttribute("xlink:href")}}}};case "DescribeFeatureType":return{DCP:{HTTP:{Get:d=>{c.DescribeFeatureType.url=d.getAttribute("xlink:href")}}}};
case "GetFeature":return{DCP:{HTTP:{Get:d=>{c.GetFeature.url=d.getAttribute("xlink:href")}}},Parameter:d=>{if("outputFormat"===d.getAttribute("name"))return{AllowedValues:{Value:f=>{(f=f.textContent)&&T.has(f.toLowerCase())&&(c.GetFeature.outputFormat=f)}}}}}}},Constraint:e=>{switch(e.getAttribute("name")){case "KVPEncoding":return{DefaultValue:d=>{b="true"===d.textContent.toLowerCase()}};case "ImplementsResultPaging":return{DefaultValue:d=>{c.GetFeature.supportsPagination="true"===d.textContent.toLowerCase()}}}}}});
if(!b)throw new k("wfs-layer:kvp-encoding-not-supported","WFS service doesn't support key/value pair (KVP) encoding");if(t.isNone(c.GetFeature.outputFormat))throw new k("wfs-layer:geojson-not-supported","WFS service doesn't support GeoJSON output format");return c}function R(a){return m.iterateXML(a,{FeatureTypeList:{FeatureType:b=>{const c={typeName:"undefined:undefined",name:"",title:"",description:"",extent:null,namespacePrefix:"",namespaceUri:"",supportedSpatialReferences:[]},e=new Set([4326]),
d=f=>{f=parseInt(f.textContent?.match(/(?<wkid>\d+$)/i)?.groups?.wkid??"",10);Number.isNaN(f)||e.add(f)};m.visitXML(b,{Name:f=>{const {name:g,prefix:h}=w(f.textContent);c.typeName=`${h}:${g}`;c.name=g;c.namespacePrefix=h;c.namespaceUri=f.lookupNamespaceURI(h)},Abstract:f=>{c.description=f.textContent},Title:f=>{c.title=f.textContent},WGS84BoundingBox:f=>{c.extent=U(f)},DefaultSRS:d,DefaultCRS:d,OtherSRS:d,OtherCRS:d});c.title||(c.title=c.name);c.supportedSpatialReferences.push(...e);return c}}})}
function U(a){let b,c,e,d;for(const f of a.children)switch(f.localName){case "LowerCorner":[b,c]=f.textContent.split(" ").map(g=>Number.parseFloat(g));break;case "UpperCorner":[e,d]=f.textContent.split(" ").map(g=>Number.parseFloat(g))}return{xmin:b,ymin:c,xmax:e,ymax:d,spatialReference:v.WGS84}}function E(a,b,c){return x.find(a,e=>c?e.name===b&&e.namespaceUri===c:e.typeName===b||e.name===b)}async function F(a,b,c,e={}){const {spatialReference:d=C.WGS84}=e;a=a.readFeatureTypes();c=b?E(a,b,c):a.next().value;
if(t.isNone(c)){if(b)throw new k("wfs-layer:feature-type-not-found",`The type '${b}' could not be found in the service`);throw new k("wfs-layer:empty-service","The service is empty");}b=new P({...c.extent,spatialReference:d});if(!v.equals(d,v.WGS84))try{await B.initializeProjection(v.WGS84,d,void 0,e),b=B.project(b,v.WGS84)}catch{throw new k("wfs-layer:unsupported-spatial-reference","Projection not supported");}return{extent:b,spatialReference:d,featureType:c}}async function V(a,b,c={}){const [e,
d]=await L.eachAlways([G(a.operations.DescribeFeatureType.url,b,c),W(a,b,c)]);if(e.error||d.error)throw new k("wfs-layer:getWFSLayerTypeInfo-error",`An error occurred while getting info about the feature type '${b}'`,{error:e.error||d.error});const {fields:f,errors:g}=e.value??{};a=e.value?.geometryType||d.value?.geometryType;c=d.value?.swapXY??!1;if(t.isNone(a))throw new k("wfs-layer:unknown-geometry-type",`The geometry type could not be determined for type '${b}`,{typeName:b,geometryType:a,fields:f,
errors:g});return{...H(f??[]),geometryType:a,swapXY:c}}function H(a){const b=a.find(e=>"geometry"===e.type);let c=a.find(e=>"oid"===e.type);a=a.filter(e=>"geometry"!==e.type);c||(c=new q({name:"__esri_wfs_id__",type:"oid",alias:"__esri_wfs_id__"}),a.unshift(c));return{geometryField:b?.name??null,objectIdField:c.name,fields:a}}async function W(a,b,c={}){let e,d=!1;const [f,g]=await Promise.all([I(a.operations.GetFeature.url,b,a.operations.GetFeature.outputFormat,{...c,count:1}),r(a.operations.GetFeature.url,
{responseType:"text",query:J(b,void 0,{...c,count:1}),signal:c?.signal})]);if(a="FeatureCollection"===f.type&&f.features[0]?.geometry){e=M.featureGeometryTypeKebabDictionary.fromJSON(N.getGeometryType(a.type));switch(a.type){case "Point":var h=a.coordinates;break;case "LineString":case "MultiPoint":h=a.coordinates[0];break;case "MultiLineString":case "Polygon":h=a.coordinates[0][0];break;case "MultiPolygon":h=a.coordinates[0][0][0]}if(b=/<[^>]*pos[^>]*> *(-?\d+(?:\.\d+)?) (-?\d+(?:\.\d+)?)/.exec(g.data))a=
h[0].toFixed(3),h=h[1].toFixed(3),c=parseFloat(b[1]).toFixed(3),b=parseFloat(b[2]).toFixed(3),a===b&&h===c&&(d=!0)}return{geometryType:e,swapXY:d}}async function G(a,b,c){a=await r(a,{responseType:"text",query:{SERVICE:"WFS",REQUEST:"DescribeFeatureType",VERSION:"2.0.0",TYPENAME:b,...c?.customParameters},signal:c?.signal});return K(b,a.data)}function K(a,b){const {name:c}=w(a);b=y(b);z(b);const e=x.find(m.iterateXML(b.firstElementChild,{element:d=>({name:d.getAttribute("name"),typeName:w(d.getAttribute("type")).name})}),
({name:d})=>d===c);if(t.isSome(e)){const d=x.find(m.iterateXML(b.firstElementChild,{complexType:f=>f}),f=>f.getAttribute("name")===e.typeName);if(t.isSome(d))return X(d)}throw new k("wfs-layer:feature-type-not-found",`Type '${a}' not found in document`,{document:(new XMLSerializer).serializeToString(b)});}function X(a){const b=[],c=[];let e=void 0;var d=m.iterateXML(a,{complexContent:{extension:{sequence:{element:f=>f}}}});for(const f of d){d=f.getAttribute("name");if(!d)continue;let g,h;f.hasAttribute("type")?
g=w(f.getAttribute("type")).name:m.visitXML(f,{simpleType:{restriction:A=>{g=w(A.getAttribute("base")).name;return{maxLength:Y=>{h=+Y.getAttribute("value")}}}}});if(!g)continue;const p="true"===f.getAttribute("nillable");let n=!1;switch(g.toLowerCase()){case "integer":case "nonpositiveinteger":case "negativeinteger":case "long":case "int":case "short":case "byte":case "nonnegativeinteger":case "unsignedlong":case "unsignedint":case "unsignedshort":case "unsignedbyte":case "positiveinteger":c.push(new q({name:d,
alias:d,type:"integer",nullable:p}));break;case "float":case "double":case "decimal":c.push(new q({name:d,alias:d,type:"double",nullable:p}));break;case "boolean":case "string":case "gyearmonth":case "gyear":case "gmonthday":case "gday":case "gmonth":case "anyuri":case "qname":case "notation":case "normalizedstring":case "token":case "language":case "idrefs":case "entities":case "nmtoken":case "nmtokens":case "name":case "ncname":case "id":case "idref":case "entity":case "duration":case "time":c.push(new q({name:d,
alias:d,type:"string",nullable:p,length:h??255}));break;case "datetime":case "date":c.push(new q({name:d,alias:d,type:"date",nullable:p,length:h??36}));break;case "pointpropertytype":e="point";n=!0;break;case "multipointpropertytype":e="multipoint";n=!0;break;case "curvepropertytype":case "multicurvepropertytype":case "multilinestringpropertytype":e="polyline";n=!0;break;case "surfacepropertytype":case "multisurfacepropertytype":case "multipolygonpropertytype":e="polygon";n=!0;break;case "geometrypropertytype":case "multigeometrypropertytype":n=
!0;b.push(new k("wfs-layer:unknown-geometry-type",`geometry type '${g}' is not supported`,{type:(new XMLSerializer).serializeToString(a)}));break;default:b.push(new k("wfs-layer:unknown-field-type",`Unknown field type '${g}'`,{type:(new XMLSerializer).serializeToString(a)}))}n&&c.push(new q({name:d,alias:d,type:"geometry",nullable:p}))}for(const f of c)if("integer"===f.type&&!f.nullable&&Z.has(f.name.toLowerCase())){f.type="oid";break}return{geometryType:e,fields:c,errors:b}}async function I(a,b,
c,e){({data:a}=await r(a,{responseType:"text",query:J(b,c,e),signal:e?.signal}));a=a.replace(/": +(-?\d+),(\d+)(,)?/g,'": $1.$2$3');try{if(e?.dateFields?.length){const d=new Set(e.dateFields);return JSON.parse(a,(f,g)=>d.has(f)?O.parseDate(g):g)}return JSON.parse(a)}catch(d){throw new k("wfs-layer:malformed-json","Error while parsing the\u00a0response",{response:a,error:d});}}function J(a,b,c){return{SERVICE:"WFS",REQUEST:"GetFeature",VERSION:"2.0.0",TYPENAMES:a,OUTPUTFORMAT:b,SRSNAME:"EPSG:4326",
STARTINDEX:c?.startIndex,COUNT:c?.count,...c?.customParameters}}function y(a){return(new DOMParser).parseFromString(a.trim(),"text/xml")}function w(a){const [b,c]=a.split(":");return{prefix:c?b:"",name:c??b}}function Q(a){if((a=a.firstElementChild?.getAttribute("version"))&&"2.0.0"!==a)throw new k("wfs-layer:unsupported-wfs-version",`Unsupported WFS version ${a}. Supported version: ${"2.0.0"}`);}function z(a){let b="",c="";m.visitXML(a.firstElementChild,{Exception:e=>{b=e.getAttribute("exceptionCode");
return{ExceptionText:d=>{c=d.textContent}}}});if(b)throw new k(`wfs-layer:${b}`,c);}const T=new Set(["json","application/json","geojson","application/json; subtype\x3dgeojson"]),Z=new Set(["objectid","fid"]);l.WFS_OID_FIELD_NAME="__esri_wfs_id__";l.describeFeatureType=G;l.findFeatureType=E;l.getCapabilities=async function(a,b){b=await r(a,{responseType:"text",query:{SERVICE:"WFS",REQUEST:"GetCapabilities",VERSION:"2.0.0",...b?.customParameters},signal:b?.signal});b=D(b.data);u.isHTTPSProtocol(a)&&
(u.hasSameOrigin(a,b.operations.DescribeFeatureType.url,!0)&&(b.operations.DescribeFeatureType.url=u.toHTTPS(b.operations.DescribeFeatureType.url)),u.hasSameOrigin(a,b.operations.GetFeature.url,!0)&&(b.operations.GetFeature.url=u.toHTTPS(b.operations.GetFeature.url)));return b};l.getFeature=I;l.getFeatureCount=async function(a,b,c){a=await r(a,{responseType:"text",query:{SERVICE:"WFS",REQUEST:"GetFeature",VERSION:"2.0.0",TYPENAMES:b,RESULTTYPE:"hits",...c?.customParameters},signal:c?.signal});a=y(a.data);
z(a);a=Number.parseFloat(a.firstElementChild.getAttribute("numberMatched"));return Number.isNaN(a)?0:a};l.getFeatureTypeInfo=F;l.getWFSLayerInfo=async function(a,b,c,e={}){const {featureType:d,extent:f}=await F(a,b,c,e),{fields:g,geometryType:h,swapXY:p,objectIdField:n,geometryField:A}=await V(a,d.typeName,e);return{url:a.operations.GetCapabilities.url,name:d.name,namespaceUri:d.namespaceUri,fields:g,geometryField:A,geometryType:h,objectIdField:n,spatialReference:e.spatialReference??C.WGS84,extent:f,
swapXY:p,wfsCapabilities:a,customParameters:e.customParameters}};l.parseDescribeFeatureTypeResponse=K;l.parseGetCapabilitiesResponse=D;l.prepareWFSLayerFields=H;Object.defineProperty(l,Symbol.toStringTag,{value:"Module"})});