// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.27/esri/copyright.txt for details.
//>>built
define("exports ../../Graphic ../../core/Collection ../../core/Error ../../core/lang ../../core/maybe ../../core/urlUtils ../../core/uuid ../../geometry/support/normalizeUtils ./assetEditingSupport ../mixins/EditBusLayer ../support/infoFor3D ../support/layerUtils".split(" "),function(t,z,p,g,A,n,B,C,D,E,u,v,q){async function F(a,b,e,d){await a.load();if(!b||null==b.applyEdits)throw new g(`${a.type}-layer:no-editing-support`,"Layer source does not support applyEdits capability",{layer:a});if(!q.getEffectiveEditingEnabled(a))throw new g(`${a.type}-layer:editing-disabled`,
"Editing is disabled for layer",{layer:a});const {edits:c,options:m}=await G(a,e,d);return c.addFeatures?.length||c.updateFeatures?.length||c.deleteFeatures?.length||c.addAttachments?.length||c.updateAttachments?.length||c.deleteAttachments?.length?{edits:c,results:await b.applyEdits(c,m)}:{edits:c,results:{addFeatureResults:[],updateFeatureResults:[],deleteFeatureResults:[],addAttachmentResults:[],updateAttachmentResults:[],deleteAttachmentResults:[]}}}async function G(a,b,e){var d=b&&(b.addFeatures||
b.updateFeatures||b.deleteFeatures),c=b&&(b.addAttachments||b.updateAttachments||b.deleteAttachments);const m=n.isSome(a.infoFor3D);if(!b||!d&&!c)throw new g(`${a.type}-layer:missing-parameters`,"'addFeatures', 'updateFeatures', 'deleteFeatures', 'addAttachments', 'updateAttachments' or 'deleteAttachments' parameter is required");d=q.getEffectiveLayerCapabilities(a);if(!d.data.isVersioned&&e?.gdbVersion)throw new g(`${a.type}-layer:invalid-parameter`,"'gdbVersion' is applicable only if the layer supports versioned data. See: 'capabilities.data.isVersioned'");
if(!d.editing.supportsRollbackOnFailure&&e?.rollbackOnFailureEnabled)throw new g(`${a.type}-layer:invalid-parameter`,"This layer does not support 'rollbackOnFailureEnabled' parameter. See: 'capabilities.editing.supportsRollbackOnFailure'");if(!d.editing.supportsGlobalId&&e?.globalIdUsed)throw new g(`${a.type}-layer:invalid-parameter`,"This layer does not support 'globalIdUsed' parameter. See: 'capabilities.editing.supportsGlobalId'");if(!d.editing.supportsGlobalId&&c)throw new g(`${a.type}-layer:invalid-parameter`,
"'addAttachments', 'updateAttachments' and 'deleteAttachments' are applicable only if the layer supports global ids. See: 'capabilities.editing.supportsGlobalId'");if(!e?.globalIdUsed&&c)throw new g(`${a.type}-layer:invalid-parameter`,"When 'addAttachments', 'updateAttachments' or 'deleteAttachments' is specified, globalIdUsed should be set to true");c={...e};null!=c.rollbackOnFailureEnabled||d.editing.supportsRollbackOnFailure||(c.rollbackOnFailureEnabled=!0);if(!1===c.rollbackOnFailureEnabled&&
"original-and-current-features"===c.returnServiceEditsOption)throw new g(`${a.type}-layer:invalid-parameter`,"'original-and-current-features' is valid for 'returnServiceEditsOption' only when 'rollBackOnFailure' is true.");if(!d.editing.supportsReturnServiceEditsInSourceSpatialReference&&c.returnServiceEditsInSourceSR)throw new g(`${a.type}-layer:invalid-parameter`,"This layer does not support 'returnServiceEditsInSourceSR' parameter. See: 'capabilities.editing.supportsReturnServiceEditsInSourceSpatialReference'");
if(c.returnServiceEditsInSourceSR&&"original-and-current-features"!==c.returnServiceEditsOption)throw new g(`${a.type}-layer:invalid-parameter`,"'returnServiceEditsInSourceSR' is valid only when 'returnServiceEditsOption' is set to 'original-and-current-features'");const f={...b};f.addFeatures=b&&p.isCollection(b.addFeatures)?b.addFeatures.toArray():f.addFeatures||[];f.updateFeatures=b&&p.isCollection(b.updateFeatures)?b.updateFeatures.toArray():f.updateFeatures||[];f.deleteFeatures=b&&p.isCollection(b.deleteFeatures)?
b.deleteFeatures.toArray():f.deleteFeatures||[];if(f.addFeatures.length&&!d.operations.supportsAdd)throw new g(`${a.type}-layer:unsupported-operation`,"Layer does not support adding features.");if(f.updateFeatures.length&&!d.operations.supportsUpdate)throw new g(`${a.type}-layer:unsupported-operation`,"Layer does not support updating features.");if(f.deleteFeatures.length&&!d.operations.supportsDelete)throw new g(`${a.type}-layer:unsupported-operation`,"Layer does not support deleting features.");
f.addAttachments=f.addAttachments||[];f.updateAttachments=f.updateAttachments||[];f.deleteAttachments=f.deleteAttachments||[];f.addFeatures=f.addFeatures.map(w);f.updateFeatures=f.updateFeatures.map(w);f.addAssets=[];const h=e?.globalIdUsed||m;f.addFeatures.forEach(k=>{r(k,a,h)});f.updateFeatures.forEach(k=>{r(k,a,h);const l=q.getEffectiveLayerCapabilities(a);if("geometry"in k&&n.isSome(k.geometry)&&!l?.editing.supportsGeometryUpdate)throw new g(`${a.type}-layer:unsupported-operation`,"Layer does not support geometry updates.");
});f.deleteFeatures.forEach(k=>{r(k,a,h)});f.addAttachments.forEach(k=>x(k,a));f.updateAttachments.forEach(k=>x(k,a));m&&await H(f,a);return{edits:await I(f),options:c}}function r(a,b,e){if(e){if("attributes"in a&&!a.attributes[b.globalIdField])throw new g(`${b.type}-layer:invalid-parameter`,"Feature should have 'globalId' when 'globalIdUsed' is true");if(!("attributes"in a||a.globalId))throw new g(`${b.type}-layer:invalid-parameter`,"'globalId' of the feature should be passed when 'globalIdUsed' is true");
}if("geometry"in a&&n.isSome(a.geometry)){if(a.geometry.hasZ&&!1===b.capabilities?.data.supportsZ)throw new g(`${b.type}-layer:z-unsupported`,"Layer does not support z values while feature has z values.");if(a.geometry.hasM&&!1===b.capabilities?.data.supportsM)throw new g(`${b.type}-layer:m-unsupported`,"Layer does not support m values while feature has m values.");}}function x(a,b){const {feature:e,attachment:d}=a;if(!e||"attributes"in e&&!e.attributes[b.globalIdField])throw new g(`${b.type}-layer:invalid-parameter`,
"Attachment should have reference to a feature with 'globalId'");if(!("attributes"in e||e.globalId))throw new g(`${b.type}-layer:invalid-parameter`,"Attachment should have reference to 'globalId' of the parent feature");if(!d.globalId)throw new g(`${b.type}-layer:invalid-parameter`,"Attachment should have 'globalId'");if(!d.data&&!d.uploadId)throw new g(`${b.type}-layer:invalid-parameter`,"Attachment should have 'data' or 'uploadId'");if(!(d.data instanceof File&&d.data.name||d.name))throw new g(`${b.type}-layer:invalid-parameter`,
"'name' is required when attachment is specified as Base64 encoded string using 'data'");if(!b.capabilities?.editing.supportsUploadWithItemId&&d.uploadId)throw new g(`${b.type}-layer:invalid-parameter`,"This layer does not support 'uploadId' parameter. See: 'capabilities.editing.supportsUploadWithItemId'");if("string"===typeof d.data&&(a=B.dataComponents(d.data))&&!a.isBase64)throw new g(`${b.type}-layer:invalid-parameter`,"Attachment 'data' should be a Blob, File or Base64 encoded string");}async function I(a){const b=
a.addFeatures??[],e=a.updateFeatures??[];var d=b.concat(e).map(f=>f.geometry);d=await D.normalizeCentralMeridian(d);const c=b.length,m=e.length;d.slice(0,c).forEach((f,h)=>b[h].geometry=f);d.slice(c,c+m).forEach((f,h)=>e[h].geometry=f);return a}function w(a){const b=new z;a.attributes||(a.attributes={});b.geometry=a.geometry;b.attributes=a.attributes;return b}async function H(a,b){if(!n.isNone(b.infoFor3D)){var {infoFor3D:e}=b,d=!1;for(const c of e.editFormats)if(c===v.AssetType.GLTF_BINARY){d=!0;
break}e=[];for(const c of a.addFeatures??[])e.push(y(c,a,b,d));for(const c of a.updateFeatures??[])e.push(y(c,a,b,d));a=await Promise.allSettled(e);for(const c of a)if("rejected"===c.status)throw c.reason;}}async function y(a,b,e,d){if(!n.isNone(a.geometry)&&"mesh"===a.geometry.type){var c=a.geometry,m=e.globalIdField;if(!(n.isSome(e.parsedUrl)&&n.isSome(c.external)&&Array.isArray(c.external.source)&&1===c.external.source.length&&"source"in c.external.source[0]&&"string"==typeof c.external.source[0].source&&
c.external.source[0].source.startsWith(e.parsedUrl.path))){if(!d)throw new g(`${e.type}-layer:binary-gltf-asset-not-supported`,"3DObjectFeatureLayer requires binary glTF (.glb) support for updating mesh geometry.");e=await (await c.toBinaryGLTF({ignoreLocalTransform:!0})).buffer();d=`{${C.generateUUID()}}`;var f=`${d}.glb`;b.addAssets?.push({featureGlobalId:a.getAttribute(m),assetMapGlobalId:d,assetName:f,flags:n.isSome(c.transform)&&c.transform.geographic?E.AssetMapEditFlags.PROJECT_VERTICES:0,data:e.data,
mimeType:e.type,assetType:v.AssetType.GLTF_BINARY,feature:a})}}}t.applyEdits=async function(a,b,e,d={}){let c,m;const f={edits:e,result:new Promise((h,k)=>{c=h;m=k})};a.emit("apply-edits",f);try{const {results:h,edits:k}=await F(a,b,e,d);b=J=>J.filter(K=>!K.error).map(A.clone);const l={edits:k,addedFeatures:b(h.addFeatureResults),updatedFeatures:b(h.updateFeatureResults),deletedFeatures:b(h.deleteFeatureResults),addedAttachments:b(h.addAttachmentResults),updatedAttachments:b(h.updateAttachmentResults),
deletedAttachments:b(h.deleteAttachmentResults),exceededTransferLimit:!1};h.editedFeatureResults?.length&&(l.editedFeatures=h.editedFeatureResults);if(l.addedFeatures.length||l.updatedFeatures.length||l.deletedFeatures.length||l.addedAttachments.length||l.updatedAttachments.length||l.deletedAttachments.length)a.emit("edits",l),u.isEditBusLayer(a)&&u.editEventBus.emit("edits",{layer:a,event:l});c(l);return h}catch(h){throw m(h),h;}};Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})});