// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.27/esri/copyright.txt for details.
//>>built
define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/JSONSupport ../../../core/maybe ../../../core/accessorSupport/decorators/property ../../../core/accessorSupport/decorators/cast ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/decorators/subclass ../PixelBlock ../RasterInfo".split(" "),function(q,g,f,p,k,r,y,z,t,u,v){f=function(h){function n(){var a=w.apply(this,arguments);a.functionArguments=null;a.readingBufferSize=0;a.id=-1;a.isNoopProcess=
!1;a.rawInputBandIds=[];a.isInputBandIdsSwizzled=!1;a.swizzledBandSelection=[];a.isBranch=!1;a._bindingResult=null;return a}q._inherits(n,h);var w=q._createSuper(n);h=n.prototype;h.bind=function(a,c=!1,b=-1){this.id=b+1;b=this._getRasterValues();let d=!0;for(let l=0;l<b.length;l++){var e=b[l];if(p.isSome(e)&&this._isRasterFunctionValue(e)){e=e.bind(a,c,this.id+l);if(!e.success)return this._bindingResult=e;d=d&&e.supportsGPU}}if(!this.rasterInfo||c)return this.sourceRasterInfos=this._getSourceRasterInfos(a),
this._bindingResult=this._bindSourceRasters(),this._bindingResult.supportsGPU=d&&this._bindingResult.supportsGPU,this.processInputBandIds(),this._bindingResult;this._bindingResult={success:!0,supportsGPU:!0};this.processInputBandIds();return this._bindingResult};h.process=function(a){var c=this._getRasterValues();c=0===c.length?a.pixelBlocks??a.primaryPixelBlocks:c.map(b=>this._readRasterValue(b,a));return this._processPixels({...a,pixelBlocks:c})};h.processInputBandIds=function(){var a=this._getRasterValues().filter(this._isRasterFunctionValue);
if(1<a.length)return this.rawInputBandIds=a.map(b=>b.processInputBandIds()[0]),this.isInputBandIdsSwizzled=this.rawInputBandIds.some((b,d)=>b!==d),a=a.filter(b=>"ExtractBand"===b.functionName),a.length&&a.forEach((b,d)=>{b.isInputBandIdsSwizzled=!0;b.swizzledBandSelection=[d,d,d]}),this.rawInputBandIds;var c=a[0];if(c){if(a=c.processInputBandIds(),c.isInputBandIdsSwizzled)return this.rawInputBandIds=a}else{a=[];({bandCount:c}=this.sourceRasterInfos[0]);for(let b=0;b<c;b++)a.push(b)}a=this._getInputBandIds(a);
this.isInputBandIdsSwizzled=a.some((b,d)=>b!==d);return this.rawInputBandIds=a};h.getPrimaryRasters=function(){const a=[],c=[];this._getPrimaryRasters(this,a,c);return{rasters:a,rasterIds:c}};h.getWebGLProcessorDefinition=function(){const a=this._getWebGLParameters(),{raster:c,rasters:b}=this.functionArguments;b&&Array.isArray(b)&&b.length?(a.rasters=b.map(d=>this._isRasterFunctionValue(d)?d.getWebGLProcessorDefinition():"number"===typeof d?{name:"Constant",parameters:{value:d},pixelType:"f32",id:-1,
isNoopProcess:!1}:{name:"Identity",parameters:{value:d},pixelType:"f32",id:-1,isNoopProcess:!1}),a.rasters.some(d=>null!=d)||(a.rasters=null)):this._isRasterFunctionValue(c)&&(a.raster=c.getWebGLProcessorDefinition());return{name:this.functionName,parameters:a,pixelType:this.outputPixelType,id:this.id,isNoopProcess:this.isNoopProcess}};h._getOutputPixelType=function(a){return"unknown"===this.outputPixelType?a:this.outputPixelType??a};h._getWebGLParameters=function(){return{}};h._getInputBandIds=function(a){return a};
h._isOutputRoundingNeeded=function(){const {outputPixelType:a}=this;return(a?.startsWith("u")||a?.startsWith("s"))??!1};h._getRasterValues=function(){const {rasterArgumentNames:a}=this;return"rasters"===a[0]?this.functionArguments.rasters??[]:a.map(c=>this.functionArguments[c])};h._getSourceRasterInfos=function(a){const c=this._getRasterValues(),{rasterInfos:b,rasterIds:d}=a;if(0===c.length)return b;const e=c.map(m=>{if(m&&"object"===typeof m&&"bind"in m&&m.rasterInfo)return m.rasterInfo;if("string"===
typeof m&&d.includes(m))return b[d.indexOf(m)];if("number"!==typeof m)return b[0]}),l=e.find(m=>m)??b[0];e.forEach((m,x)=>{void 0===m&&(e[x]=l)});return e};h._getPrimaryRasterId=function(a){return a?.url};h._getPrimaryRasters=function(a,c=[],b=[]){for(let e=0;e<a.sourceRasters.length;e++){var d=a.sourceRasters[e];if("number"!==typeof d)if("bind"in d)this._getPrimaryRasters(d,c,b);else{const l=this._getPrimaryRasterId(d);null==l||b.includes(l)||(this.mainPrimaryRasterId===l?(c.unshift(d),b.unshift(l)):
(c.push(d),b.push(l)))}}};h._isRasterFunctionValue=function(a){return null!=a&&"object"===typeof a&&"getWebGLProcessorDefinition"in a};h._readRasterValue=function(a,c){var {primaryPixelBlocks:b}=c;if(p.isNone(a)||"$$"===a)return a=b[0],p.isNone(a)?null:a.clone();if("string"===typeof a)return a=c.primaryRasterIds.indexOf(a),-1===a?null:b[a];if("number"===typeof a){b=b[0];if(p.isNone(b))return null;const {width:d,height:e,pixelType:l,mask:m}=b;b=m?new Uint8Array(m):null;c=new Float32Array(d*e);c.fill(a);
a=Array(this.sourceRasterInfos[0].bandCount).fill(c);return new u({width:d,height:e,pixelType:l,pixels:a,mask:b})}return a.process(c)};q._createClass(n,[{key:"supportsGPU",get:function(){return this._bindingResult.supportsGPU}},{key:"flatWebGLFunctionChain",get:function(){var a=this.getWebGLProcessorDefinition();if(!a)return null;const c=[a];({parameters:a}=a);for(a=a.rasters||a.raster&&[a.raster];a?.length;){c.unshift(...a);var b=[];for(var d=0;d<a.length;d++){var {parameters:e}=a[d];e=e.rasters||
e.raster&&[e.raster];e?.length&&b.push(...e)}a=b}for(a=c.length-1;0<=a;a--)c[a].isNoopProcess&&c.splice(a,1);a=!1;for(b=0;b<c.length;b++)d=c[b],d.id=c.length-b-1,{rasters:d}=d.parameters,a=a||null!=d&&1<d.length;b=c.some(({name:l})=>"Slope"===l||"Aspect"===l);return{functions:c,hasBranches:a,hasSurfaceFunction:b}}}]);return n}(f.JSONSupport);g.__decorate([k.property({json:{write:!0}})],f.prototype,"functionName",void 0);g.__decorate([k.property({json:{write:!0}})],f.prototype,"functionArguments",
void 0);g.__decorate([k.property()],f.prototype,"rasterArgumentNames",void 0);g.__decorate([k.property({json:{write:!0}}),r.cast(h=>h?.toLowerCase())],f.prototype,"outputPixelType",void 0);g.__decorate([k.property({json:{write:!0}})],f.prototype,"mainPrimaryRasterId",void 0);g.__decorate([k.property()],f.prototype,"sourceRasters",void 0);g.__decorate([k.property({type:[v],json:{write:!0}})],f.prototype,"sourceRasterInfos",void 0);g.__decorate([k.property({json:{write:!0}})],f.prototype,"rasterInfo",
void 0);g.__decorate([k.property({json:{write:!0}})],f.prototype,"readingBufferSize",void 0);g.__decorate([k.property({json:{write:!0}})],f.prototype,"id",void 0);g.__decorate([k.property()],f.prototype,"isNoopProcess",void 0);g.__decorate([k.property()],f.prototype,"supportsGPU",null);g.__decorate([k.property()],f.prototype,"rawInputBandIds",void 0);g.__decorate([k.property()],f.prototype,"isInputBandIdsSwizzled",void 0);g.__decorate([k.property()],f.prototype,"swizzledBandSelection",void 0);g.__decorate([k.property()],
f.prototype,"isBranch",void 0);g.__decorate([k.property()],f.prototype,"flatWebGLFunctionChain",null);g.__decorate([k.property()],f.prototype,"_bindingResult",void 0);return f=g.__decorate([t.subclass("esri.layers.support.rasterFunctions.BaseRasterFunction")],f)});