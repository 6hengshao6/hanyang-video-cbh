// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.27/esri/copyright.txt for details.
//>>built
define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../geometry ../../../core/Error ../../../core/maybe ../../../core/accessorSupport/decorators/property ../../../core/accessorSupport/ensureType ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/decorators/subclass ../PixelBlock ../RasterInfo ../RasterStorageInfo ./BaseRaster ./pamParser ./xmlUtilities ../rasterFormats/utils ../rasterFunctions/stretchUtils ../../../geometry/SpatialReference ../../../geometry/Extent ../../../geometry/Point".split(" "),
function(D,A,y,B,E,F,S,T,U,J,K,L,M,N,G,t,O,P,z,H,I){const u=new Map;u.set("Int8","s8");u.set("UInt8","u8");u.set("Int16","s16");u.set("UInt16","u16");u.set("Int32","s32");u.set("UInt32","u32");u.set("Float32","f32");u.set("Float64","f32");u.set("Double64","f32");const x=new Map;x.set("none",{blobExtension:".til",isOneSegment:!0,decoderFormat:"bip"});x.set("lerc",{blobExtension:".lrc",isOneSegment:!1,decoderFormat:"lerc"});x.set("deflate",{blobExtension:".pzp",isOneSegment:!0,decoderFormat:"deflate"});
x.set("jpeg",{blobExtension:".pjg",isOneSegment:!0,decoderFormat:"jpg"});y=function(w){function C(){var a=Q.apply(this,arguments);a._files=null;a._storageIndex=null;a.datasetFormat="MRF";return a}D._inherits(C,w);var Q=D._createSuper(C);w=C.prototype;w.open=async function(a){await this.init();this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1);var b=a?E.unwrap(a.signal):null,d=await this.request(this.url,{responseType:"xml",signal:b});const {rasterInfo:c,files:f}=this._parseHeader(d.data);
-1===this.ioConfig.skipExtensions?.indexOf("aux.xml")&&(a=await this._fetchAuxiliaryData(a),null!=a&&(c.statistics=a.statistics??c.statistics,(c.histograms=a.histograms)&&E.isNone(c.statistics)&&(c.statistics=P.estimateStatisticsFromHistograms(a.histograms))));this._set("rasterInfo",c);this._files=f;b=await this.request(f.index,{responseType:"array-buffer",signal:b});this._storageIndex=this._parseIndex(b.data);const {blockWidth:m,blockHeight:p}=this.rasterInfo.storageInfo;b=this.rasterInfo.storageInfo.pyramidScalingFactor;
const {width:e,height:q}=this.rasterInfo;a=[];d=this._getBandSegmentCount();let r=0,g=-1;for(;r<this._storageIndex.length;){g++;const k=Math.ceil(e/m/b**g)-1,h=Math.ceil(q/p/b**g)-1;r+=(k+1)*(h+1)*d*4;a.push({maxRow:h,maxCol:k,minCol:0,minRow:0})}this.rasterInfo.storageInfo.blockBoundary=a;0<g&&(this.rasterInfo.storageInfo.firstPyramidLevel=1,this.rasterInfo.storageInfo.maximumPyramidLevel=g);this.updateTileInfo()};w.fetchRawTile=async function(a,b,d,c={}){const {blockWidth:f,blockHeight:m,blockBoundary:p}=
this.rasterInfo.storageInfo;var e=p[a];if(!e||e.maxRow<b||e.maxCol<d||e.minRow>b||e.minCol>d)return null;const {bandCount:q,pixelType:r}=this.rasterInfo,{ranges:g,actualTileWidth:k,actualTileHeight:h}=this._getTileLocation(a,b,d);if(!g||0===g.length)return null;if(0===g[0].from&&0===g[0].to)return a=new Uint8Array(f*m),new K({width:f,height:m,pixels:null,mask:a,validPixelCount:0});({bandIds:b}=this.ioConfig);d=this._getBandSegmentCount();e=[];for(a=a=0;a<d;a++)(!b||-1<b.indexOf[a])&&e.push(this.request(this._files.data,
{range:{from:g[a].from,to:g[a].to},responseType:"array-buffer",signal:c.signal}));c=await Promise.all(e);a=c.map(v=>v.data.byteLength).reduce((v,n)=>v+n);e=new Uint8Array(a);let l=0;for(a=0;a<d;a++)e.set(new Uint8Array(c[a].data),l),l+=c[a].data.byteLength;a=x.get(this.rasterInfo.storageInfo.compression).decoderFormat;b=await this.decodePixelBlock(e.buffer,{width:f,height:m,format:a,planes:b?.length||q,pixelType:r});if(null==b)return null;if(E.isSome(this.rasterInfo.noDataValue)&&"lerc"!==a&&!b.mask&&
(c=this.rasterInfo.noDataValue[0],null!=c)){d=b.width*b.height;e=new Uint8Array(d);if(1E24<Math.abs(c))for(a=0;a<d;a++)1E-6<Math.abs((b.pixels[0][a]-c)/c)&&(e[a]=1);else for(a=0;a<d;a++)b.pixels[0][a]!==c&&(e[a]=1);b.mask=e}d=c=0;if(k!==f||h!==m)if(e=b.mask)for(a=0;a<m;a++)for(d=a*f,c=a<h?k:0;c<f;c++)e[d+c]=0;else for(e=new Uint8Array(f*m),b.mask=e,a=0;a<h;a++)for(d=a*f,c=0;c<k;c++)e[d+c]=1;return b};w._parseIndex=function(a){if(0<a.byteLength%16)throw Error("invalid array buffer must be multiples of 16");
let b,d,c,f,m;if(O.isPlatformLittleEndian){b=new Uint8Array(a);c=new ArrayBuffer(a.byteLength);d=new Uint8Array(c);for(f=0;f<a.byteLength/4;f++)for(m=0;4>m;m++)d[4*f+m]=b[4*f+3-m];a=new Uint32Array(c)}else a=new Uint32Array(a);return a};w._getBandSegmentCount=function(){return x.get(this.rasterInfo.storageInfo.compression).isOneSegment?1:this.rasterInfo.bandCount};w._getTileLocation=function(a,b,d){const {blockWidth:c,blockHeight:f,pyramidScalingFactor:m}=this.rasterInfo.storageInfo,{width:p,height:e}=
this.rasterInfo,q=this._getBandSegmentCount();let r,g;var k,h=0;let l=0;for(k=0;k<a;k++)l=m**k,r=Math.ceil(p/c/l),g=Math.ceil(e/f/l),h+=r*g;l=m**a;r=Math.ceil(p/c/l);g=Math.ceil(e/f/l);h=4*(h+(b*r+d))*q;a=this._storageIndex.subarray(h,h+4*q);h=k=0;const v=[];for(let n=0;n<q;n++)k=a[4*n]*2**32+a[4*n+1],h=k+a[4*n+2]*2**32+a[4*n+3],v.push({from:k,to:h});return{ranges:v,actualTileWidth:d<r-1?c:Math.ceil(p/l)-c*(r-1),actualTileHeight:b<g-1?f:Math.ceil(e/l)-f*(g-1)}};w._parseHeader=function(a){var b=t.getElement(a,
"MRF_META/Raster");if(!b)throw new B("mrf:open","not a valid MRF format");var d=t.getElement(b,"Size"),c=parseInt(d.getAttribute("x"),10),f=parseInt(d.getAttribute("y"),10);const m=parseInt(d.getAttribute("c"),10);d=(t.getElementValue(b,"Compression")||"none").toLowerCase();if(!x.has(d))throw new B("mrf:open","currently does not support compression "+d);var p=t.getElementValue(b,"DataType")||"UInt8";const e=u.get(p);if(null==e)throw new B("mrf:open","currently does not support pixel type "+p);var q=
t.getElement(b,"PageSize");p=parseInt(q.getAttribute("x"),10);q=parseInt(q.getAttribute("y"),10);b=t.getElement(b,"DataValues");let r;b&&(b=b.getAttribute("NoData"),null!=b&&(r=b.trim().split(" ").map(R=>parseFloat(R))));if(t.getElement(a,"MRF_META/CachedSource"))throw new B("mrf:open","currently does not support MRF referencing other data files");var g=t.getElement(a,"MRF_META/GeoTags"),k=t.getElement(g,"BoundingBox");b=!1;if(null!=k){var h=parseFloat(k.getAttribute("minx"));var l=parseFloat(k.getAttribute("miny")),
v=parseFloat(k.getAttribute("maxx"));k=parseFloat(k.getAttribute("maxy"));var n=t.getElementValue(g,"Projection")||"";g=z.WGS84;"LOCAL_CS[]"!==n?n.toLowerCase().startsWith("epsg:")?(n=Number(n.slice(5)),isNaN(n)||0===n||(g=new z({wkid:n}))):g=G.parseSpatialReference(n)??z.WGS84:(b=!0,g=new z({wkid:3857}));h=new H(h,l,v,k);h.spatialReference=g}else b=!0,h=new H({xmin:-.5,ymin:.5-f,xmax:c-.5,ymax:.5,spatialReference:new z({wkid:3857})});l=t.getElement(a,"MRF_META/Rsets");v=parseInt(l&&l.getAttribute("scale")||
"2",10);l=h.spatialReference;p=new M({origin:new I({x:h.xmin,y:h.ymax,spatialReference:l}),blockWidth:p,blockHeight:q,pyramidBlockWidth:p,pyramidBlockHeight:q,compression:d,pyramidScalingFactor:v});q=new I({x:h.width/c,y:h.height/f,spatialReference:l});c=new L({width:c,height:f,extent:h,isPseudoSpatialReference:b,spatialReference:l,bandCount:m,pixelType:e,pixelSize:q,noDataValue:r,storageInfo:p});f=t.getElementValue(a,"datafile");a=t.getElementValue(a,"IndexFile");a={mrf:this.url,index:a||this.url.replace(".mrf",
".idx"),data:f||this.url.replace(".mrf",x.get(d).blobExtension)};return{rasterInfo:c,files:a}};w._fetchAuxiliaryData=async function(a){try{const {data:b}=await this.request(this.url+".aux.xml",{responseType:"xml",signal:a?.signal});return G.parsePAMInfo(b)}catch{return null}};return D._createClass(C)}(N);A.__decorate([F.property()],y.prototype,"_files",void 0);A.__decorate([F.property()],y.prototype,"_storageIndex",void 0);A.__decorate([F.property({type:String,json:{write:!0}})],y.prototype,"datasetFormat",
void 0);return y=A.__decorate([J.subclass("esri.layers.support.rasterIO.MRFRaster")],y)});