// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.27/esri/copyright.txt for details.
//>>built
define("exports ../../core/arrayUtils ../../core/Error ../../core/Logger ../../core/maybe ../../core/promiseUtils ../../core/accessorSupport/originUtils ../FeatureLayer ../support/arcgisLayerUrl ../support/fetchService ../support/layerUtils ../../portal/Portal ../../portal/PortalItem ../../portal/support/jsonContext ../../portal/support/portalItemUtils".split(" "),function(n,H,k,r,t,p,u,I,J,K,z,L,M,v,h){function m(a,b){return`Layer (title: ${a.title}, id: ${a.id}) of type '${a.declaredClass}' ${b}`}
function A(a,b){if("Feature Service"!==b.type)throw new k("feature-layer:portal-item-wrong-type",m(a,'should have portal item of type "Feature Service"'));}async function B(a){await a.load();if(z.isFeatureCollectionLayer(a))throw new k("feature-layer:save",m(a,"using an in-memory source cannot be saved to a portal item"));}function N(a,b){a=(a.messages??[]).filter(({type:c})=>"error"===c).map(({name:c,message:d,details:e})=>new k(c,d,e));b?.ignoreUnsupported&&(a=a.filter(({name:c})=>"layer:unsupported"!==
c&&"symbol:unsupported"!==c&&"symbol-layer:unsupported"!==c&&"property:unsupported"!==c&&"url:unsupported"!==c));if(0<a.length)throw new k("feature-layer:save","Failed to save feature layer due to unsupported or invalid content. See 'details.errors' for more detailed information",{errors:a});}async function w(a,b,c){"beforeSave"in a&&"function"===typeof a.beforeSave&&await a.beforeSave();a=a.write({},b);N(b,c);return a}function C(a){const {layer:b,layerJSON:c}=a;return b.isTable?{layers:[],tables:[c]}:
{layers:[c],tables:[]}}function x(a){h.addTypeKeyword(a,h.TypeKeyword.JSAPI);a.typeKeywords&&(a.typeKeywords=a.typeKeywords.filter((b,c,d)=>d.indexOf(b)===c))}async function D(a,b){return/\/\d+\/?$/.test(a.url??"")?C(b[0]):O(a,b)}async function O(a,b){const {layer:{url:c,customParameters:d,apiKey:e}}=b[0];(a=await a.fetchData("json"))&&null!=a.layers&&null!=a.tables||(a=await P(a,{url:c??"",customParameters:d,apiKey:e},b.map(f=>f.layer.layerId)));for(const f of b)E(f.layer,f.layerJSON,a);return a}
async function P(a,b,c){var d,e;a||(a={});(d=a).layers||(d.layers=[]);(e=a).tables||(e.tables=[]);const {url:f,customParameters:g,apiKey:l}=b,{serviceJSON:q,layersJSON:y}=await K.fetchFeatureService(f,{customParameters:g,apiKey:l});b=F(a.layers,q.layers,c);c=F(a.tables,q.tables,c);a.layers=b.itemResources;a.tables=c.itemResources;c=[...b.added,...c.added];b=y?[...y.layers,...y.tables]:[];await Q(a,c,f,b);return a}function F(a,b,c){const d=H.difference(a,b,(e,f)=>e.id===f.id);a=a.filter(e=>!d.removed.some(f=>
f.id===e.id));b=d.added.map(({id:e})=>({id:e}));b.forEach(({id:e})=>{a.push({id:e})});return{itemResources:a,added:b.filter(({id:e})=>!c.includes(e))}}async function Q(a,b,c,d){b=b.map(({id:e})=>new I({url:c,layerId:e,sourceJSON:d.find(({id:f})=>f===e)}));await p.eachAlways(b.map(e=>e.load()));b.forEach(e=>{const {layerId:f,loaded:g,defaultPopupTemplate:l}=e;if(g&&!t.isNone(l)){var q={id:f,popupInfo:l.toJSON()};E(e,q,a)}})}function E(a,b,c){a.isTable?G(c.tables,b):G(c.layers,b)}function G(a,b){if(a){var c=
a.findIndex(({id:d})=>d===b.id);-1===c?a.push(b):a[c]=b}}function R(a){const {portalItem:b}=a;return z.isFeatureServiceLayer(a)&&!a.dynamicDataSource&&!!b?.loaded&&"Feature Service"===b.type}async function S(a){if(!a?.length)throw new k("feature-layer-utils-saveall:missing-parameters","'layers' array should contain at least one feature layer");await Promise.all(a.map(c=>c.load()));for(var b of a)if(!R(b))throw new k("feature-layer-utils-saveall:invalid-parameters",`'layers' array should only contain layers or tables in a feature service loaded from 'Feature Service' item. ${m(b,
"does not conform")}`,{layer:b});b=a.map(c=>c.portalItem.id);if(1<(new Set(b)).size)throw new k("feature-layer-utils-saveall:invalid-parameters","All layers in the 'layers' array should be loaded from the same portal item");a=a.map(c=>c.layerId);if((new Set(a)).size!==a.length)throw new k("feature-layer-utils-saveall:invalid-parameters","'layers' array should contain only one instance each of layer or table in a feature service");}async function T(a,b){const {url:c,layerId:d,title:e,fullExtent:f,
isTable:g}=a;a=J.parse(c);a=t.isSome(a)&&"FeatureServer"===a.serverType;b.url=a?c:`${c}/${d}`;b.title||(b.title=e);b.extent=null;!g&&t.isSome(f)&&(b.extent=await h.getWGS84ExtentForItem(f));h.removeTypeKeyword(b,h.TypeKeyword.METADATA);h.removeTypeKeyword(b,h.TypeKeyword.MULTI_LAYER);h.addTypeKeyword(b,h.TypeKeyword.SINGLE_LAYER);g&&h.addTypeKeyword(b,h.TypeKeyword.TABLE);x(b)}async function U(a,b,c){const d=a.portal;await d?.signIn();await d?.user?.addItem({item:a,data:b,folder:c?.folder})}const V=
r.getLogger("esri.layers.FeatureLayer");r=p.debounce(async function(a,b){await B(a);var c=a.portalItem;if(!c)throw V.error("save: requires the portalItem property to be set"),new k("feature-layer:portal-item-not-set",m(a,"requires the portalItem property to be set"));if(!c.loaded)throw new k("feature-layer:portal-item-not-loaded",m(a,"cannot be saved to a portal item that does not exist or is inaccessible"));A(a,c);c=a.portalItem;const d=v.createForItemWrite(c);b=await w(a,d,b);a=await D(c,[{layer:a,
layerJSON:b}]);x(c);await c.update({data:a});u.updateOrigins(d);return c});const W=p.debounce(async(a,b)=>{await S(a);const c=a[0].portalItem,d=v.createForItemWrite(c),e=await Promise.all(a.map(g=>w(g,d,b))),f=await D(c,a.map((g,l)=>({layer:g,layerJSON:e[l]})));x(c);await c.update({data:f});await Promise.all(a.slice(1).map(g=>g.portalItem.reload()));u.updateOrigins(d);return c.clone()}),X=p.debounce(async function(a,b,c){await B(a);var d,e;b=M.from(b);b.id&&(b=b.clone(),b.id=null);(d=b).type??(d.type=
"Feature Service");(e=b).portal??(e.portal=L.getDefault());A(a,b);d=b;e=v.createForItemWrite(d);b=await w(a,e,c);b=C({layer:a,layerJSON:b});await T(a,d);await U(d,b,c);a.portalItem=d;u.updateOrigins(e);return d});n.save=r;n.saveAll=W;n.saveAs=X;Object.defineProperty(n,Symbol.toStringTag,{value:"Module"})});