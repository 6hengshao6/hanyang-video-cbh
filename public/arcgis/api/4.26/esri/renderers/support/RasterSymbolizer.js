// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.27/esri/copyright.txt for details.
//>>built
define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/colorUtils ../../core/JSONSupport ../../core/Logger ../../core/maybe ../../core/accessorSupport/decorators/property ../../core/accessorSupport/ensureType ../../core/arrayUtils ../../core/has ../../core/accessorSupport/decorators/subclass ../../layers/support/RasterInfo ../../layers/support/rasterFunctions/pixelUtils ../../layers/support/rasterFunctions/stretchUtils ../../layers/support/rasterFunctions/surfaceUtils ./colorRampUtils".split(" "),
function(C,z,H,x,E,r,A,N,O,P,I,J,t,u,D,F){function K(l,w){const {attributeTable:y,bandCount:a}=l;return r.isNone(y)||1<a||w&&null==y.fields.find(b=>b.name.toLowerCase()===w.toLowerCase())?!1:!0}function L(l){const {bandCount:w,colormap:y}=l;return r.isSome(y)&&0<y.length&&1===w}function G(l){return t.isValidPixelBlock(l)&&0!==l.validPixelCount}x=function(l){function w(a){return y.call(this,a)}C._inherits(w,l);var y=C._createSuper(w);l=w.prototype;l.bind=function(){const {rendererJSON:a}=this;if(!a)return{success:!1};
this.lookup={rendererJSON:{}};let b;switch(a.type){case "uniqueValue":b=this._updateUVRenderer(a);break;case "rasterColormap":b=this._updateColormapRenderer(a);break;case "rasterStretch":b=this._updateStretchRenderer(a);break;case "classBreaks":b=this._updateClassBreaksRenderer(a);break;case "rasterShadedRelief":b=this._updateShadedReliefRenderer(a);break;case "vectorField":b=this._updateVectorFieldRenderer();break;case "flowRenderer":b=this._updateFlowRenderer()}return b};l.symbolize=function(a){let b=
a&&a.pixelBlock;if(!G(b))return b;if(a.simpleStretchParams&&"rasterStretch"===this.rendererJSON.type)return this.simpleStretch(b,a.simpleStretchParams);try{3<b.pixels.length&&(b=t.extractBands(b,[0,1,2]));let d;switch(this.rendererJSON.type){case "uniqueValue":case "rasterColormap":d=this._symbolizeColormap(b);break;case "classBreaks":d=this._symbolizeClassBreaks(b);break;case "rasterStretch":d=this._symbolizeStretch(b,a.bandIds);break;case "rasterShadedRelief":const f=a.extent;d=this._symbolizeShadedRelief(b,
{isGCS:f.spatialReference.isGeographic,resolution:{x:(f.xmax-f.xmin)/b.width,y:(f.ymax-f.ymin)/b.height}})}return d}catch(d){return E.getLogger(this.declaredClass).error("symbolize",d.message),b}};l.simpleStretch=function(a,b){if(!G(a))return a;try{return 3<a.pixels.length&&(a=t.extractBands(a,[0,1,2])),u.stretch(a,{...b,isRenderer:!0})}catch(d){return E.getLogger(this.declaredClass).error("symbolize",d.message),a}};l.generateWebGLParameters=function(a){if(["uniqueValue","rasterColormap","classBreaks"].includes(this.rendererJSON.type)){const {indexedColormap:c,
offset:k}=this.lookup.colormapLut||{};return{colormap:c,colormapOffset:k,type:"lut"}}const {pixelBlock:b,isGCS:d,resolution:f,bandIds:m}=a;({rendererJSON:a}=this);return"rasterStretch"===a.type?this._generateStretchWebGLParams(b,a,m):"rasterShadedRelief"===a.type?this._generateShadedReliefWebGLParams(a,d,f??void 0):"vectorField"===a.type?this._generateVectorFieldWebGLParams(a):null};l._isLUTChanged=function(a){if(!this.lookup||!this.lookup.rendererJSON)return!0;if("colorRamp"in this.rendererJSON){const b=
this.rendererJSON.colorRamp;if(a)return JSON.stringify(b)!==JSON.stringify(this.lookup.rendererJSON.colorRamp);({...this.rendererJSON});({...this.lookup.rendererJSON})}return JSON.stringify(this.rendererJSON)!==JSON.stringify(this.lookup.rendererJSON)};l._symbolizeColormap=function(a){return this._isLUTChanged()&&!this.bind().success?a:t.colorize(a,this.lookup.colormapLut)};l._symbolizeClassBreaks=function(a){const {canUseIndexedLUT:b}=this._analyzeClassBreaks(this.rendererJSON);return this._isLUTChanged()&&
!this.bind().success?a:b?t.colorize(a,this.lookup.colormapLut):t.remapColor(a,this.lookup.remapLut??[])};l._symbolizeStretch=function(a,b){const {rasterInfo:d}=this,{pixelType:f,bandCount:m}=d,c=this.rendererJSON;var k=["u8","u16","s8","s16"].includes(f);let e;var {dra:h}=c;({gamma:g}=this.lookup);if("histogramEqualization"===c.stretchType){k=h?null:this.lookup?.histogramLut;b=u.getStretchCutoff(c,{rasterInfo:d,pixelBlock:a,bandIds:b,returnHistogramLut:!k});var g=u.stretch(a,{...b,gamma:g,isRenderer:!0});
g=t.lookupPixels(g,{lut:h?b.histogramLut:k,offset:0})}else if(k){if(h)h=u.getStretchCutoff(c,{rasterInfo:d,pixelBlock:a,bandIds:b}),e=u.createStretchLUT({pixelType:f,...h,gamma:g,rounding:"floor"});else{if(this._isLUTChanged()&&!this.bind().success)return a;e=this.lookup?this.lookup.stretchLut:null}if(!e)return a;1<m&&b?.length===r.unwrap(a)?.pixels.length&&e?.lut.length===m&&(e={lut:b.map(n=>e.lut[n]),offset:e.offset});g=t.lookupPixels(a,e)}else h=u.getStretchCutoff(c,{rasterInfo:d,pixelBlock:a,
bandIds:b}),g=u.stretch(a,{...h,gamma:g,isRenderer:!0});if(c.colorRamp){if(this._isLUTChanged(!0)&&!this.bind().success)return a;g=t.colorize(g,this.lookup?.colormapLut)}return g};l._symbolizeShadedRelief=function(a,b){var d=this.rendererJSON;b=D.hillshade(a,{...d,...b});if(!d.colorRamp||this._isLUTChanged(!0)&&!this.bind().success)return b;d=this.lookup?this.lookup.hsvMap:null;if(!d)return b;const f=r.unwrap(this.rasterInfo.statistics)?.[0]??{min:0,max:8E3};D.tintHillshade(b,a,d,f);return b};l._isVectorFieldData=
function(){const {bandCount:a,dataType:b}=this.rasterInfo;return 2===a&&("vector-magdir"===b||"vector-uv"===b)};l._updateVectorFieldRenderer=function(){return this._isVectorFieldData()?{success:!0}:{success:!1,error:`Unsupported data type "${this.rasterInfo.dataType}"; VectorFieldRenderer only supports "vector-magdir" and "vector-uv".`}};l._updateFlowRenderer=function(){return this._isVectorFieldData()?{success:!0}:{success:!1,error:`Unsupported data type "${this.rasterInfo.dataType}"; FlowRenderer only supports "vector-magdir" and "vector-uv".`}};
l._updateUVRenderer=function(a){const {bandCount:b,attributeTable:d,pixelType:f}=this.rasterInfo,m=a.field1;if(!m)return{success:!1,error:"Unsupported renderer; missing UniqueValueRenderer.field."};const c=a.defaultSymbol;var k=1===b&&["u8","s8"].includes(f);if(!K(this.rasterInfo,m)&&!k)return{success:!1,error:"Unsupported data; UniqueValueRenderer is only supported on single band data with a valid raster attribute table."};const e=[];if(r.isSome(d)){const h=d.fields.find(g=>"value"===g.name.toLowerCase());
if(!h)return{success:!1,error:"Unsupported data; the data's raster attribute table does not have a value field."};d.features.forEach(g=>{const n=a.uniqueValueInfos?.find(q=>String(q.value)===String(g.attributes[m]))?.symbol?.color;n?e.push([g.attributes[h.name]].concat(n)):c&&e.push([g.attributes[h.name]].concat(c.color))})}else{if("value"!==m.toLowerCase())return{success:!1,error:'Unsupported renderer; UniqueValueRenderer.field must be "Value" when raster attribute table is not availalbe.'};a.uniqueValueInfos?.forEach(h=>
{const g=h?.symbol?.color;g?e.push([parseInt(""+h.value,10)].concat(g)):c&&e.push([parseInt(""+h.value,10)].concat(c?.color))})}if(0===e.length)return{success:!1,error:"Invalid UniqueValueRenderer. Cannot find matching records in the raster attribute table."};k=t.createColormapLUT({colormap:e});this.lookup={rendererJSON:a,colormapLut:k};this.canRenderInWebGL=!0;return{success:!0}};l._updateColormapRenderer=function(a){if(!L(this.rasterInfo))return{success:!1,error:"Unsupported data; the data source does not have a colormap."};
var b=a.colormapInfos.map(d=>[d.value].concat(d.color)).sort((d,f)=>d[0]-f[0]);if(!b||0===b.length)return{success:!1,error:"Unsupported renderer; ColormapRenderer must have meaningful colormapInfos."};b=t.createColormapLUT({colormap:b});this.lookup={rendererJSON:a,colormapLut:b};this.canRenderInWebGL=!0;return{success:!0}};l._updateShadedReliefRenderer=function(a){const {bandCount:b,dataType:d,pixelType:f}=this.rasterInfo;if("elevation"!==d&&("generic"!==d||1!==b||"s16"!==f&&"f32"!==f&&"f64"!==f))return{success:!1,
error:`Unsupported data type "${this.rasterInfo.dataType}"; ShadedReliefRenderer only supports "elevation", or single band float/s16 data.`};if(a.colorRamp){var m=F.convertColorRampToColormap(a.colorRamp,{interpolateAlpha:!0});m=t.createColormapLUT({colormap:m});const c=[],k=m.indexedColormap;for(let e=0;e<k.length;e+=4){const h=H.toHSV({r:k[e],g:k[e+1],b:k[e+2]});c.push([h.h/60,h.s/100,255*h.v/100])}this.lookup={rendererJSON:a,colormapLut:m,hsvMap:c}}else this.lookup=null;this.canRenderInWebGL=!0;
return{success:!0}};l._analyzeClassBreaks=function(a){const {attributeTable:b,pixelType:d}=this.rasterInfo,f=r.isSome(b)?b.fields.find(k=>"value"===k.name.toLowerCase()):null,m=r.isSome(b)?b.fields.find(k=>k.name.toLowerCase()===a.field.toLowerCase()):null,c=null!=f&&null!==m;return{canUseIndexedLUT:["u8","u16","s8","s16"].includes(d)||c,tableValueField:f,tableBreakField:m}};l._updateClassBreaksRenderer=function(a){var {attributeTable:b}=this.rasterInfo;const {canUseIndexedLUT:d,tableValueField:f,
tableBreakField:m}=this._analyzeClassBreaks(a);var c=a.classBreakInfos;if(!c?.length)return{success:!1,error:"Unsupported renderer; missing or invalid ClassBreaksRenderer.classBreakInfos."};c=c.sort((n,q)=>n.classMaxValue-q.classMaxValue);var k=c[c.length-1],e=a.minValue;if(!d){var h=[];for(var g=0;g<c.length;g++)h.push({value:c[g].classMinValue??e,mappedColor:c[g].symbol.color}),e=c[g].classMaxValue;h.push({value:k.classMaxValue,mappedColor:k.symbol.color});this.lookup={rendererJSON:a,remapLut:h};
this.canRenderInWebGL=!1;return{success:!0}}h=[];if(r.isSome(b)&&null!=f&&null!==m&&f!==m){k=f.name;const n=m.name,q=c[c.length-1],{classMaxValue:p}=q;e=a.minValue;for(g of b.features){b=g.attributes[k];const v=g.attributes[n],B=v===p?q:v<e?null:c.find(({classMaxValue:M})=>M>v);B&&h.push([b].concat(B.symbol.color))}}else{e=Math.floor(a.minValue);for(g=0;g<c.length;g++){for(b=c[g];e<b.classMaxValue;e++)h.push([e].concat(b.symbol.color));e=Math.ceil(b.classMaxValue)}k.classMaxValue===e&&h.push([k.classMaxValue].concat(k.symbol.color))}c=
t.createColormapLUT({colormap:h,fillUnspecified:!1});this.lookup={rendererJSON:a,colormapLut:c};this.canRenderInWebGL=!0;return{success:!0}};l._isHistogramRequired=function(a){return"percentClip"===a||"histogramEqualization"===a};l._isValidRasterStatistics=function(a){return r.isSome(a)&&0<a.length&&null!=a[0].min&&null!=a[0].max};l._updateStretchRenderer=function(a){let {stretchType:b,dra:d}=a;if(!("none"===b||a.statistics?.length||this._isValidRasterStatistics(this.rasterInfo.statistics)||d))return{success:!1,
error:"Unsupported renderer; StretchRenderer.statistics is required when dynamic range adjustment is not used."};var f=r.unwrap(a.histograms||this.rasterInfo.histograms);!this._isHistogramRequired(a.stretchType)||f?.length||d||(b="minMax");const {computeGamma:m,useGamma:c,colorRamp:k}=a;var {gamma:e}=a;c&&m&&!e?.length&&(e=a.statistics?.length?a.statistics:r.unwrap(this.rasterInfo.statistics),e=u.computeGammaValues(this.rasterInfo.pixelType,e));const h=this.rasterInfo.pixelType,g=!d&&["u8","u16",
"s8","s16"].includes(h);"histogramEqualization"===b?(f=f.map(n=>u.createHistogramEqualizationLUT(n)),this.lookup={rendererJSON:a,histogramLut:f}):g&&(f=u.getStretchCutoff(a,{rasterInfo:this.rasterInfo}),f=u.createStretchLUT({pixelType:h,...f,gamma:c?e:null,rounding:"floor"}),this.lookup={rendererJSON:a,stretchLut:f});k&&(f=F.convertColorRampToColormap(k,{interpolateAlpha:!0}),this.lookup||(this.lookup={rendererJSON:a}),this.lookup.colormapLut=t.createColormapLUT({colormap:f}),this.lookup.rendererJSON=
a);this.lookup.gamma=c&&e?.length?e:null;this.canRenderInWebGL=!0;return{success:!0}};l._generateStretchWebGLParams=function(a,b,d){let f=null,m=null;var c=this.lookup&&this.lookup.colormapLut;b.colorRamp&&c&&(f=c.indexedColormap,m=c.offset);"histogramEqualization"===b.stretchType&&(b={...b,stretchType:"minMax"});({gamma:c}=this.lookup);const k=!!(b.useGamma&&c&&c.some(B=>1!==B)),{minCutOff:e,maxCutOff:h,outMin:g,outMax:n}=u.getStretchCutoff(b,{rasterInfo:this.rasterInfo,pixelBlock:a,bandIds:d});
var q=0;r.isSome(a)&&(q=a.getPlaneCount(),2===q&&(a=a.clone(),a.statistics=[a.statistics[0]],a.pixels=[a.pixels[0]]));({bandCount:a}=this.rasterInfo);d=Math.min(3,d?.length||q||a,a);a=new Float32Array(d);q=f||k?1:255;let p;for(p=0;p<e.length;p++)a[p]=h[p]===e[p]?0:(n-g)/(h[p]-e[p])/q;const v=new Float32Array(d);if(k&&c)for(p=0;p<d;p++)v[p]=1<c[p]?2<c[p]?6.5+(c[p]-2)**2.5:6.5+100*(2-c[p])**4:1;return{bandCount:d,outMin:g/q,outMax:n/q,minCutOff:e,maxCutOff:h,factor:a,useGamma:k,gamma:k?c:[1,1,1],gammaCorrection:k?
v:[1,1,1],colormap:f,colormapOffset:m,stretchType:b.stretchType,type:"stretch"}};l._generateShadedReliefWebGLParams=function(a,b=!1,d={x:0,y:0}){let f=null,m=null;const c=this.lookup&&this.lookup.colormapLut;a.colorRamp&&c&&(f=c.indexedColormap,m=c.offset);b=D.calculateHillshadeParams({...a,isGCS:b,resolution:d});d=r.unwrap(this.rasterInfo.statistics)?.[0];return{...b,minValue:d?.min??0,maxValue:d?.max??8E3,hillshadeType:"traditional"===a.hillshadeType?0:1,type:"hillshade",colormap:f,colormapOffset:m}};
l._generateVectorFieldWebGLParams=function(a){const {style:b,inputUnit:d,outputUnit:f,visualVariables:m,symbolTileSize:c,flowRepresentation:k}=a;let e;var h=this.rasterInfo.statistics?.[0].min??0,g=this.rasterInfo.statistics?.[0].max??50,n=m?.find(v=>"sizeInfo"===v.type)??{type:"sizeInfo",field:"Magnitude",maxDataValue:g,maxSize:.8*c,minDataValue:h,minSize:.2*c},q=n.minDataValue??h,p=n.maxDataValue??g;g=r.isSome(n.maxSize)&&r.isSome(n.minSize)?[n.minSize/c,n.maxSize/c]:[.2,.8];"wind_speed"===b&&(g[0]=
g[1]=(g[0]+g[1])/2);h=r.isSome(q)&&r.isSome(p)?[q,p]:null;if("classified_arrow"===b)if(r.isSome(q)&&r.isSome(p)&&r.isSome(n))for(e=[],q=(n.maxDataValue-n.minDataValue)/5,p=0;6>p;p++)e.push(n.minDataValue+q*p);else e=[0,1E-6,3.5,7,10.5,14];n="flow_to"===k===("ocean_current_kn"===b||"ocean_current_m"===b)?0:Math.PI;q=m?.find(v=>"rotationInfo"===v.type);return{breakValues:e,dataRange:h,inputUnit:d,outputUnit:f,symbolTileSize:c,symbolPercentRange:g,style:b||"single_arrow",rotation:n,rotationType:this.rasterInfo.storageInfo?.tileInfo&&
"vector-uv"===this.rasterInfo.dataType?"geographic":q?.rotationType||a.rotationType,type:"vectorField"}};return C._createClass(w)}(x.JSONSupport);z.__decorate([A.property({json:{write:!0}})],x.prototype,"rendererJSON",void 0);z.__decorate([A.property({type:J,json:{write:!0}})],x.prototype,"rasterInfo",void 0);z.__decorate([A.property({json:{write:!0}})],x.prototype,"lookup",void 0);z.__decorate([A.property()],x.prototype,"canRenderInWebGL",void 0);return x=z.__decorate([I.subclass("esri.renderers.support.RasterSymbolizer")],
x)});